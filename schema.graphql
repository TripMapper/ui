type Account implements Node {
  affiliateOnBoardingComplete: Boolean!

  """When this item was archived"""
  archivedAt: Datetime

  """When this item was created"""
  createdAt: Datetime

  """Whether this user is eligible for a free trial"""
  eligibleForTrial: Boolean
  email: String
  emailConfirmed: Datetime

  """Lists features the user has early access to"""
  featurePreview: [String]

  """
  **Readonly**  
  The date this user first subscribed
  """
  firstSubscriptionDate: Datetime

  """The date their account will be reverted to free tier"""
  gratisEndDate: Datetime

  """Is this user currently in a trail?"""
  inTrial: Boolean

  """**Readonly**"""
  isAffiliate: Boolean

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  phone: String

  """When this item was restored"""
  restoredAt: Datetime
  role: Role!
  stripeCustomerId: String

  """
  **Readonly**  
  The unique identifier of this subscription, given by the origin. `transactionReceipt` for iOS, `purchaseToken` for Android, `sub_` id for Stripe.
  """
  subscriptionIdentifier: String

  """
  **Readonly**  
  The origin of their current subscription
  """
  subscriptionOrigin: SubscriptionOrigin
  tier: Tier!

  """When this item was updated"""
  updatedAt: Datetime

  """Reads a single `User` that is related to this `Account`."""
  user: User
  userId: UUID!
}

"""The fields on `account` to look up the row to connect."""
input AccountAccountEmailKeyConnect {
  email: String!
}

"""The fields on `account` to look up the row to connect."""
input AccountAccountPkeyConnect {
  userId: UUID!
}

"""The fields on `account` to look up the row to connect."""
input AccountAccountStripeCustomerIdKeyConnect {
  stripeCustomerId: String!
}

"""
A filter to be used against `Account` object types. All fields are combined with a logical ‘and.’
"""
input AccountFilter {
  """Checks for all expressions in this list."""
  and: [AccountFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `eligibleForTrial` field."""
  eligibleForTrial: BooleanFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `emailConfirmed` field."""
  emailConfirmed: DatetimeFilter

  """Filter by the object’s `featurePreview` field."""
  featurePreview: StringListFilter

  """Filter by the object’s `firstSubscriptionDate` field."""
  firstSubscriptionDate: DatetimeFilter

  """Filter by the object’s `gratisEndDate` field."""
  gratisEndDate: DatetimeFilter

  """Filter by the object’s `inTrial` field."""
  inTrial: BooleanFilter

  """Filter by the object’s `isAffiliate` field."""
  isAffiliate: BooleanFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Negates the expression."""
  not: AccountFilter

  """Checks for any expressions in this list."""
  or: [AccountFilter!]

  """Filter by the object’s `phone` field."""
  phone: StringFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `role` field."""
  role: RoleFilter

  """Filter by the object’s `stripeCustomerId` field."""
  stripeCustomerId: StringFilter

  """Filter by the object’s `subscriptionIdentifier` field."""
  subscriptionIdentifier: StringFilter

  """Filter by the object’s `subscriptionOrigin` field."""
  subscriptionOrigin: SubscriptionOriginFilter

  """Filter by the object’s `tier` field."""
  tier: TierFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""The globally unique `ID` look up for the row to connect."""
input AccountNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input AccountOnAccountForAccountUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `account` to look up the row to update."""
input AccountOnAccountForAccountUserIdFkeyUsingAccountEmailKeyUpdate {
  email: String!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountUserIdFkeyPatch!
}

"""The fields on `account` to look up the row to update."""
input AccountOnAccountForAccountUserIdFkeyUsingAccountPkeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountUserIdFkeyPatch!
  userId: UUID!
}

"""The fields on `account` to look up the row to update."""
input AccountOnAccountForAccountUserIdFkeyUsingAccountStripeCustomerIdKeyUpdate {
  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: updateAccountOnAccountForAccountUserIdFkeyPatch!
  stripeCustomerId: String!
}

"""
Represents an update to a `Account`. Fields that are set will be updated.
"""
input AccountPatch {
  email: String
  emailConfirmed: Datetime

  """Lists features the user has early access to"""
  featurePreview: [String]

  """The date their account will be reverted to free tier"""
  gratisEndDate: Datetime

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  phone: String
  role: Role
  stripeCustomerId: String
  tier: Tier
  user: AccountUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `user` in the `AccountInput` mutation.
"""
input AccountUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnAccountForAccountUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: AccountOnAccountForAccountUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `account` in the `UserInput` mutation.
"""
input AccountUserIdFkeyInverseInput {
  """The primary key(s) for `account` for the far side of the relationship."""
  connectByEmail: AccountAccountEmailKeyConnect

  """The primary key(s) for `account` for the far side of the relationship."""
  connectByNodeId: AccountNodeIdConnect

  """The primary key(s) for `account` for the far side of the relationship."""
  connectByStripeCustomerId: AccountAccountStripeCustomerIdKeyConnect

  """The primary key(s) for `account` for the far side of the relationship."""
  connectByUserId: AccountAccountPkeyConnect

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByEmail: AccountOnAccountForAccountUserIdFkeyUsingAccountEmailKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByNodeId: UserOnAccountForAccountUserIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByStripeCustomerId: AccountOnAccountForAccountUserIdFkeyUsingAccountStripeCustomerIdKeyUpdate

  """
  The primary key(s) and patch data for `account` for the far side of the relationship.
  """
  updateByUserId: AccountOnAccountForAccountUserIdFkeyUsingAccountPkeyUpdate
}

"""A `Account` edge in the connection."""
type AccountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Account` at the end of the edge."""
  node: Account!
}

"""Methods to use when ordering `Account`."""
enum AccountsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAIL_ASC
  EMAIL_CONFIRMED_ASC
  EMAIL_CONFIRMED_DESC
  EMAIL_DESC
  FEATURE_PREVIEW_ASC
  FEATURE_PREVIEW_DESC
  FIRST_SUBSCRIPTION_DATE_ASC
  FIRST_SUBSCRIPTION_DATE_DESC
  GRATIS_END_DATE_ASC
  GRATIS_END_DATE_DESC
  IS_AFFILIATE_ASC
  IS_AFFILIATE_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NATURAL
  PHONE_ASC
  PHONE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  ROLE_ASC
  ROLE_DESC
  STRIPE_CUSTOMER_ID_ASC
  STRIPE_CUSTOMER_ID_DESC
  SUBSCRIPTION_IDENTIFIER_ASC
  SUBSCRIPTION_IDENTIFIER_DESC
  SUBSCRIPTION_ORIGIN_ASC
  SUBSCRIPTION_ORIGIN_DESC
  TIER_ASC
  TIER_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""All input for the `acquireLock` mutation."""
input AcquireLockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  key: String!
}

"""The output of our `acquireLock` mutation."""
type AcquireLockPayload {
  boolean: Boolean

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `addColumn` mutation."""
input AddColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  insertAfter: Int
  insertBefore: Int
  tripId: UUID!
}

"""The output of our `addColumn` mutation."""
type AddColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `addExpoPushToken` mutation."""
input AddExpoPushTokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  token: String!
}

"""The output of our `addExpoPushToken` mutation."""
type AddExpoPushTokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `agentDeleteAccount` mutation."""
input AgentDeleteAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `agentDeleteAccount` mutation."""
type AgentDeleteAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Airline implements Node {
  """When this item was created"""
  createdAt: Datetime
  facebook: String
  iata: String!
  instagram: String
  linkedin: String
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  twitter: String

  """When this item was updated"""
  updatedAt: Datetime
  website: String
}

type Airport implements Node {
  cityName: String

  """Reads a single `Country` that is related to this `Airport`."""
  country: Country
  countryId: UUID

  """When this item was created"""
  createdAt: Datetime
  facebook: String
  iata: String!
  instagram: String
  linkedin: String
  location: Location
  name: String!
  namesI18N: JSON

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  phone: String
  timezoneName: String
  twitter: String

  """When this item was updated"""
  updatedAt: Datetime
  website: String
}

"""The fields on `airport` to look up the row to connect."""
input AirportAirportPkeyConnect {
  iata: String!
}

"""The `country` to be created by this mutation."""
input AirportCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `AirportInput` mutation.
"""
input AirportCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: AirportCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnAirportForAirportCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnAirportForAirportCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: AirportOnAirportForAirportCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnAirportForAirportCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `airport` in the `CountryInput` mutation.
"""
input AirportCountryIdFkeyInverseInput {
  """The primary key(s) for `airport` for the far side of the relationship."""
  connectByIata: [AirportAirportPkeyConnect!]

  """The primary key(s) for `airport` for the far side of the relationship."""
  connectByNodeId: [AirportNodeIdConnect!]

  """
  The primary key(s) and patch data for `airport` for the far side of the relationship.
  """
  updateByIata: [AirportOnAirportForAirportCountryIdFkeyUsingAirportPkeyUpdate!]

  """
  The primary key(s) and patch data for `airport` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnAirportForAirportCountryIdFkeyNodeIdUpdate!]
}

"""The globally unique `ID` look up for the row to connect."""
input AirportNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `airport` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input AirportOnAirportForAirportCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `airport` to look up the row to update."""
input AirportOnAirportForAirportCountryIdFkeyUsingAirportPkeyUpdate {
  iata: String!

  """
  An object where the defined keys will be set on the `airport` being updated.
  """
  patch: updateAirportOnAirportForAirportCountryIdFkeyPatch!
}

"""
Represents an update to a `Airport`. Fields that are set will be updated.
"""
input AirportPatch {
  cityName: String
  country: AirportCountryIdFkeyInput
  countryId: UUID
  facebook: String
  iata: String
  instagram: String
  linkedin: String
  location: LocationInput
  name: String
  namesI18N: JSON
  phone: String
  timezoneName: String
  twitter: String
  website: String
}

"""A connection to a list of `Airport` values."""
type AirportsConnection {
  """
  A list of edges which contains the `Airport` and cursor to aid in pagination.
  """
  edges: [AirportsEdge!]!

  """A list of `Airport` objects."""
  nodes: [Airport!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Airport` you could get from the connection."""
  totalCount: Int!
}

"""A `Airport` edge in the connection."""
type AirportsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Airport` at the end of the edge."""
  node: Airport!
}

"""All input for the `archiveByDay` mutation."""
input ArchiveByDayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  day: Int!
  tripId: UUID!
}

"""The output of our `archiveByDay` mutation."""
type ArchiveByDayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Asset implements Node {
  attribution: AssetAttribution

  """Reads and enables pagination through a set of `Card`."""
  cardsByImageId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsConnection!

  """Reads and enables pagination through a set of `Card`."""
  cardsByImageIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!]
  ): [Card!]!

  """Reads and enables pagination through a set of `Country`."""
  countriesByImageId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesConnection!

  """Reads and enables pagination through a set of `Country`."""
  countriesByImageIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
  ): [Country!]!

  """When this item was created"""
  createdAt: Datetime
  encoding: String
  file: JSON!
  filename: String
  height: Int
  id: UUID!
  mimetype: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `Organisation`."""
  organisationsByLogoId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsConnection!

  """Reads and enables pagination through a set of `Organisation`."""
  organisationsByLogoIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!]
  ): [Organisation!]!

  """Reads a single `User` that is related to this `Asset`."""
  owner: User
  ownerId: UUID

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesByBackgroundId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesConnection!

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesByBackgroundIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!]
  ): [PartnerPage!]!

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesByLogoId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesConnection!

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesByLogoIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!]
  ): [PartnerPage!]!
  path: String
  placeholderUri(aspect: Float, height: Int, width: Int): String @deprecated(reason: "Use Srcset.placeholder")
  placeholderUrl(aspect: Float, height: Int, width: Int): String

  """Reads and enables pagination through a set of `Region`."""
  regionsByImageId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsConnection!

  """Reads and enables pagination through a set of `Region`."""
  regionsByImageIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!]
  ): [Region!]!
  src(aspect: Float, height: Int, webp: Boolean, width: Int): String
  srcset(aspect: Float, height: Int, width: Int): Srcset

  """Reads and enables pagination through a set of `Supplier`."""
  suppliersByLogoId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersConnection!

  """Reads and enables pagination through a set of `Supplier`."""
  suppliersByLogoIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!]
  ): [Supplier!]!

  """Reads and enables pagination through a set of `TripAssetImage`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripAssetImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripAssetImageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripAssetImagesConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsByImageId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsByImageIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]!

  """Reads and enables pagination through a set of `TripAssetImage`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripAssetImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripAssetImageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!]
  ): [TripAssetImage!]!

  """When this item was updated"""
  updatedAt: Datetime
  url(align: AssetAlignInput, aspect: Float, contain: Boolean, crop: AssetPositionInput, fit: AssetFit, height: Int, uniqueKey: String, width: Int): String @deprecated(reason: "Use `Asset.src`")

  """Reads and enables pagination through a set of `User`."""
  usersByAvatarId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersConnection!

  """Reads and enables pagination through a set of `User`."""
  usersByAvatarIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
  ): [User!]!

  """Reads and enables pagination through a set of `ViewerOrganisation`."""
  viewerOrganisationsByLogoId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ViewerOrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ViewerOrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ViewerOrganisation`."""
    orderBy: [ViewerOrganisationsOrderBy!] = [NATURAL]
  ): ViewerOrganisationsConnection!

  """Reads and enables pagination through a set of `ViewerOrganisation`."""
  viewerOrganisationsByLogoIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ViewerOrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ViewerOrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ViewerOrganisation`."""
    orderBy: [ViewerOrganisationsOrderBy!]
  ): [ViewerOrganisation!]!
  width: Int
}

"""An input for mutations affecting `AssetAlign`"""
input AssetAlignInput {
  horizontal: Int
  vertical: Int
}

"""The fields on `asset` to look up the row to connect."""
input AssetAssetPkeyConnect {
  id: UUID!
}

"""The fields on `asset` to look up the row to delete."""
input AssetAssetPkeyDelete {
  id: UUID!
}

type AssetAttribution {
  name: String
  url: String
}

"""
A filter to be used against `AssetAttribution` object types. All fields are combined with a logical ‘and.’
"""
input AssetAttributionFilter {
  """Checks for all expressions in this list."""
  and: [AssetAttributionFilter!]

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: AssetAttributionFilter

  """Checks for any expressions in this list."""
  or: [AssetAttributionFilter!]

  """Filter by the object’s `url` field."""
  url: StringFilter
}

"""An input for mutations affecting `AssetAttribution`"""
input AssetAttributionInput {
  name: String
  url: String
}

"""
A condition to be used against `Asset` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AssetCondition {
  """Checks for equality with the object’s `attribution` field."""
  attribution: AssetAttributionInput

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `file` field."""
  file: JSON

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `ownerId` field."""
  ownerId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `Asset` object types. All fields are combined with a logical ‘and.’
"""
input AssetFilter {
  """Checks for all expressions in this list."""
  and: [AssetFilter!]

  """Filter by the object’s `attribution` field."""
  attribution: AssetAttributionFilter

  """Filter by the object’s `cardsByImageId` relation."""
  cardsByImageId: AssetToManyCardFilter

  """Some related `cardsByImageId` exist."""
  cardsByImageIdExist: Boolean

  """Filter by the object’s `countriesByImageId` relation."""
  countriesByImageId: AssetToManyCountryFilter

  """Some related `countriesByImageId` exist."""
  countriesByImageIdExist: Boolean

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `encoding` field."""
  encoding: StringFilter

  """Filter by the object’s `file` field."""
  file: JSONFilter

  """Filter by the object’s `filename` field."""
  filename: StringFilter

  """Filter by the object’s `height` field."""
  height: IntFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `mimetype` field."""
  mimetype: StringFilter

  """Negates the expression."""
  not: AssetFilter

  """Checks for any expressions in this list."""
  or: [AssetFilter!]

  """Filter by the object’s `organisationsByLogoId` relation."""
  organisationsByLogoId: AssetToManyOrganisationFilter

  """Some related `organisationsByLogoId` exist."""
  organisationsByLogoIdExist: Boolean

  """Filter by the object’s `owner` relation."""
  owner: UserFilter

  """A related `owner` exists."""
  ownerExists: Boolean

  """Filter by the object’s `ownerId` field."""
  ownerId: UUIDFilter

  """Filter by the object’s `partnerPagesByBackgroundId` relation."""
  partnerPagesByBackgroundId: AssetToManyPartnerPageFilter

  """Some related `partnerPagesByBackgroundId` exist."""
  partnerPagesByBackgroundIdExist: Boolean

  """Filter by the object’s `partnerPagesByLogoId` relation."""
  partnerPagesByLogoId: AssetToManyPartnerPageFilter

  """Some related `partnerPagesByLogoId` exist."""
  partnerPagesByLogoIdExist: Boolean

  """Filter by the object’s `path` field."""
  path: StringFilter

  """Filter by the object’s `placeholderUrl` field."""
  placeholderUrl: StringFilter

  """Filter by the object’s `referrersByBackgroundId` relation."""
  referrersByBackgroundId: AssetToManyReferrerFilter

  """Some related `referrersByBackgroundId` exist."""
  referrersByBackgroundIdExist: Boolean

  """Filter by the object’s `referrersByLogoId` relation."""
  referrersByLogoId: AssetToManyReferrerFilter

  """Some related `referrersByLogoId` exist."""
  referrersByLogoIdExist: Boolean

  """Filter by the object’s `regionsByImageId` relation."""
  regionsByImageId: AssetToManyRegionFilter

  """Some related `regionsByImageId` exist."""
  regionsByImageIdExist: Boolean

  """Filter by the object’s `src` field."""
  src: StringFilter

  """Filter by the object’s `suppliersByLogoId` relation."""
  suppliersByLogoId: AssetToManySupplierFilter

  """Some related `suppliersByLogoId` exist."""
  suppliersByLogoIdExist: Boolean

  """Filter by the object’s `trips` relation."""
  trips: AssetToManyTripAssetImageFilter

  """Filter by the object’s `tripsByImageId` relation."""
  tripsByImageId: AssetToManyTripFilter

  """Some related `tripsByImageId` exist."""
  tripsByImageIdExist: Boolean

  """Some related `trips` exist."""
  tripsExist: Boolean

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `url` field."""
  url: StringFilter

  """Filter by the object’s `usersByAvatarId` relation."""
  usersByAvatarId: AssetToManyUserFilter

  """Some related `usersByAvatarId` exist."""
  usersByAvatarIdExist: Boolean

  """Filter by the object’s `viewerOrganisationsByLogoId` relation."""
  viewerOrganisationsByLogoId: AssetToManyViewerOrganisationFilter

  """Some related `viewerOrganisationsByLogoId` exist."""
  viewerOrganisationsByLogoIdExist: Boolean

  """Filter by the object’s `width` field."""
  width: IntFilter
}

enum AssetFit {
  ADAPTIVE
  FULL
  IN
}

"""An input for mutations affecting `Asset`"""
input AssetInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""The globally unique `ID` look up for the row to connect."""
input AssetNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input AssetNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `asset` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnAssetForAssetOwnerIdNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnAssetForAssetOwnerIdUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnAssetForAssetOwnerIdPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnCardForCardImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnCardForCardImageIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnCardForCardImageIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnCountryForCountryImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnCountryForCountryImageIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnCountryForCountryImageIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnOrganisationForOrganisationLogoIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnOrganisationForOrganisationLogoIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnOrganisationForOrganisationLogoIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnPartnerPageForPartnerPageBackgroundIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `partnerPage` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: PartnerPagePatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnPartnerPageForPartnerPageBackgroundIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnPartnerPageForPartnerPageBackgroundIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnPartnerPageForPartnerPageLogoIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `partnerPage` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: PartnerPagePatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnRegionForRegionImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `region` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: RegionPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnRegionForRegionImageIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnRegionForRegionImageIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnSupplierForSupplierLogoIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnSupplierForSupplierLogoIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnSupplierForSupplierLogoIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnTripAssetImageForTripAssetImageAssetIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tripAssetImage` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tripAssetImage` being updated.
  """
  patch: TripAssetImagePatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnTripAssetImageForTripAssetImageAssetIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnTripAssetImageForTripAssetImageAssetIdFkeyPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnTripForTripImageIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnTripForTripImageIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AssetOnUserForUserAvatarIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnUserForUserAvatarIdFkeyUsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnUserForUserAvatarIdFkeyPatch!
}

"""The fields on `asset` to look up the row to update."""
input AssetOnViewerOrganisationForFakePublicViewerOrganisationsForeignKey0UsingAssetPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: updateAssetOnViewerOrganisationForFakePublicViewerOrganisationsForeignKey0Patch!
}

"""The `asset` to be created by this mutation."""
input AssetOwnerIdAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""Input for the nested mutation of `user` in the `AssetInput` mutation."""
input AssetOwnerIdInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnAssetForAssetOwnerIdUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: AssetOnAssetForAssetOwnerIdNodeIdUpdate
}

"""Input for the nested mutation of `asset` in the `UserInput` mutation."""
input AssetOwnerIdInverseInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: [AssetAssetPkeyConnect!]

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: [AssetNodeIdConnect!]

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: [AssetOwnerIdAssetCreateInput!]

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: [AssetAssetPkeyDelete!]

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: [AssetNodeIdDelete!]

  """
  Flag indicating whether all other `asset` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: [AssetOnAssetForAssetOwnerIdUsingAssetPkeyUpdate!]

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: [UserOnAssetForAssetOwnerIdNodeIdUpdate!]
}

"""
Represents an update to a `Asset`. Fields that are set will be updated.
"""
input AssetPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""An input for mutations affecting `AssetPosition`"""
input AssetPositionInput {
  bottom: Int
  left: Int
  right: Int
  top: Int
}

"""
A filter to be used against many `Card` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyCardFilter {
  """
  Every related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CardFilter

  """
  No related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CardFilter

  """
  Some related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CardFilter
}

"""
A filter to be used against many `Country` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyCountryFilter {
  """
  Every related `Country` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CountryFilter

  """
  No related `Country` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CountryFilter

  """
  Some related `Country` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CountryFilter
}

"""
A filter to be used against many `Organisation` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyOrganisationFilter {
  """
  Every related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationFilter

  """
  No related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationFilter

  """
  Some related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationFilter
}

"""
A filter to be used against many `PartnerPage` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyPartnerPageFilter {
  """
  Every related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PartnerPageFilter

  """
  No related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PartnerPageFilter

  """
  Some related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PartnerPageFilter
}

"""
A filter to be used against many `Referrer` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyReferrerFilter {
  """
  Every related `Referrer` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ReferrerFilter

  """
  No related `Referrer` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ReferrerFilter

  """
  Some related `Referrer` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ReferrerFilter
}

"""
A filter to be used against many `Region` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyRegionFilter {
  """
  Every related `Region` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RegionFilter

  """
  No related `Region` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RegionFilter

  """
  Some related `Region` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RegionFilter
}

"""
A filter to be used against many `Supplier` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManySupplierFilter {
  """
  Every related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SupplierFilter

  """
  No related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SupplierFilter

  """
  Some related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SupplierFilter
}

"""
A filter to be used against many `TripAssetImage` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyTripAssetImageFilter {
  """
  Every related `TripAssetImage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripAssetImageFilter

  """
  No related `TripAssetImage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripAssetImageFilter

  """
  Some related `TripAssetImage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripAssetImageFilter
}

"""
A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyTripFilter {
  """
  Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripFilter

  """
  No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripFilter

  """
  Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripFilter
}

"""
A filter to be used against many `User` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyUserFilter {
  """
  Every related `User` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: UserFilter

  """
  No related `User` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: UserFilter

  """
  Some related `User` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: UserFilter
}

"""
A filter to be used against many `ViewerOrganisation` object types. All fields are combined with a logical ‘and.’
"""
input AssetToManyViewerOrganisationFilter {
  """
  Every related `ViewerOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ViewerOrganisationFilter

  """
  No related `ViewerOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ViewerOrganisationFilter

  """
  Some related `ViewerOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ViewerOrganisationFilter
}

"""A connection to a list of `Asset` values."""
type AssetsConnection {
  """
  A list of edges which contains the `Asset` and cursor to aid in pagination.
  """
  edges: [AssetsEdge!]!

  """A list of `Asset` objects."""
  nodes: [Asset!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Asset` you could get from the connection."""
  totalCount: Int!
}

"""A `Asset` edge in the connection."""
type AssetsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Asset` at the end of the edge."""
  node: Asset!
}

"""Methods to use when ordering `Asset`."""
enum AssetsOrderBy {
  ATTRIBUTION_ASC
  ATTRIBUTION_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  FILE_ASC
  FILE_DESC
  ID_ASC
  ID_DESC
  NATURAL
  OWNER_ID_ASC
  OWNER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type Attachment implements Node {
  attachment: JSON!

  """Reads a single `Card` that is related to this `Attachment`."""
  card: Card
  cardId: UUID!

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `User` that is related to this `Attachment`."""
  owner: User
  ownerId: UUID

  """Reads a single `Trip` that is related to this `Attachment`."""
  trip: Trip
  tripId: UUID

  """When this item was updated"""
  updatedAt: Datetime

  """A presigned URL to the attachment, expires after 60 seconds"""
  url: String!
}

"""The fields on `attachment` to look up the row to connect."""
input AttachmentAttachmentPkeyConnect {
  id: UUID!
}

"""The fields on `attachment` to look up the row to delete."""
input AttachmentAttachmentPkeyDelete {
  id: UUID!
}

"""The `attachment` to be created by this mutation."""
input AttachmentCardIdFkeyAttachmentCreateInput {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""The `card` to be created by this mutation."""
input AttachmentCardIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
Input for the nested mutation of `card` in the `AttachmentInput` mutation.
"""
input AttachmentCardIdFkeyInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: CardCardPkeyConnect

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: CardNodeIdConnect

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: AttachmentCardIdFkeyCardCreateInput

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: CardCardPkeyDelete

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: CardNodeIdDelete

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: CardOnAttachmentForAttachmentCardIdFkeyUsingCardPkeyUpdate

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: AttachmentOnAttachmentForAttachmentCardIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `attachment` in the `CardInput` mutation.
"""
input AttachmentCardIdFkeyInverseInput {
  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  connectById: [AttachmentAttachmentPkeyConnect!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  connectByNodeId: [AttachmentNodeIdConnect!]

  """
  A `AttachmentInput` object that will be created and connected to this object.
  """
  create: [AttachmentCardIdFkeyAttachmentCreateInput!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  deleteById: [AttachmentAttachmentPkeyDelete!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  deleteByNodeId: [AttachmentNodeIdDelete!]

  """
  Flag indicating whether all other `attachment` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `attachment` for the far side of the relationship.
  """
  updateById: [AttachmentOnAttachmentForAttachmentCardIdFkeyUsingAttachmentPkeyUpdate!]

  """
  The primary key(s) and patch data for `attachment` for the far side of the relationship.
  """
  updateByNodeId: [CardOnAttachmentForAttachmentCardIdFkeyNodeIdUpdate!]
}

"""
A condition to be used against `Attachment` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AttachmentCondition {
  """Checks for equality with the object’s `attachment` field."""
  attachment: JSON

  """Checks for equality with the object’s `cardId` field."""
  cardId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `ownerId` field."""
  ownerId: UUID

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `Attachment` object types. All fields are combined with a logical ‘and.’
"""
input AttachmentFilter {
  """Checks for all expressions in this list."""
  and: [AttachmentFilter!]

  """Filter by the object’s `attachment` field."""
  attachment: JSONFilter

  """Filter by the object’s `card` relation."""
  card: CardFilter

  """Filter by the object’s `cardId` field."""
  cardId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: AttachmentFilter

  """Checks for any expressions in this list."""
  or: [AttachmentFilter!]

  """Filter by the object’s `owner` relation."""
  owner: UserFilter

  """A related `owner` exists."""
  ownerExists: Boolean

  """Filter by the object’s `ownerId` field."""
  ownerId: UUIDFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """A related `trip` exists."""
  tripExists: Boolean

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""An input for mutations affecting `Attachment`"""
input AttachmentInput {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to connect."""
input AttachmentNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `attachment` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input AttachmentNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `attachment` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input AttachmentOnAttachmentForAttachmentCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `attachment` to look up the row to update."""
input AttachmentOnAttachmentForAttachmentCardIdFkeyUsingAttachmentPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `attachment` being updated.
  """
  patch: updateAttachmentOnAttachmentForAttachmentCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AttachmentOnAttachmentForAttachmentOwnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `attachment` to look up the row to update."""
input AttachmentOnAttachmentForAttachmentOwnerIdFkeyUsingAttachmentPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `attachment` being updated.
  """
  patch: updateAttachmentOnAttachmentForAttachmentOwnerIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input AttachmentOnAttachmentForAttachmentTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `attachment` to look up the row to update."""
input AttachmentOnAttachmentForAttachmentTripIdFkeyUsingAttachmentPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `attachment` being updated.
  """
  patch: updateAttachmentOnAttachmentForAttachmentTripIdFkeyPatch!
}

"""The `attachment` to be created by this mutation."""
input AttachmentOwnerIdFkeyAttachmentCreateInput {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""
Input for the nested mutation of `user` in the `AttachmentInput` mutation.
"""
input AttachmentOwnerIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnAttachmentForAttachmentOwnerIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: AttachmentOnAttachmentForAttachmentOwnerIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `attachment` in the `UserInput` mutation.
"""
input AttachmentOwnerIdFkeyInverseInput {
  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  connectById: [AttachmentAttachmentPkeyConnect!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  connectByNodeId: [AttachmentNodeIdConnect!]

  """
  A `AttachmentInput` object that will be created and connected to this object.
  """
  create: [AttachmentOwnerIdFkeyAttachmentCreateInput!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  deleteById: [AttachmentAttachmentPkeyDelete!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  deleteByNodeId: [AttachmentNodeIdDelete!]

  """
  Flag indicating whether all other `attachment` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `attachment` for the far side of the relationship.
  """
  updateById: [AttachmentOnAttachmentForAttachmentOwnerIdFkeyUsingAttachmentPkeyUpdate!]

  """
  The primary key(s) and patch data for `attachment` for the far side of the relationship.
  """
  updateByNodeId: [UserOnAttachmentForAttachmentOwnerIdFkeyNodeIdUpdate!]
}

"""
Represents an update to a `Attachment`. Fields that are set will be updated.
"""
input AttachmentPatch {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""The `attachment` to be created by this mutation."""
input AttachmentTripIdFkeyAttachmentCreateInput {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""
Input for the nested mutation of `trip` in the `AttachmentInput` mutation.
"""
input AttachmentTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: AttachmentTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnAttachmentForAttachmentTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: AttachmentOnAttachmentForAttachmentTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `attachment` in the `TripInput` mutation.
"""
input AttachmentTripIdFkeyInverseInput {
  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  connectById: [AttachmentAttachmentPkeyConnect!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  connectByNodeId: [AttachmentNodeIdConnect!]

  """
  A `AttachmentInput` object that will be created and connected to this object.
  """
  create: [AttachmentTripIdFkeyAttachmentCreateInput!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  deleteById: [AttachmentAttachmentPkeyDelete!]

  """
  The primary key(s) for `attachment` for the far side of the relationship.
  """
  deleteByNodeId: [AttachmentNodeIdDelete!]

  """
  Flag indicating whether all other `attachment` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `attachment` for the far side of the relationship.
  """
  updateById: [AttachmentOnAttachmentForAttachmentTripIdFkeyUsingAttachmentPkeyUpdate!]

  """
  The primary key(s) and patch data for `attachment` for the far side of the relationship.
  """
  updateByNodeId: [TripOnAttachmentForAttachmentTripIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input AttachmentTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

type AttachmentVisibilitySetting implements Node {
  """
  If true, this users attachments will be visible to all collaborator and owner
  """
  defaultAttachmentVisibility: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
An input for mutations affecting `AttachmentVisibilitySettingsPatchRecord`
"""
input AttachmentVisibilitySettingsPatchRecordInput {
  defaultAttachmentVisibility: Boolean
  tripId: UUID
}

"""A connection to a list of `Attachment` values."""
type AttachmentsConnection {
  """
  A list of edges which contains the `Attachment` and cursor to aid in pagination.
  """
  edges: [AttachmentsEdge!]!

  """A list of `Attachment` objects."""
  nodes: [Attachment!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Attachment` you could get from the connection."""
  totalCount: Int!
}

"""A `Attachment` edge in the connection."""
type AttachmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Attachment` at the end of the edge."""
  node: Attachment!
}

"""Methods to use when ordering `Attachment`."""
enum AttachmentsOrderBy {
  ATTACHMENT_ASC
  ATTACHMENT_DESC
  CARD_ID_ASC
  CARD_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  NATURAL
  OWNER_ID_ASC
  OWNER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""All input for the `authNoop` mutation."""
input AuthNoopInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  provider: OauthProvider!
}

"""The output of our `authNoop` mutation."""
type AuthNoopPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

input AuthenticateInput {
  clientMutationId: String
  email: String!
  password: String!
  session: Boolean
}

input AuthenticateOauthInput {
  """[Deprecated]"""
  email: String

  """
  **Apple**: Authorization Code  
  **Google**: ID Token
  """
  identifier: String!

  """Only used for Apple authentication"""
  name: String
  provider: OauthProvider!
}

type AuthenticatePayload {
  clientMutationId: String
  query: Query
  sessionToken: SessionToken
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""
A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’
"""
input BigIntFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: BigInt

  """Equal to the specified value."""
  equalTo: BigInt

  """Greater than the specified value."""
  greaterThan: BigInt

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: BigInt

  """Included in the specified list."""
  in: [BigInt!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: BigInt

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: BigInt

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: BigInt

  """Not equal to the specified value."""
  notEqualTo: BigInt

  """Not included in the specified list."""
  notIn: [BigInt!]
}

"""
A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’
"""
input BooleanFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Boolean

  """Equal to the specified value."""
  equalTo: Boolean

  """Greater than the specified value."""
  greaterThan: Boolean

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Boolean

  """Included in the specified list."""
  in: [Boolean!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Boolean

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Boolean

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Boolean

  """Not equal to the specified value."""
  notEqualTo: Boolean

  """Not included in the specified list."""
  notIn: [Boolean!]
}

type Budget {
  paid: Float
  remaining: Float
  spend: Spend
  total: Float
  unpaid: Float
}

enum BudgetType {
  DAILY
  ENTIRE
}

"""
A filter to be used against BudgetType List fields. All fields are combined with a logical ‘and.’
"""
input BudgetTypeListFilter {
  """Any array item is equal to the specified value."""
  anyEqualTo: BudgetType

  """Any array item is greater than the specified value."""
  anyGreaterThan: BudgetType

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: BudgetType

  """Any array item is less than the specified value."""
  anyLessThan: BudgetType

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: BudgetType

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: BudgetType

  """Contained by the specified list of values."""
  containedBy: [BudgetType]

  """Contains the specified list of values."""
  contains: [BudgetType]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [BudgetType]

  """Equal to the specified value."""
  equalTo: [BudgetType]

  """Greater than the specified value."""
  greaterThan: [BudgetType]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [BudgetType]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: [BudgetType]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [BudgetType]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [BudgetType]

  """Not equal to the specified value."""
  notEqualTo: [BudgetType]

  """Overlaps the specified list of values."""
  overlaps: [BudgetType]
}

type Card implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads and enables pagination through a set of `Attachment`."""
  attachments(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttachmentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AttachmentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttachmentsConnection!

  """Reads and enables pagination through a set of `Attachment`."""
  attachmentsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttachmentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AttachmentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!]
  ): [Attachment!]!
  budget: Float

  """Reads a single `CardCost` that is related to this `Card`."""
  cardCost: CardCost

  """Reads and enables pagination through a set of `Card`."""
  childCards(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsConnection!

  """Reads and enables pagination through a set of `Card`."""
  childCardsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!]
  ): [Card!]!
  contentSorting: JSON
  cost: CardCost

  """Reads and enables pagination through a set of `CostItem`."""
  costItems(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsConnection!

  """Reads and enables pagination through a set of `CostItem`."""
  costItemsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!]
  ): [CostItem!]!

  """When this item was created"""
  createdAt: Datetime

  """Reads a single `Currency` that is related to this `Card`."""
  currency: Currency
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  date: Datetime
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType!
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flight: Flight
  flightNumber: String
  id: UUID!

  """Reads a single `Asset` that is related to this `Card`."""
  image: Asset
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isMultiDayChild(isLast: Boolean): Boolean
  isMultiDayParent: Boolean
  location: Location
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  notes: String

  """Reads a single `User` that is related to this `Card`."""
  owner: User
  ownerId: UUID

  """Reads a single `Card` that is related to this `Card`."""
  parent: Card
  parentId: UUID
  place: Place
  placeId: String

  """When this item was restored"""
  restoredAt: Datetime
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksConnection!

  """Reads and enables pagination through a set of `Task`."""
  tasksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!]
  ): [Task!]!

  """Reads a single `Trip` that is related to this `Card`."""
  trip: Trip
  tripBudget: Float
  tripDeposit: Float
  tripId: UUID!
  type: CardType

  """When this item was updated"""
  updatedAt: Datetime
}

"""The fields on `card` to look up the row to connect."""
input CardCardPkeyConnect {
  id: UUID!
}

"""The fields on `card` to look up the row to delete."""
input CardCardPkeyDelete {
  id: UUID!
}

"""
A condition to be used against `Card` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CardCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `budget` field."""
  budget: Float

  """Checks for equality with the object’s `contentSorting` field."""
  contentSorting: JSON

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `currencyId` field."""
  currencyId: UUID

  """Checks for equality with the object’s `dailyBudget` field."""
  dailyBudget: Float

  """Checks for equality with the object’s `dailyDeposit` field."""
  dailyDeposit: Float

  """Checks for equality with the object’s `day` field."""
  day: Int

  """Checks for equality with the object’s `deposit` field."""
  deposit: Float

  """Checks for equality with the object’s `duration` field."""
  duration: Int

  """Checks for equality with the object’s `durationType` field."""
  durationType: CardDurationType

  """Checks for equality with the object’s `enableImage` field."""
  enableImage: Boolean

  """Checks for equality with the object’s `enableMap` field."""
  enableMap: Boolean

  """Checks for equality with the object’s `endAlert` field."""
  endAlert: Boolean

  """Checks for equality with the object’s `endAlertOffset` field."""
  endAlertOffset: Int

  """Checks for equality with the object’s `endTime` field."""
  endTime: Time

  """Checks for equality with the object’s `flightNumber` field."""
  flightNumber: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `location` field."""
  location: LocationInput

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `ownerId` field."""
  ownerId: UUID

  """Checks for equality with the object’s `parentId` field."""
  parentId: UUID

  """Checks for equality with the object’s `placeId` field."""
  placeId: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `sorting` field."""
  sorting: Int

  """Checks for equality with the object’s `startAlert` field."""
  startAlert: Boolean

  """Checks for equality with the object’s `startAlertOffset` field."""
  startAlertOffset: Int

  """Checks for equality with the object’s `startTime` field."""
  startTime: Time

  """Checks for equality with the object’s `status` field."""
  status: CardStatus

  """Checks for equality with the object’s `subType` field."""
  subType: CardSubType

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID

  """Checks for equality with the object’s `type` field."""
  type: CardType

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

type CardCost implements Node {
  """Reads a single `Card` that is related to this `CardCost`."""
  card: Card
  cardId: UUID
  costTax: UUID

  """Reads a single `CostTax` that is related to this `CardCost`."""
  costTaxByCostTax: CostTax
  costType: CostType
  discount: Float
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""The fields on `cardCost` to look up the row to connect."""
input CardCostCardCostPkeyConnect {
  id: UUID!
}

"""The `cardCost` to be created by this mutation."""
input CardCostCardIdFkeyCardCostCreateInput {
  card: CardCostCardIdFkeyInput
  cardId: UUID
  costTax: CardCostCostTaxFkeyInput
  costType: CostType
  discount: Float
  id: UUID
}

"""The `card` to be created by this mutation."""
input CardCostCardIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
Input for the nested mutation of `card` in the `CardCostInput` mutation.
"""
input CardCostCardIdFkeyInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: CardCardPkeyConnect

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: CardNodeIdConnect

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: CardCostCardIdFkeyCardCreateInput

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: CardCardPkeyDelete

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: CardNodeIdDelete

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: CardOnCardCostForCardCostCardIdFkeyUsingCardPkeyUpdate

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: CardCostOnCardCostForCardCostCardIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `cardCost` in the `CardInput` mutation.
"""
input CardCostCardIdFkeyInverseInput {
  """
  The primary key(s) for `cardCost` for the far side of the relationship.
  """
  connectByCardId: CardCostCostCardCostCardIdUniqueConnect

  """
  The primary key(s) for `cardCost` for the far side of the relationship.
  """
  connectById: CardCostCardCostPkeyConnect

  """
  The primary key(s) for `cardCost` for the far side of the relationship.
  """
  connectByNodeId: CardCostNodeIdConnect

  """
  A `CardCostInput` object that will be created and connected to this object.
  """
  create: [CardCostCardIdFkeyCardCostCreateInput!]

  """
  The primary key(s) and patch data for `cardCost` for the far side of the relationship.
  """
  updateByCardId: CardCostOnCardCostForCardCostCardIdFkeyUsingCostCardCostCardIdUniqueUpdate

  """
  The primary key(s) and patch data for `cardCost` for the far side of the relationship.
  """
  updateById: CardCostOnCardCostForCardCostCardIdFkeyUsingCardCostPkeyUpdate

  """
  The primary key(s) and patch data for `cardCost` for the far side of the relationship.
  """
  updateByNodeId: CardOnCardCostForCardCostCardIdFkeyNodeIdUpdate
}

"""The fields on `cardCost` to look up the row to connect."""
input CardCostCostCardCostCardIdUniqueConnect {
  cardId: UUID!
}

"""The `cardCost` to be created by this mutation."""
input CardCostCostTaxFkeyCardCostCreateInput {
  card: CardCostCardIdFkeyInput
  cardId: UUID
  costTax: CardCostCostTaxFkeyInput
  costType: CostType
  discount: Float
  id: UUID
}

"""The `costTax` to be created by this mutation."""
input CardCostCostTaxFkeyCostTaxCreateInput {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID
  name: String!
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float!
}

"""
Input for the nested mutation of `costTax` in the `CardCostInput` mutation.
"""
input CardCostCostTaxFkeyInput {
  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectById: CostTaxCostTaxPkeyConnect

  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectByNodeId: CostTaxNodeIdConnect

  """
  A `CostTaxInput` object that will be created and connected to this object.
  """
  create: CardCostCostTaxFkeyCostTaxCreateInput

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteById: CostTaxCostTaxPkeyDelete

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteByNodeId: CostTaxNodeIdDelete

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateById: CostTaxOnCardCostForCardCostCostTaxFkeyUsingCostTaxPkeyUpdate

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateByNodeId: CardCostOnCardCostForCardCostCostTaxFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `cardCost` in the `CostTaxInput` mutation.
"""
input CardCostCostTaxFkeyInverseInput {
  """
  The primary key(s) for `cardCost` for the far side of the relationship.
  """
  connectByCardId: [CardCostCostCardCostCardIdUniqueConnect!]

  """
  The primary key(s) for `cardCost` for the far side of the relationship.
  """
  connectById: [CardCostCardCostPkeyConnect!]

  """
  The primary key(s) for `cardCost` for the far side of the relationship.
  """
  connectByNodeId: [CardCostNodeIdConnect!]

  """
  A `CardCostInput` object that will be created and connected to this object.
  """
  create: [CardCostCostTaxFkeyCardCostCreateInput!]

  """
  The primary key(s) and patch data for `cardCost` for the far side of the relationship.
  """
  updateByCardId: [CardCostOnCardCostForCardCostCostTaxFkeyUsingCostCardCostCardIdUniqueUpdate!]

  """
  The primary key(s) and patch data for `cardCost` for the far side of the relationship.
  """
  updateById: [CardCostOnCardCostForCardCostCostTaxFkeyUsingCardCostPkeyUpdate!]

  """
  The primary key(s) and patch data for `cardCost` for the far side of the relationship.
  """
  updateByNodeId: [CostTaxOnCardCostForCardCostCostTaxFkeyNodeIdUpdate!]
}

"""All input for the `cardCostDuplicate` mutation."""
input CardCostDuplicateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  origincardid: UUID!
  targetcardid: UUID!
}

"""The output of our `cardCostDuplicate` mutation."""
type CardCostDuplicatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A filter to be used against `CardCost` object types. All fields are combined with a logical ‘and.’
"""
input CardCostFilter {
  """Checks for all expressions in this list."""
  and: [CardCostFilter!]

  """Filter by the object’s `card` relation."""
  card: CardFilter

  """A related `card` exists."""
  cardExists: Boolean

  """Filter by the object’s `cardId` field."""
  cardId: UUIDFilter

  """Filter by the object’s `costTax` field."""
  costTax: UUIDFilter

  """Filter by the object’s `costTaxByCostTax` relation."""
  costTaxByCostTax: CostTaxFilter

  """A related `costTaxByCostTax` exists."""
  costTaxByCostTaxExists: Boolean

  """Filter by the object’s `costType` field."""
  costType: CostTypeFilter

  """Filter by the object’s `discount` field."""
  discount: FloatFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: CardCostFilter

  """Checks for any expressions in this list."""
  or: [CardCostFilter!]
}

"""An input for mutations affecting `CardCost`"""
input CardCostInput {
  card: CardCostCardIdFkeyInput
  cardId: UUID
  costTax: CardCostCostTaxFkeyInput
  costType: CostType
  discount: Float
  id: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input CardCostNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `cardCost` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CardCostOnCardCostForCardCostCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `cardCost` to look up the row to update."""
input CardCostOnCardCostForCardCostCardIdFkeyUsingCardCostPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `cardCost` being updated.
  """
  patch: updateCardCostOnCardCostForCardCostCardIdFkeyPatch!
}

"""The fields on `cardCost` to look up the row to update."""
input CardCostOnCardCostForCardCostCardIdFkeyUsingCostCardCostCardIdUniqueUpdate {
  cardId: UUID!

  """
  An object where the defined keys will be set on the `cardCost` being updated.
  """
  patch: updateCardCostOnCardCostForCardCostCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardCostOnCardCostForCardCostCostTaxFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costTax` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: CostTaxPatch!
}

"""The fields on `cardCost` to look up the row to update."""
input CardCostOnCardCostForCardCostCostTaxFkeyUsingCardCostPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `cardCost` being updated.
  """
  patch: updateCardCostOnCardCostForCardCostCostTaxFkeyPatch!
}

"""The fields on `cardCost` to look up the row to update."""
input CardCostOnCardCostForCardCostCostTaxFkeyUsingCostCardCostCardIdUniqueUpdate {
  cardId: UUID!

  """
  An object where the defined keys will be set on the `cardCost` being updated.
  """
  patch: updateCardCostOnCardCostForCardCostCostTaxFkeyPatch!
}

"""
Represents an update to a `CardCost`. Fields that are set will be updated.
"""
input CardCostPatch {
  card: CardCostCardIdFkeyInput
  cardId: UUID
  costTax: CardCostCostTaxFkeyInput
  costType: CostType
  discount: Float
  id: UUID
}

"""The `card` to be created by this mutation."""
input CardCurrencyIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""The `currency` to be created by this mutation."""
input CardCurrencyIdFkeyCurrencyCreateInput {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
Input for the nested mutation of `currency` in the `CardInput` mutation.
"""
input CardCurrencyIdFkeyInput {
  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectById: CurrencyCurrencyPkeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByIso: CurrencyCurrencyIsoKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByName: CurrencyCurrencyNameKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByNodeId: CurrencyNodeIdConnect

  """
  A `CurrencyInput` object that will be created and connected to this object.
  """
  create: CardCurrencyIdFkeyCurrencyCreateInput

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteById: CurrencyCurrencyPkeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByIso: CurrencyCurrencyIsoKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByName: CurrencyCurrencyNameKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByNodeId: CurrencyNodeIdDelete

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateById: CurrencyOnCardForCardCurrencyIdFkeyUsingCurrencyPkeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByIso: CurrencyOnCardForCardCurrencyIdFkeyUsingCurrencyIsoKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByName: CurrencyOnCardForCardCurrencyIdFkeyUsingCurrencyNameKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByNodeId: CardOnCardForCardCurrencyIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `card` in the `CurrencyInput` mutation.
"""
input CardCurrencyIdFkeyInverseInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: [CardCardPkeyConnect!]

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: [CardNodeIdConnect!]

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: [CardCurrencyIdFkeyCardCreateInput!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: [CardCardPkeyDelete!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: [CardNodeIdDelete!]

  """
  Flag indicating whether all other `card` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: [CardOnCardForCardCurrencyIdFkeyUsingCardPkeyUpdate!]

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: [CurrencyOnCardForCardCurrencyIdFkeyNodeIdUpdate!]
}

"""
**`recurring`**: The card will repeat at the same times across multiple days  

**`extended`**: The card will extend from the start time to end time across multiple days
"""
enum CardDurationType {
  EXTENDED
  RECURRING
}

"""
A filter to be used against CardDurationType fields. All fields are combined with a logical ‘and.’
"""
input CardDurationTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: CardDurationType

  """Equal to the specified value."""
  equalTo: CardDurationType

  """Greater than the specified value."""
  greaterThan: CardDurationType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: CardDurationType

  """Included in the specified list."""
  in: [CardDurationType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: CardDurationType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: CardDurationType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: CardDurationType

  """Not equal to the specified value."""
  notEqualTo: CardDurationType

  """Not included in the specified list."""
  notIn: [CardDurationType!]
}

"""
A filter to be used against `Card` object types. All fields are combined with a logical ‘and.’
"""
input CardFilter {
  """Checks for all expressions in this list."""
  and: [CardFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `attachments` relation."""
  attachments: CardToManyAttachmentFilter

  """Some related `attachments` exist."""
  attachmentsExist: Boolean

  """Filter by the object’s `budget` field."""
  budget: FloatFilter

  """Filter by the object’s `cardCost` relation."""
  cardCost: CardCostFilter

  """A related `cardCost` exists."""
  cardCostExists: Boolean

  """Filter by the object’s `childCards` relation."""
  childCards: CardToManyCardFilter

  """Some related `childCards` exist."""
  childCardsExist: Boolean

  """Filter by the object’s `contentSorting` field."""
  contentSorting: JSONFilter

  """Filter by the object’s `costItems` relation."""
  costItems: CardToManyCostItemFilter

  """Some related `costItems` exist."""
  costItemsExist: Boolean

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `currency` relation."""
  currency: CurrencyFilter

  """A related `currency` exists."""
  currencyExists: Boolean

  """Filter by the object’s `currencyId` field."""
  currencyId: UUIDFilter

  """Filter by the object’s `dailyBudget` field."""
  dailyBudget: FloatFilter

  """Filter by the object’s `dailyDeposit` field."""
  dailyDeposit: FloatFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Filter by the object’s `day` field."""
  day: IntFilter

  """Filter by the object’s `deposit` field."""
  deposit: FloatFilter

  """Filter by the object’s `duration` field."""
  duration: IntFilter

  """Filter by the object’s `durationType` field."""
  durationType: CardDurationTypeFilter

  """Filter by the object’s `enableImage` field."""
  enableImage: BooleanFilter

  """Filter by the object’s `enableMap` field."""
  enableMap: BooleanFilter

  """Filter by the object’s `endAlert` field."""
  endAlert: BooleanFilter

  """Filter by the object’s `endAlertOffset` field."""
  endAlertOffset: IntFilter

  """Filter by the object’s `endTime` field."""
  endTime: TimeFilter

  """Filter by the object’s `flightNumber` field."""
  flightNumber: StringFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `image` relation."""
  image: AssetFilter

  """A related `image` exists."""
  imageExists: Boolean

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `isMultiDayChild` field."""
  isMultiDayChild: BooleanFilter

  """Filter by the object’s `isMultiDayParent` field."""
  isMultiDayParent: BooleanFilter

  """Filter by the object’s `location` field."""
  location: LocationFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CardFilter

  """Filter by the object’s `notes` field."""
  notes: StringFilter

  """Checks for any expressions in this list."""
  or: [CardFilter!]

  """Filter by the object’s `owner` relation."""
  owner: UserFilter

  """A related `owner` exists."""
  ownerExists: Boolean

  """Filter by the object’s `ownerId` field."""
  ownerId: UUIDFilter

  """Filter by the object’s `parent` relation."""
  parent: CardFilter

  """A related `parent` exists."""
  parentExists: Boolean

  """Filter by the object’s `parentId` field."""
  parentId: UUIDFilter

  """Filter by the object’s `placeId` field."""
  placeId: StringFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `sorting` field."""
  sorting: IntFilter

  """Filter by the object’s `startAlert` field."""
  startAlert: BooleanFilter

  """Filter by the object’s `startAlertOffset` field."""
  startAlertOffset: IntFilter

  """Filter by the object’s `startTime` field."""
  startTime: TimeFilter

  """Filter by the object’s `status` field."""
  status: CardStatusFilter

  """Filter by the object’s `subType` field."""
  subType: CardSubTypeFilter

  """Filter by the object’s `tasks` relation."""
  tasks: CardToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripBudget` field."""
  tripBudget: FloatFilter

  """Filter by the object’s `tripDeposit` field."""
  tripDeposit: FloatFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter

  """Filter by the object’s `type` field."""
  type: CardTypeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""The `asset` to be created by this mutation."""
input CardImageIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""The `card` to be created by this mutation."""
input CardImageIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""Input for the nested mutation of `asset` in the `CardInput` mutation."""
input CardImageIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: CardImageIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnCardForCardImageIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: CardOnCardForCardImageIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `card` in the `AssetInput` mutation."""
input CardImageIdFkeyInverseInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: [CardCardPkeyConnect!]

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: [CardNodeIdConnect!]

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: [CardImageIdFkeyCardCreateInput!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: [CardCardPkeyDelete!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: [CardNodeIdDelete!]

  """
  Flag indicating whether all other `card` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: [CardOnCardForCardImageIdFkeyUsingCardPkeyUpdate!]

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnCardForCardImageIdFkeyNodeIdUpdate!]
}

"""An input for mutations affecting `Card`"""
input CardInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to connect."""
input CardNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input CardNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `card` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnAttachmentForAttachmentCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `attachment` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `attachment` being updated.
  """
  patch: AttachmentPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnAttachmentForAttachmentCardIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnAttachmentForAttachmentCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCardCostForCardCostCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `cardCost` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `cardCost` being updated.
  """
  patch: CardCostPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCardCostForCardCostCardIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCardCostForCardCostCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCardForCardCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currency` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: CurrencyPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCardForCardCurrencyIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCardForCardCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCardForCardImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCardForCardImageIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCardForCardImageIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCardForCardOwnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCardForCardOwnerIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCardForCardOwnerIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCardForCardParentIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCardForCardParentIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCardForCardParentIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCardForCardTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCardForCardTripIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCardForCardTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnCostItemForCostItemCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: CostItemPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnCostItemForCostItemCardIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnCostItemForCostItemCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CardOnTaskForTaskCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `task` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `task` being updated.
  """
  patch: TaskPatch!
}

"""The fields on `card` to look up the row to update."""
input CardOnTaskForTaskCardIdFkeyUsingCardPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: updateCardOnTaskForTaskCardIdFkeyPatch!
}

"""The `card` to be created by this mutation."""
input CardOwnerIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""Input for the nested mutation of `user` in the `CardInput` mutation."""
input CardOwnerIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnCardForCardOwnerIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: CardOnCardForCardOwnerIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `card` in the `UserInput` mutation."""
input CardOwnerIdFkeyInverseInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: [CardCardPkeyConnect!]

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: [CardNodeIdConnect!]

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: [CardOwnerIdFkeyCardCreateInput!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: [CardCardPkeyDelete!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: [CardNodeIdDelete!]

  """
  Flag indicating whether all other `card` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: [CardOnCardForCardOwnerIdFkeyUsingCardPkeyUpdate!]

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: [UserOnCardForCardOwnerIdFkeyNodeIdUpdate!]
}

"""The `card` to be created by this mutation."""
input CardParentIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""Input for the nested mutation of `card` in the `CardInput` mutation."""
input CardParentIdFkeyInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: CardCardPkeyConnect

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: CardNodeIdConnect

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: CardParentIdFkeyCardCreateInput

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: CardCardPkeyDelete

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: CardNodeIdDelete

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: CardOnCardForCardParentIdFkeyUsingCardPkeyUpdate

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: CardOnCardForCardParentIdFkeyNodeIdUpdate
}

"""Represents an update to a `Card`. Fields that are set will be updated."""
input CardPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

enum CardStatus {
  BOOKED
  BOOKED_DEPOSIT_PAID
  BOOKED_PAID
  PAID
  TO_BOOK
}

"""
A filter to be used against CardStatus fields. All fields are combined with a logical ‘and.’
"""
input CardStatusFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: CardStatus

  """Equal to the specified value."""
  equalTo: CardStatus

  """Greater than the specified value."""
  greaterThan: CardStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: CardStatus

  """Included in the specified list."""
  in: [CardStatus!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: CardStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: CardStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: CardStatus

  """Not equal to the specified value."""
  notEqualTo: CardStatus

  """Not included in the specified list."""
  notIn: [CardStatus!]
}

enum CardSubType {
  TRAVEL_BOAT
  TRAVEL_CYCLE
  TRAVEL_DRIVE
  TRAVEL_FLIGHT
  TRAVEL_PUBLIC_TRANSPORT
  TRAVEL_TAXI
  TRAVEL_WALK
}

"""
A filter to be used against CardSubType fields. All fields are combined with a logical ‘and.’
"""
input CardSubTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: CardSubType

  """Equal to the specified value."""
  equalTo: CardSubType

  """Greater than the specified value."""
  greaterThan: CardSubType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: CardSubType

  """Included in the specified list."""
  in: [CardSubType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: CardSubType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: CardSubType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: CardSubType

  """Not equal to the specified value."""
  notEqualTo: CardSubType

  """Not included in the specified list."""
  notIn: [CardSubType!]
}

"""
A filter to be used against many `Attachment` object types. All fields are combined with a logical ‘and.’
"""
input CardToManyAttachmentFilter {
  """
  Every related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AttachmentFilter

  """
  No related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AttachmentFilter

  """
  Some related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AttachmentFilter
}

"""
A filter to be used against many `Card` object types. All fields are combined with a logical ‘and.’
"""
input CardToManyCardFilter {
  """
  Every related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CardFilter

  """
  No related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CardFilter

  """
  Some related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CardFilter
}

"""
A filter to be used against many `CostItem` object types. All fields are combined with a logical ‘and.’
"""
input CardToManyCostItemFilter {
  """
  Every related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CostItemFilter

  """
  No related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CostItemFilter

  """
  Some related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CostItemFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’
"""
input CardToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskFilter
}

"""The `card` to be created by this mutation."""
input CardTripIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""Input for the nested mutation of `trip` in the `CardInput` mutation."""
input CardTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: CardTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnCardForCardTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: CardOnCardForCardTripIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `card` in the `TripInput` mutation."""
input CardTripIdFkeyInverseInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: [CardCardPkeyConnect!]

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: [CardNodeIdConnect!]

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: [CardTripIdFkeyCardCreateInput!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: [CardCardPkeyDelete!]

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: [CardNodeIdDelete!]

  """
  Flag indicating whether all other `card` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: [CardOnCardForCardTripIdFkeyUsingCardPkeyUpdate!]

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: [TripOnCardForCardTripIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input CardTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

enum CardType {
  ACCOMMODATION
  ACTIVITY
  FOOD
  OTHER
  TRAVEL
}

"""
A filter to be used against CardType fields. All fields are combined with a logical ‘and.’
"""
input CardTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: CardType

  """Equal to the specified value."""
  equalTo: CardType

  """Greater than the specified value."""
  greaterThan: CardType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: CardType

  """Included in the specified list."""
  in: [CardType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: CardType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: CardType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: CardType

  """Not equal to the specified value."""
  notEqualTo: CardType

  """Not included in the specified list."""
  notIn: [CardType!]
}

"""A connection to a list of `Card` values."""
type CardsConnection {
  """
  A list of edges which contains the `Card` and cursor to aid in pagination.
  """
  edges: [CardsEdge!]!

  """A list of `Card` objects."""
  nodes: [Card!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Card` you could get from the connection."""
  totalCount: Int!
}

"""A `Card` edge in the connection."""
type CardsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Card` at the end of the edge."""
  node: Card!
}

"""Methods to use when ordering `Card`."""
enum CardsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  BUDGET_ASC
  BUDGET_DESC
  CONTENT_SORTING_ASC
  CONTENT_SORTING_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CURRENCY_ID_ASC
  CURRENCY_ID_DESC
  DAILY_BUDGET_ASC
  DAILY_BUDGET_DESC
  DAILY_DEPOSIT_ASC
  DAILY_DEPOSIT_DESC
  DAY_ASC
  DAY_DESC
  DEPOSIT_ASC
  DEPOSIT_DESC
  DURATION_ASC
  DURATION_DESC
  DURATION_TYPE_ASC
  DURATION_TYPE_DESC
  ENABLE_IMAGE_ASC
  ENABLE_IMAGE_DESC
  ENABLE_MAP_ASC
  ENABLE_MAP_DESC
  END_ALERT_ASC
  END_ALERT_DESC
  END_ALERT_OFFSET_ASC
  END_ALERT_OFFSET_DESC
  END_TIME_ASC
  END_TIME_DESC
  FLIGHT_NUMBER_ASC
  FLIGHT_NUMBER_DESC
  ID_ASC
  ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  LOCATION_ASC
  LOCATION_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  PLACE_ID_ASC
  PLACE_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SORTING_ASC
  SORTING_DESC
  START_ALERT_ASC
  START_ALERT_DESC
  START_ALERT_OFFSET_ASC
  START_ALERT_OFFSET_DESC
  START_TIME_ASC
  START_TIME_DESC
  STATUS_ASC
  STATUS_DESC
  SUB_TYPE_ASC
  SUB_TYPE_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type CardsOverTime {
  count: BigInt
  date: Datetime
}

"""
A condition to be used against `CardsOverTime` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CardsOverTimeCondition {
  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `date` field."""
  date: Datetime
}

"""
A filter to be used against `CardsOverTime` object types. All fields are combined with a logical ‘and.’
"""
input CardsOverTimeFilter {
  """Checks for all expressions in this list."""
  and: [CardsOverTimeFilter!]

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Negates the expression."""
  not: CardsOverTimeFilter

  """Checks for any expressions in this list."""
  or: [CardsOverTimeFilter!]
}

"""A connection to a list of `CardsOverTime` values."""
type CardsOverTimesConnection {
  """
  A list of edges which contains the `CardsOverTime` and cursor to aid in pagination.
  """
  edges: [CardsOverTimesEdge!]!

  """A list of `CardsOverTime` objects."""
  nodes: [CardsOverTime!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CardsOverTime` you could get from the connection."""
  totalCount: Int!
}

"""A `CardsOverTime` edge in the connection."""
type CardsOverTimesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CardsOverTime` at the end of the edge."""
  node: CardsOverTime!
}

"""Methods to use when ordering `CardsOverTime`."""
enum CardsOverTimesOrderBy {
  COUNT_ASC
  COUNT_DESC
  DATE_ASC
  DATE_DESC
  NATURAL
}

type Catalogue implements Node {
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  targetId: UUID!
  type: String!
  vector: String
}

"""
A filter to be used against `Catalogue` object types. All fields are combined with a logical ‘and.’
"""
input CatalogueFilter {
  """Checks for all expressions in this list."""
  and: [CatalogueFilter!]

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CatalogueFilter

  """Checks for any expressions in this list."""
  or: [CatalogueFilter!]

  """Filter by the object’s `targetId` field."""
  targetId: UUIDFilter

  """Filter by the object’s `type` field."""
  type: StringFilter
}

"""A connection to a list of `Catalogue` values."""
type CataloguesConnection {
  """
  A list of edges which contains the `Catalogue` and cursor to aid in pagination.
  """
  edges: [CataloguesEdge!]!

  """A list of `Catalogue` objects."""
  nodes: [Catalogue!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Catalogue` you could get from the connection."""
  totalCount: Int!
}

"""A `Catalogue` edge in the connection."""
type CataloguesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Catalogue` at the end of the edge."""
  node: Catalogue!
}

type Charge {
  amount: Float!
  currency: String!
  expires: Datetime
  id: String!
  purchased: Datetime
  trip: String
}

"""All input for the `clearCountryRelations` mutation."""
input ClearCountryRelationsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `clearCountryRelations` mutation."""
type ClearCountryRelationsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `clearUserAffiliatePromoCodes` mutation."""
input ClearUserAffiliatePromoCodesInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `clearUserAffiliatePromoCodes` mutation."""
type ClearUserAffiliatePromoCodesPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Client implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads a single `User` that is related to this `Client`."""
  author: User
  authorId: UUID

  """Reads a single `ClientOrganisation` that is related to this `Client`."""
  clientOrganisation: ClientOrganisation

  """Reads a single `ClientPerson` that is related to this `Client`."""
  clientPerson: ClientPerson

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Organisation` that is related to this `Client`."""
  organisation: Organisation
  organisationId: UUID!

  """When this item was restored"""
  restoredAt: Datetime

  """Reads and enables pagination through a set of `Trip`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]!
  type: ClientType!

  """When this item was updated"""
  updatedAt: Datetime
}

"""The `client` to be created by this mutation."""
input ClientAuthorIdFkeyClientCreateInput {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType!
  user: ClientAuthorIdFkeyInput
}

"""Input for the nested mutation of `user` in the `ClientInput` mutation."""
input ClientAuthorIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnClientForClientAuthorIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: ClientOnClientForClientAuthorIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `client` in the `UserInput` mutation."""
input ClientAuthorIdFkeyInverseInput {
  """The primary key(s) for `client` for the far side of the relationship."""
  connectById: [ClientClientPkeyConnect!]

  """The primary key(s) for `client` for the far side of the relationship."""
  connectByNodeId: [ClientNodeIdConnect!]

  """
  A `ClientInput` object that will be created and connected to this object.
  """
  create: [ClientAuthorIdFkeyClientCreateInput!]

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteById: [ClientClientPkeyDelete!]

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteByNodeId: [ClientNodeIdDelete!]

  """
  Flag indicating whether all other `client` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateById: [ClientOnClientForClientAuthorIdFkeyUsingClientPkeyUpdate!]

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateByNodeId: [UserOnClientForClientAuthorIdFkeyNodeIdUpdate!]
}

"""The fields on `client` to look up the row to connect."""
input ClientClientPkeyConnect {
  id: UUID!
}

"""The fields on `client` to look up the row to delete."""
input ClientClientPkeyDelete {
  id: UUID!
}

"""
A condition to be used against `Client` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ClientCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `authorId` field."""
  authorId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `type` field."""
  type: ClientType

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `Client` object types. All fields are combined with a logical ‘and.’
"""
input ClientFilter {
  """Checks for all expressions in this list."""
  and: [ClientFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the object’s `authorId` field."""
  authorId: UUIDFilter

  """Filter by the object’s `clientOrganisation` relation."""
  clientOrganisation: ClientOrganisationFilter

  """A related `clientOrganisation` exists."""
  clientOrganisationExists: Boolean

  """Filter by the object’s `clientPerson` relation."""
  clientPerson: ClientPersonFilter

  """A related `clientPerson` exists."""
  clientPersonExists: Boolean

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Negates the expression."""
  not: ClientFilter

  """Checks for any expressions in this list."""
  or: [ClientFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `trips` relation."""
  trips: ClientToManyTripFilter

  """Some related `trips` exist."""
  tripsExist: Boolean

  """Filter by the object’s `type` field."""
  type: ClientTypeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""An input for mutations affecting `Client`"""
input ClientInput {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType!
  user: ClientAuthorIdFkeyInput
}

"""The globally unique `ID` look up for the row to connect."""
input ClientNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `client` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input ClientNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `client` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOnClientForClientAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `client` to look up the row to update."""
input ClientOnClientForClientAuthorIdFkeyUsingClientPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: updateClientOnClientForClientAuthorIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOnClientForClientOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `client` to look up the row to update."""
input ClientOnClientForClientOrganisationIdFkeyUsingClientPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: updateClientOnClientForClientOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOnClientOrganisationForClientOrganisationIdFkey1NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientOrganisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientOrganisation` being updated.
  """
  patch: ClientOrganisationPatch!
}

"""The fields on `client` to look up the row to update."""
input ClientOnClientOrganisationForClientOrganisationIdFkey1UsingClientPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: updateClientOnClientOrganisationForClientOrganisationIdFkey1Patch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOnClientPersonForClientPersonIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientPerson` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: ClientPersonPatch!
}

"""The fields on `client` to look up the row to update."""
input ClientOnClientPersonForClientPersonIdFkeyUsingClientPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: updateClientOnClientPersonForClientPersonIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOnTripForTripClientIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `client` to look up the row to update."""
input ClientOnTripForTripClientIdFkeyUsingClientPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: updateClientOnTripForTripClientIdFkeyPatch!
}

type ClientOrganisation implements Node {
  """Reads a single `Client` that is related to this `ClientOrganisation`."""
  client: Client

  """
  Reads and enables pagination through a set of `ClientOrganisationContact`.
  """
  contact(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientOrganisationContactCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientOrganisationContactFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationContactsConnection!

  """
  Reads and enables pagination through a set of `ClientOrganisationContact`.
  """
  contactList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientOrganisationContactCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientOrganisationContactFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!]
  ): [ClientOrganisationContact!]!
  id: UUID!

  """Reads and enables pagination through a set of `Meta`."""
  metadata(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasConnection!

  """Reads and enables pagination through a set of `Meta`."""
  metadataList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]
  ): [Meta!]!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""The fields on `clientOrganisation` to look up the row to connect."""
input ClientOrganisationClientOrganisationPkeyConnect {
  id: UUID!
}

type ClientOrganisationContact implements Node {
  isPrimary: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `ClientOrganisation` that is related to this `ClientOrganisationContact`.
  """
  organisation: ClientOrganisation
  organisationId: UUID!

  """
  Reads a single `ClientPerson` that is related to this `ClientOrganisationContact`.
  """
  person: ClientPerson
  personId: UUID!
  role: String
}

"""
The fields on `clientOrganisationContact` to look up the row to connect.
"""
input ClientOrganisationContactClientOrganisationContactPkeyConnect {
  organisationId: UUID!
  personId: UUID!
}

"""
The fields on `clientOrganisationContact` to look up the row to delete.
"""
input ClientOrganisationContactClientOrganisationContactPkeyDelete {
  organisationId: UUID!
  personId: UUID!
}

"""
A condition to be used against `ClientOrganisationContact` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input ClientOrganisationContactCondition {
  """Checks for equality with the object’s `isPrimary` field."""
  isPrimary: Boolean

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `personId` field."""
  personId: UUID

  """Checks for equality with the object’s `role` field."""
  role: String
}

"""
A filter to be used against `ClientOrganisationContact` object types. All fields are combined with a logical ‘and.’
"""
input ClientOrganisationContactFilter {
  """Checks for all expressions in this list."""
  and: [ClientOrganisationContactFilter!]

  """Filter by the object’s `isPrimary` field."""
  isPrimary: BooleanFilter

  """Negates the expression."""
  not: ClientOrganisationContactFilter

  """Checks for any expressions in this list."""
  or: [ClientOrganisationContactFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: ClientOrganisationFilter

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `person` relation."""
  person: ClientPersonFilter

  """Filter by the object’s `personId` field."""
  personId: UUIDFilter

  """Filter by the object’s `role` field."""
  role: StringFilter
}

"""An input for mutations affecting `ClientOrganisationContact`"""
input ClientOrganisationContactInput {
  clientOrganisation: ClientOrganisationContactOrganisationIdFkeyInput
  clientPerson: ClientOrganisationContactPersonIdFkeyInput
  isPrimary: Boolean
  organisationId: UUID
  personId: UUID
  role: String
}

"""The globally unique `ID` look up for the row to connect."""
input ClientOrganisationContactNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `clientOrganisationContact` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input ClientOrganisationContactNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `clientOrganisationContact` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientOrganisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientOrganisation` being updated.
  """
  patch: ClientOrganisationPatch!
}

"""
The fields on `clientOrganisationContact` to look up the row to update.
"""
input ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyUsingClientOrganisationContactPkeyUpdate {
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `clientOrganisationContact` being updated.
  """
  patch: updateClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyPatch!
  personId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientPerson` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: ClientPersonPatch!
}

"""
The fields on `clientOrganisationContact` to look up the row to update.
"""
input ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyUsingClientOrganisationContactPkeyUpdate {
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `clientOrganisationContact` being updated.
  """
  patch: updateClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyPatch!
  personId: UUID!
}

"""The `clientOrganisationContact` to be created by this mutation."""
input ClientOrganisationContactOrganisationIdFkeyClientOrganisationContactCreateInput {
  clientOrganisation: ClientOrganisationContactOrganisationIdFkeyInput
  clientPerson: ClientOrganisationContactPersonIdFkeyInput
  isPrimary: Boolean
  organisationId: UUID
  personId: UUID
  role: String
}

"""The `clientOrganisation` to be created by this mutation."""
input ClientOrganisationContactOrganisationIdFkeyClientOrganisationCreateInput {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String!
}

"""
Input for the nested mutation of `clientOrganisation` in the `ClientOrganisationContactInput` mutation.
"""
input ClientOrganisationContactOrganisationIdFkeyInput {
  """
  The primary key(s) for `clientOrganisation` for the far side of the relationship.
  """
  connectById: ClientOrganisationClientOrganisationPkeyConnect

  """
  The primary key(s) for `clientOrganisation` for the far side of the relationship.
  """
  connectByNodeId: ClientOrganisationNodeIdConnect

  """
  A `ClientOrganisationInput` object that will be created and connected to this object.
  """
  create: ClientOrganisationContactOrganisationIdFkeyClientOrganisationCreateInput

  """
  The primary key(s) and patch data for `clientOrganisation` for the far side of the relationship.
  """
  updateById: ClientOrganisationOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyUsingClientOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `clientOrganisation` for the far side of the relationship.
  """
  updateByNodeId: ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `clientOrganisationContact` in the `ClientOrganisationInput` mutation.
"""
input ClientOrganisationContactOrganisationIdFkeyInverseInput {
  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  connectByNodeId: [ClientOrganisationContactNodeIdConnect!]

  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  connectByPersonIdAndOrganisationId: [ClientOrganisationContactClientOrganisationContactPkeyConnect!]

  """
  A `ClientOrganisationContactInput` object that will be created and connected to this object.
  """
  create: [ClientOrganisationContactOrganisationIdFkeyClientOrganisationContactCreateInput!]

  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  deleteByNodeId: [ClientOrganisationContactNodeIdDelete!]

  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  deleteByPersonIdAndOrganisationId: [ClientOrganisationContactClientOrganisationContactPkeyDelete!]

  """
  Flag indicating whether all other `clientOrganisationContact` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `clientOrganisationContact` for the far side of the relationship.
  """
  updateByNodeId: [ClientOrganisationOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `clientOrganisationContact` for the far side of the relationship.
  """
  updateByPersonIdAndOrganisationId: [ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyUsingClientOrganisationContactPkeyUpdate!]
}

"""
Represents an update to a `ClientOrganisationContact`. Fields that are set will be updated.
"""
input ClientOrganisationContactPatch {
  clientOrganisation: ClientOrganisationContactOrganisationIdFkeyInput
  clientPerson: ClientOrganisationContactPersonIdFkeyInput
  isPrimary: Boolean
  organisationId: UUID
  personId: UUID
  role: String
}

"""The `clientOrganisationContact` to be created by this mutation."""
input ClientOrganisationContactPersonIdFkeyClientOrganisationContactCreateInput {
  clientOrganisation: ClientOrganisationContactOrganisationIdFkeyInput
  clientPerson: ClientOrganisationContactPersonIdFkeyInput
  isPrimary: Boolean
  organisationId: UUID
  personId: UUID
  role: String
}

"""The `clientPerson` to be created by this mutation."""
input ClientOrganisationContactPersonIdFkeyClientPersonCreateInput {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String!
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String!
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `clientPerson` in the `ClientOrganisationContactInput` mutation.
"""
input ClientOrganisationContactPersonIdFkeyInput {
  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectById: ClientPersonClientPersonPkeyConnect

  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectByNodeId: ClientPersonNodeIdConnect

  """
  A `ClientPersonInput` object that will be created and connected to this object.
  """
  create: ClientOrganisationContactPersonIdFkeyClientPersonCreateInput

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateById: ClientPersonOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyUsingClientPersonPkeyUpdate

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateByNodeId: ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `clientOrganisationContact` in the `ClientPersonInput` mutation.
"""
input ClientOrganisationContactPersonIdFkeyInverseInput {
  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  connectByNodeId: [ClientOrganisationContactNodeIdConnect!]

  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  connectByPersonIdAndOrganisationId: [ClientOrganisationContactClientOrganisationContactPkeyConnect!]

  """
  A `ClientOrganisationContactInput` object that will be created and connected to this object.
  """
  create: [ClientOrganisationContactPersonIdFkeyClientOrganisationContactCreateInput!]

  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  deleteByNodeId: [ClientOrganisationContactNodeIdDelete!]

  """
  The primary key(s) for `clientOrganisationContact` for the far side of the relationship.
  """
  deleteByPersonIdAndOrganisationId: [ClientOrganisationContactClientOrganisationContactPkeyDelete!]

  """
  Flag indicating whether all other `clientOrganisationContact` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `clientOrganisationContact` for the far side of the relationship.
  """
  updateByNodeId: [ClientPersonOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `clientOrganisationContact` for the far side of the relationship.
  """
  updateByPersonIdAndOrganisationId: [ClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyUsingClientOrganisationContactPkeyUpdate!]
}

"""A connection to a list of `ClientOrganisationContact` values."""
type ClientOrganisationContactsConnection {
  """
  A list of edges which contains the `ClientOrganisationContact` and cursor to aid in pagination.
  """
  edges: [ClientOrganisationContactsEdge!]!

  """A list of `ClientOrganisationContact` objects."""
  nodes: [ClientOrganisationContact!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ClientOrganisationContact` you could get from the connection.
  """
  totalCount: Int!
}

"""A `ClientOrganisationContact` edge in the connection."""
type ClientOrganisationContactsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ClientOrganisationContact` at the end of the edge."""
  node: ClientOrganisationContact!
}

"""Methods to use when ordering `ClientOrganisationContact`."""
enum ClientOrganisationContactsOrderBy {
  IS_PRIMARY_ASC
  IS_PRIMARY_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PERSON_ID_ASC
  PERSON_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROLE_ASC
  ROLE_DESC
}

"""
A filter to be used against `ClientOrganisation` object types. All fields are combined with a logical ‘and.’
"""
input ClientOrganisationFilter {
  """Checks for all expressions in this list."""
  and: [ClientOrganisationFilter!]

  """Filter by the object’s `client` relation."""
  client: ClientFilter

  """Filter by the object’s `contact` relation."""
  contact: ClientOrganisationToManyClientOrganisationContactFilter

  """Some related `contact` exist."""
  contactExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `metadata` relation."""
  metadata: ClientOrganisationToManyMetaFilter

  """Some related `metadata` exist."""
  metadataExist: Boolean

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: ClientOrganisationFilter

  """Checks for any expressions in this list."""
  or: [ClientOrganisationFilter!]
}

"""The `client` to be created by this mutation."""
input ClientOrganisationIdFkey1ClientCreateInput {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType!
  user: ClientAuthorIdFkeyInput
}

"""The `clientOrganisation` to be created by this mutation."""
input ClientOrganisationIdFkey1ClientOrganisationCreateInput {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String!
}

"""
Input for the nested mutation of `client` in the `ClientOrganisationInput` mutation.
"""
input ClientOrganisationIdFkey1Input {
  """The primary key(s) for `client` for the far side of the relationship."""
  connectById: ClientClientPkeyConnect

  """The primary key(s) for `client` for the far side of the relationship."""
  connectByNodeId: ClientNodeIdConnect

  """
  A `ClientInput` object that will be created and connected to this object.
  """
  create: ClientOrganisationIdFkey1ClientCreateInput

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteById: ClientClientPkeyDelete

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteByNodeId: ClientNodeIdDelete

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateById: ClientOnClientOrganisationForClientOrganisationIdFkey1UsingClientPkeyUpdate

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateByNodeId: ClientOrganisationOnClientOrganisationForClientOrganisationIdFkey1NodeIdUpdate
}

"""
Input for the nested mutation of `clientOrganisation` in the `ClientInput` mutation.
"""
input ClientOrganisationIdFkey1InverseInput {
  """
  The primary key(s) for `clientOrganisation` for the far side of the relationship.
  """
  connectById: ClientOrganisationClientOrganisationPkeyConnect

  """
  The primary key(s) for `clientOrganisation` for the far side of the relationship.
  """
  connectByNodeId: ClientOrganisationNodeIdConnect

  """
  A `ClientOrganisationInput` object that will be created and connected to this object.
  """
  create: [ClientOrganisationIdFkey1ClientOrganisationCreateInput!]

  """
  The primary key(s) and patch data for `clientOrganisation` for the far side of the relationship.
  """
  updateById: ClientOrganisationOnClientOrganisationForClientOrganisationIdFkey1UsingClientOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `clientOrganisation` for the far side of the relationship.
  """
  updateByNodeId: ClientOnClientOrganisationForClientOrganisationIdFkey1NodeIdUpdate
}

"""The `client` to be created by this mutation."""
input ClientOrganisationIdFkeyClientCreateInput {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType!
  user: ClientAuthorIdFkeyInput
}

"""
Input for the nested mutation of `organisation` in the `ClientInput` mutation.
"""
input ClientOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnClientForClientOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: ClientOnClientForClientOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `client` in the `OrganisationInput` mutation.
"""
input ClientOrganisationIdFkeyInverseInput {
  """The primary key(s) for `client` for the far side of the relationship."""
  connectById: [ClientClientPkeyConnect!]

  """The primary key(s) for `client` for the far side of the relationship."""
  connectByNodeId: [ClientNodeIdConnect!]

  """
  A `ClientInput` object that will be created and connected to this object.
  """
  create: [ClientOrganisationIdFkeyClientCreateInput!]

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteById: [ClientClientPkeyDelete!]

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteByNodeId: [ClientNodeIdDelete!]

  """
  Flag indicating whether all other `client` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateById: [ClientOnClientForClientOrganisationIdFkeyUsingClientPkeyUpdate!]

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnClientForClientOrganisationIdFkeyNodeIdUpdate!]
}

"""An input for mutations affecting `ClientOrganisation`"""
input ClientOrganisationInput {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String!
}

"""The globally unique `ID` look up for the row to connect."""
input ClientOrganisationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `clientOrganisation` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOrganisationOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientOrganisationContact` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientOrganisationContact` being updated.
  """
  patch: ClientOrganisationContactPatch!
}

"""The fields on `clientOrganisation` to look up the row to update."""
input ClientOrganisationOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyUsingClientOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientOrganisation` being updated.
  """
  patch: updateClientOrganisationOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOrganisationOnClientOrganisationForClientOrganisationIdFkey1NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `client` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: ClientPatch!
}

"""The fields on `clientOrganisation` to look up the row to update."""
input ClientOrganisationOnClientOrganisationForClientOrganisationIdFkey1UsingClientOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientOrganisation` being updated.
  """
  patch: updateClientOrganisationOnClientOrganisationForClientOrganisationIdFkey1Patch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientOrganisationOnMetaForMetadataClientOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meta` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: MetaPatch!
}

"""The fields on `clientOrganisation` to look up the row to update."""
input ClientOrganisationOnMetaForMetadataClientOrganisationIdFkeyUsingClientOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientOrganisation` being updated.
  """
  patch: updateClientOrganisationOnMetaForMetadataClientOrganisationIdFkeyPatch!
}

"""
Represents an update to a `ClientOrganisation`. Fields that are set will be updated.
"""
input ClientOrganisationPatch {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String
}

"""
A filter to be used against many `ClientOrganisationContact` object types. All fields are combined with a logical ‘and.’
"""
input ClientOrganisationToManyClientOrganisationContactFilter {
  """
  Every related `ClientOrganisationContact` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ClientOrganisationContactFilter

  """
  No related `ClientOrganisationContact` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ClientOrganisationContactFilter

  """
  Some related `ClientOrganisationContact` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ClientOrganisationContactFilter
}

"""
A filter to be used against many `Meta` object types. All fields are combined with a logical ‘and.’
"""
input ClientOrganisationToManyMetaFilter {
  """
  Every related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MetaFilter

  """
  No related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MetaFilter

  """
  Some related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MetaFilter
}

"""A `ClientOrganisation` edge in the connection."""
type ClientOrganisationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ClientOrganisation` at the end of the edge."""
  node: ClientOrganisation!
}

"""Methods to use when ordering `ClientOrganisation`."""
enum ClientOrganisationsOrderBy {
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
Represents an update to a `Client`. Fields that are set will be updated.
"""
input ClientPatch {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType
  user: ClientAuthorIdFkeyInput
}

"""A connection to a list of `ClientPerson` values."""
type ClientPeopleConnection {
  """
  A list of edges which contains the `ClientPerson` and cursor to aid in pagination.
  """
  edges: [ClientPeopleEdge!]!

  """A list of `ClientPerson` objects."""
  nodes: [ClientPerson!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ClientPerson` you could get from the connection."""
  totalCount: Int!
}

"""A `ClientPerson` edge in the connection."""
type ClientPeopleEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ClientPerson` at the end of the edge."""
  node: ClientPerson!
}

"""Methods to use when ordering `ClientPerson`."""
enum ClientPeopleOrderBy {
  FAMILY_NAME_ASC
  FAMILY_NAME_DESC
  GIVEN_NAME_ASC
  GIVEN_NAME_DESC
  HONORIFIC_ASC
  HONORIFIC_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PREFERRED_NAME_ASC
  PREFERRED_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

type ClientPerson implements Node {
  """Reads a single `Client` that is related to this `ClientPerson`."""
  client: Client

  """
  Reads and enables pagination through a set of `ClientOrganisationContact`.
  """
  contact(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientOrganisationContactCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientOrganisationContactFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationContactsConnection!

  """
  Reads and enables pagination through a set of `ClientOrganisationContact`.
  """
  contactList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientOrganisationContactCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientOrganisationContactFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!]
  ): [ClientOrganisationContact!]!
  familyName: String! @deprecated(reason: "Use `name`")
  givenName: String @deprecated(reason: "Use `name`")
  honorific: Honorific
  id: UUID!

  """Reads and enables pagination through a set of `Meta`."""
  metadata(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasConnection!

  """Reads and enables pagination through a set of `Meta`."""
  metadataList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]
  ): [Meta!]!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  preferredName: String

  """Reads a single `User` that is related to this `ClientPerson`."""
  user: User
  userId: UUID
}

"""The fields on `clientPerson` to look up the row to connect."""
input ClientPersonClientPersonPkeyConnect {
  id: UUID!
}

"""
A condition to be used against `ClientPerson` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ClientPersonCondition {
  """Checks for equality with the object’s `familyName` field."""
  familyName: String

  """Checks for equality with the object’s `givenName` field."""
  givenName: String

  """Checks for equality with the object’s `honorific` field."""
  honorific: Honorific

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `preferredName` field."""
  preferredName: String

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `ClientPerson` object types. All fields are combined with a logical ‘and.’
"""
input ClientPersonFilter {
  """Checks for all expressions in this list."""
  and: [ClientPersonFilter!]

  """Filter by the object’s `client` relation."""
  client: ClientFilter

  """Filter by the object’s `contact` relation."""
  contact: ClientPersonToManyClientOrganisationContactFilter

  """Some related `contact` exist."""
  contactExist: Boolean

  """Filter by the object’s `familyName` field."""
  familyName: StringFilter

  """Filter by the object’s `givenName` field."""
  givenName: StringFilter

  """Filter by the object’s `honorific` field."""
  honorific: HonorificFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `metadata` relation."""
  metadata: ClientPersonToManyMetaFilter

  """Some related `metadata` exist."""
  metadataExist: Boolean

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: ClientPersonFilter

  """Checks for any expressions in this list."""
  or: [ClientPersonFilter!]

  """Filter by the object’s `preferredName` field."""
  preferredName: StringFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""The `client` to be created by this mutation."""
input ClientPersonIdFkeyClientCreateInput {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType!
  user: ClientAuthorIdFkeyInput
}

"""The `clientPerson` to be created by this mutation."""
input ClientPersonIdFkeyClientPersonCreateInput {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String!
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String!
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `client` in the `ClientPersonInput` mutation.
"""
input ClientPersonIdFkeyInput {
  """The primary key(s) for `client` for the far side of the relationship."""
  connectById: ClientClientPkeyConnect

  """The primary key(s) for `client` for the far side of the relationship."""
  connectByNodeId: ClientNodeIdConnect

  """
  A `ClientInput` object that will be created and connected to this object.
  """
  create: ClientPersonIdFkeyClientCreateInput

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteById: ClientClientPkeyDelete

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteByNodeId: ClientNodeIdDelete

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateById: ClientOnClientPersonForClientPersonIdFkeyUsingClientPkeyUpdate

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateByNodeId: ClientPersonOnClientPersonForClientPersonIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `clientPerson` in the `ClientInput` mutation.
"""
input ClientPersonIdFkeyInverseInput {
  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectById: ClientPersonClientPersonPkeyConnect

  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectByNodeId: ClientPersonNodeIdConnect

  """
  A `ClientPersonInput` object that will be created and connected to this object.
  """
  create: [ClientPersonIdFkeyClientPersonCreateInput!]

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateById: ClientPersonOnClientPersonForClientPersonIdFkeyUsingClientPersonPkeyUpdate

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateByNodeId: ClientOnClientPersonForClientPersonIdFkeyNodeIdUpdate
}

"""An input for mutations affecting `ClientPerson`"""
input ClientPersonInput {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String!
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String!
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input ClientPersonNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `clientPerson` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input ClientPersonOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientOrganisationContact` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientOrganisationContact` being updated.
  """
  patch: ClientOrganisationContactPatch!
}

"""The fields on `clientPerson` to look up the row to update."""
input ClientPersonOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyUsingClientPersonPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: updateClientPersonOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientPersonOnClientPersonForClientPersonIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `client` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: ClientPatch!
}

"""The fields on `clientPerson` to look up the row to update."""
input ClientPersonOnClientPersonForClientPersonIdFkeyUsingClientPersonPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: updateClientPersonOnClientPersonForClientPersonIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientPersonOnClientPersonForClientPersonUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `clientPerson` to look up the row to update."""
input ClientPersonOnClientPersonForClientPersonUserIdFkeyUsingClientPersonPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: updateClientPersonOnClientPersonForClientPersonUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input ClientPersonOnMetaForMetadataClientPersonIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meta` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: MetaPatch!
}

"""The fields on `clientPerson` to look up the row to update."""
input ClientPersonOnMetaForMetadataClientPersonIdFkeyUsingClientPersonPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: updateClientPersonOnMetaForMetadataClientPersonIdFkeyPatch!
}

"""
Represents an update to a `ClientPerson`. Fields that are set will be updated.
"""
input ClientPersonPatch {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
A filter to be used against many `ClientOrganisationContact` object types. All fields are combined with a logical ‘and.’
"""
input ClientPersonToManyClientOrganisationContactFilter {
  """
  Every related `ClientOrganisationContact` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ClientOrganisationContactFilter

  """
  No related `ClientOrganisationContact` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ClientOrganisationContactFilter

  """
  Some related `ClientOrganisationContact` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ClientOrganisationContactFilter
}

"""
A filter to be used against many `Meta` object types. All fields are combined with a logical ‘and.’
"""
input ClientPersonToManyMetaFilter {
  """
  Every related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MetaFilter

  """
  No related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MetaFilter

  """
  Some related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MetaFilter
}

"""The `clientPerson` to be created by this mutation."""
input ClientPersonUserIdFkeyClientPersonCreateInput {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String!
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String!
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `user` in the `ClientPersonInput` mutation.
"""
input ClientPersonUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnClientPersonForClientPersonUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: ClientPersonOnClientPersonForClientPersonUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `clientPerson` in the `UserInput` mutation.
"""
input ClientPersonUserIdFkeyInverseInput {
  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectById: [ClientPersonClientPersonPkeyConnect!]

  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectByNodeId: [ClientPersonNodeIdConnect!]

  """
  A `ClientPersonInput` object that will be created and connected to this object.
  """
  create: [ClientPersonUserIdFkeyClientPersonCreateInput!]

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateById: [ClientPersonOnClientPersonForClientPersonUserIdFkeyUsingClientPersonPkeyUpdate!]

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateByNodeId: [UserOnClientPersonForClientPersonUserIdFkeyNodeIdUpdate!]
}

"""
A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’
"""
input ClientToManyTripFilter {
  """
  Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripFilter

  """
  No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripFilter

  """
  Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripFilter
}

enum ClientType {
  ORGANISATION
  PERSON
}

"""
A filter to be used against ClientType fields. All fields are combined with a logical ‘and.’
"""
input ClientTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: ClientType

  """Equal to the specified value."""
  equalTo: ClientType

  """Greater than the specified value."""
  greaterThan: ClientType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: ClientType

  """Included in the specified list."""
  in: [ClientType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: ClientType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: ClientType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: ClientType

  """Not equal to the specified value."""
  notEqualTo: ClientType

  """Not included in the specified list."""
  notIn: [ClientType!]
}

"""A connection to a list of `Client` values."""
type ClientsConnection {
  """
  A list of edges which contains the `Client` and cursor to aid in pagination.
  """
  edges: [ClientsEdge!]!

  """A list of `Client` objects."""
  nodes: [Client!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Client` you could get from the connection."""
  totalCount: Int!
}

"""A `Client` edge in the connection."""
type ClientsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Client` at the end of the edge."""
  node: Client!
}

"""Methods to use when ordering `Client`."""
enum ClientsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""All input for the `cloneTrip` mutation."""
input CloneTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `cloneTrip` mutation."""
type CloneTripPayload {
  """Reads a single `Client` that is related to this `Trip`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation

  """Reads a single `User` that is related to this `Trip`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip
  trip: Trip

  """An edge for our `Trip`. May be used by Relay 1."""
  tripEdge(
    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsEdge
}

enum CollaborationRole {
  ADMIN
  EDITOR
  OWNER
  VIEWER
  VIEWER_WITH_BUDGET
}

"""
A filter to be used against CollaborationRole fields. All fields are combined with a logical ‘and.’
"""
input CollaborationRoleFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: CollaborationRole

  """Equal to the specified value."""
  equalTo: CollaborationRole

  """Greater than the specified value."""
  greaterThan: CollaborationRole

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: CollaborationRole

  """Included in the specified list."""
  in: [CollaborationRole!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: CollaborationRole

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: CollaborationRole

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: CollaborationRole

  """Not equal to the specified value."""
  notEqualTo: CollaborationRole

  """Not included in the specified list."""
  notIn: [CollaborationRole!]
}

type Collaborator implements Node {
  """When this item was created"""
  createdAt: Datetime
  email: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  permissions: [Permission] @deprecated(reason: "Use role")
  role: CollaborationRole!

  """Reads a single `Trip` that is related to this `Collaborator`."""
  trip: Trip
  tripId: UUID!

  """When this item was updated"""
  updatedAt: Datetime

  """Reads a single `User` that is related to this `Collaborator`."""
  user: User
  userId: UUID!
}

"""The fields on `collaborator` to look up the row to connect."""
input CollaboratorCollaboratorPkeyConnect {
  tripId: UUID!
  userId: UUID!
}

"""
A condition to be used against `Collaborator` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CollaboratorCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `permissions` field."""
  permissions: [Permission]

  """Checks for equality with the object’s `role` field."""
  role: CollaborationRole

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `Collaborator` object types. All fields are combined with a logical ‘and.’
"""
input CollaboratorFilter {
  """Checks for all expressions in this list."""
  and: [CollaboratorFilter!]

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Negates the expression."""
  not: CollaboratorFilter

  """Checks for any expressions in this list."""
  or: [CollaboratorFilter!]

  """Filter by the object’s `permissions` field."""
  permissions: PermissionListFilter

  """Filter by the object’s `role` field."""
  role: CollaborationRoleFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""The globally unique `ID` look up for the row to connect."""
input CollaboratorNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `collaborator` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CollaboratorOnCollaboratorForCollaboratorTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `collaborator` to look up the row to update."""
input CollaboratorOnCollaboratorForCollaboratorTripIdFkeyUsingCollaboratorPkeyUpdate {
  """
  An object where the defined keys will be set on the `collaborator` being updated.
  """
  patch: updateCollaboratorOnCollaboratorForCollaboratorTripIdFkeyPatch!
  tripId: UUID!
  userId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input CollaboratorOnCollaboratorForCollaboratorUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `collaborator` to look up the row to update."""
input CollaboratorOnCollaboratorForCollaboratorUserIdFkeyUsingCollaboratorPkeyUpdate {
  """
  An object where the defined keys will be set on the `collaborator` being updated.
  """
  patch: updateCollaboratorOnCollaboratorForCollaboratorUserIdFkeyPatch!
  tripId: UUID!
  userId: UUID!
}

"""
Represents an update to a `Collaborator`. Fields that are set will be updated.
"""
input CollaboratorPatch {
  permissions: [Permission]
  role: CollaborationRole
  trip: CollaboratorTripIdFkeyInput
  tripId: UUID
  user: CollaboratorUserIdFkeyInput
  userId: UUID
}

"""All input for the `collaboratorRevoke` mutation."""
input CollaboratorRevokeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  tripId: UUID!
  userId: UUID
}

"""The output of our `collaboratorRevoke` mutation."""
type CollaboratorRevokePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
Input for the nested mutation of `trip` in the `CollaboratorInput` mutation.
"""
input CollaboratorTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: CollaboratorTripIdFkeyTripCreateInput

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnCollaboratorForCollaboratorTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: CollaboratorOnCollaboratorForCollaboratorTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `collaborator` in the `TripInput` mutation.
"""
input CollaboratorTripIdFkeyInverseInput {
  """
  The primary key(s) for `collaborator` for the far side of the relationship.
  """
  connectByNodeId: [CollaboratorNodeIdConnect!]

  """
  The primary key(s) for `collaborator` for the far side of the relationship.
  """
  connectByTripIdAndUserId: [CollaboratorCollaboratorPkeyConnect!]

  """
  The primary key(s) and patch data for `collaborator` for the far side of the relationship.
  """
  updateByNodeId: [TripOnCollaboratorForCollaboratorTripIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `collaborator` for the far side of the relationship.
  """
  updateByTripIdAndUserId: [CollaboratorOnCollaboratorForCollaboratorTripIdFkeyUsingCollaboratorPkeyUpdate!]
}

"""The `trip` to be created by this mutation."""
input CollaboratorTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
Input for the nested mutation of `user` in the `CollaboratorInput` mutation.
"""
input CollaboratorUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnCollaboratorForCollaboratorUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: CollaboratorOnCollaboratorForCollaboratorUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `collaborator` in the `UserInput` mutation.
"""
input CollaboratorUserIdFkeyInverseInput {
  """
  The primary key(s) for `collaborator` for the far side of the relationship.
  """
  connectByNodeId: [CollaboratorNodeIdConnect!]

  """
  The primary key(s) for `collaborator` for the far side of the relationship.
  """
  connectByTripIdAndUserId: [CollaboratorCollaboratorPkeyConnect!]

  """
  The primary key(s) and patch data for `collaborator` for the far side of the relationship.
  """
  updateByNodeId: [UserOnCollaboratorForCollaboratorUserIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `collaborator` for the far side of the relationship.
  """
  updateByTripIdAndUserId: [CollaboratorOnCollaboratorForCollaboratorUserIdFkeyUsingCollaboratorPkeyUpdate!]
}

"""A connection to a list of `Collaborator` values."""
type CollaboratorsConnection {
  """
  A list of edges which contains the `Collaborator` and cursor to aid in pagination.
  """
  edges: [CollaboratorsEdge!]!

  """A list of `Collaborator` objects."""
  nodes: [Collaborator!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Collaborator` you could get from the connection."""
  totalCount: Int!
}

"""A `Collaborator` edge in the connection."""
type CollaboratorsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Collaborator` at the end of the edge."""
  node: Collaborator!
}

"""Methods to use when ordering `Collaborator`."""
enum CollaboratorsOrderBy {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NATURAL
  PERMISSIONS_ASC
  PERMISSIONS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROLE_ASC
  ROLE_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
}

type Continent implements Node {
  """Reads and enables pagination through a set of `Country`."""
  countries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesConnection!

  """Reads and enables pagination through a set of `Country`."""
  countriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
  ): [Country!]!
  id: UUID!
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `Continent` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ContinentCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""The fields on `continent` to look up the row to connect."""
input ContinentContinentNameKeyConnect {
  name: String!
}

"""The fields on `continent` to look up the row to delete."""
input ContinentContinentNameKeyDelete {
  name: String!
}

"""The fields on `continent` to look up the row to connect."""
input ContinentContinentPkeyConnect {
  id: UUID!
}

"""The fields on `continent` to look up the row to delete."""
input ContinentContinentPkeyDelete {
  id: UUID!
}

"""
A filter to be used against `Continent` object types. All fields are combined with a logical ‘and.’
"""
input ContinentFilter {
  """Checks for all expressions in this list."""
  and: [ContinentFilter!]

  """Filter by the object’s `countries` relation."""
  countries: ContinentToManyCountryFilter

  """Some related `countries` exist."""
  countriesExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: ContinentFilter

  """Checks for any expressions in this list."""
  or: [ContinentFilter!]
}

"""An input for mutations affecting `Continent`"""
input ContinentInput {
  countries: CountryContinentIdFkeyInverseInput
  id: UUID
  name: String
}

"""The globally unique `ID` look up for the row to connect."""
input ContinentNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `continent` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input ContinentNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `continent` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input ContinentOnCountryForCountryContinentIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `continent` to look up the row to update."""
input ContinentOnCountryForCountryContinentIdFkeyUsingContinentNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `continent` being updated.
  """
  patch: updateContinentOnCountryForCountryContinentIdFkeyPatch!
}

"""The fields on `continent` to look up the row to update."""
input ContinentOnCountryForCountryContinentIdFkeyUsingContinentPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `continent` being updated.
  """
  patch: updateContinentOnCountryForCountryContinentIdFkeyPatch!
}

"""
Represents an update to a `Continent`. Fields that are set will be updated.
"""
input ContinentPatch {
  countries: CountryContinentIdFkeyInverseInput
  id: UUID
  name: String
}

"""
A filter to be used against many `Country` object types. All fields are combined with a logical ‘and.’
"""
input ContinentToManyCountryFilter {
  """
  Every related `Country` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CountryFilter

  """
  No related `Country` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CountryFilter

  """
  Some related `Country` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CountryFilter
}

"""A connection to a list of `Continent` values."""
type ContinentsConnection {
  """
  A list of edges which contains the `Continent` and cursor to aid in pagination.
  """
  edges: [ContinentsEdge!]!

  """A list of `Continent` objects."""
  nodes: [Continent!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Continent` you could get from the connection."""
  totalCount: Int!
}

"""A `Continent` edge in the connection."""
type ContinentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Continent` at the end of the edge."""
  node: Continent!
}

"""Methods to use when ordering `Continent`."""
enum ContinentsOrderBy {
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type CostItem implements Node {
  agentProfit: Float

  """Reads a single `Card` that is related to this `CostItem`."""
  card: Card
  cardId: UUID
  costConverted: Float

  """Reads a single `Currency` that is related to this `CostItem`."""
  costCurrency: Currency
  costCurrencyId: UUID

  """Reads a single `CostTax` that is related to this `CostItem`."""
  costTax: CostTax
  costTaxId: UUID
  costType: CostType
  costValue: Float
  discountPercent: Float
  discountQuantity: Int
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Organisation` that is related to this `CostItem`."""
  organisation: Organisation
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""The `card` to be created by this mutation."""
input CostItemCardIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""The `costItem` to be created by this mutation."""
input CostItemCardIdFkeyCostItemCreateInput {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""
Input for the nested mutation of `card` in the `CostItemInput` mutation.
"""
input CostItemCardIdFkeyInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: CardCardPkeyConnect

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: CardNodeIdConnect

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: CostItemCardIdFkeyCardCreateInput

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: CardCardPkeyDelete

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: CardNodeIdDelete

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: CardOnCostItemForCostItemCardIdFkeyUsingCardPkeyUpdate

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: CostItemOnCostItemForCostItemCardIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `costItem` in the `CardInput` mutation.
"""
input CostItemCardIdFkeyInverseInput {
  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectById: [CostItemCostItemPkeyConnect!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectByNodeId: [CostItemNodeIdConnect!]

  """
  A `CostItemInput` object that will be created and connected to this object.
  """
  create: [CostItemCardIdFkeyCostItemCreateInput!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteById: [CostItemCostItemPkeyDelete!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteByNodeId: [CostItemNodeIdDelete!]

  """
  Flag indicating whether all other `costItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateById: [CostItemOnCostItemForCostItemCardIdFkeyUsingCostItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateByNodeId: [CardOnCostItemForCostItemCardIdFkeyNodeIdUpdate!]
}

"""
A condition to be used against `CostItem` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CostItemCondition {
  """Checks for equality with the object’s `agentProfit` field."""
  agentProfit: Float

  """Checks for equality with the object’s `cardId` field."""
  cardId: UUID

  """Checks for equality with the object’s `costConverted` field."""
  costConverted: Float

  """Checks for equality with the object’s `costCurrencyId` field."""
  costCurrencyId: UUID

  """Checks for equality with the object’s `costTaxId` field."""
  costTaxId: UUID

  """Checks for equality with the object’s `costType` field."""
  costType: CostType

  """Checks for equality with the object’s `costValue` field."""
  costValue: Float

  """Checks for equality with the object’s `discountPercent` field."""
  discountPercent: Float

  """Checks for equality with the object’s `discountQuantity` field."""
  discountQuantity: Int

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `primaryQuantity` field."""
  primaryQuantity: Int

  """Checks for equality with the object’s `primaryType` field."""
  primaryType: String

  """Checks for equality with the object’s `secondaryQuantity` field."""
  secondaryQuantity: Int

  """Checks for equality with the object’s `secondaryType` field."""
  secondaryType: String
}

"""The `costItem` to be created by this mutation."""
input CostItemCostCurrencyIdFkeyCostItemCreateInput {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""The `currency` to be created by this mutation."""
input CostItemCostCurrencyIdFkeyCurrencyCreateInput {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
Input for the nested mutation of `currency` in the `CostItemInput` mutation.
"""
input CostItemCostCurrencyIdFkeyInput {
  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectById: CurrencyCurrencyPkeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByIso: CurrencyCurrencyIsoKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByName: CurrencyCurrencyNameKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByNodeId: CurrencyNodeIdConnect

  """
  A `CurrencyInput` object that will be created and connected to this object.
  """
  create: CostItemCostCurrencyIdFkeyCurrencyCreateInput

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteById: CurrencyCurrencyPkeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByIso: CurrencyCurrencyIsoKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByName: CurrencyCurrencyNameKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByNodeId: CurrencyNodeIdDelete

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateById: CurrencyOnCostItemForCostItemCostCurrencyIdFkeyUsingCurrencyPkeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByIso: CurrencyOnCostItemForCostItemCostCurrencyIdFkeyUsingCurrencyIsoKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByName: CurrencyOnCostItemForCostItemCostCurrencyIdFkeyUsingCurrencyNameKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByNodeId: CostItemOnCostItemForCostItemCostCurrencyIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `costItem` in the `CurrencyInput` mutation.
"""
input CostItemCostCurrencyIdFkeyInverseInput {
  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectById: [CostItemCostItemPkeyConnect!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectByNodeId: [CostItemNodeIdConnect!]

  """
  A `CostItemInput` object that will be created and connected to this object.
  """
  create: [CostItemCostCurrencyIdFkeyCostItemCreateInput!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteById: [CostItemCostItemPkeyDelete!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteByNodeId: [CostItemNodeIdDelete!]

  """
  Flag indicating whether all other `costItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateById: [CostItemOnCostItemForCostItemCostCurrencyIdFkeyUsingCostItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateByNodeId: [CurrencyOnCostItemForCostItemCostCurrencyIdFkeyNodeIdUpdate!]
}

"""The fields on `costItem` to look up the row to connect."""
input CostItemCostItemPkeyConnect {
  id: UUID!
}

"""The fields on `costItem` to look up the row to delete."""
input CostItemCostItemPkeyDelete {
  id: UUID!
}

"""The `costItem` to be created by this mutation."""
input CostItemCostTaxIdFkeyCostItemCreateInput {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""The `costTax` to be created by this mutation."""
input CostItemCostTaxIdFkeyCostTaxCreateInput {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID
  name: String!
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float!
}

"""
Input for the nested mutation of `costTax` in the `CostItemInput` mutation.
"""
input CostItemCostTaxIdFkeyInput {
  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectById: CostTaxCostTaxPkeyConnect

  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectByNodeId: CostTaxNodeIdConnect

  """
  A `CostTaxInput` object that will be created and connected to this object.
  """
  create: CostItemCostTaxIdFkeyCostTaxCreateInput

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteById: CostTaxCostTaxPkeyDelete

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteByNodeId: CostTaxNodeIdDelete

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateById: CostTaxOnCostItemForCostItemCostTaxIdFkeyUsingCostTaxPkeyUpdate

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateByNodeId: CostItemOnCostItemForCostItemCostTaxIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `costItem` in the `CostTaxInput` mutation.
"""
input CostItemCostTaxIdFkeyInverseInput {
  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectById: [CostItemCostItemPkeyConnect!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectByNodeId: [CostItemNodeIdConnect!]

  """
  A `CostItemInput` object that will be created and connected to this object.
  """
  create: [CostItemCostTaxIdFkeyCostItemCreateInput!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteById: [CostItemCostItemPkeyDelete!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteByNodeId: [CostItemNodeIdDelete!]

  """
  Flag indicating whether all other `costItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateById: [CostItemOnCostItemForCostItemCostTaxIdFkeyUsingCostItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateByNodeId: [CostTaxOnCostItemForCostItemCostTaxIdFkeyNodeIdUpdate!]
}

"""All input for the `costItemDuplicate` mutation."""
input CostItemDuplicateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  originalcardid: UUID!
  targetcardid: UUID!
}

"""The output of our `costItemDuplicate` mutation."""
type CostItemDuplicatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A filter to be used against `CostItem` object types. All fields are combined with a logical ‘and.’
"""
input CostItemFilter {
  """Filter by the object’s `agentProfit` field."""
  agentProfit: FloatFilter

  """Checks for all expressions in this list."""
  and: [CostItemFilter!]

  """Filter by the object’s `card` relation."""
  card: CardFilter

  """A related `card` exists."""
  cardExists: Boolean

  """Filter by the object’s `cardId` field."""
  cardId: UUIDFilter

  """Filter by the object’s `costConverted` field."""
  costConverted: FloatFilter

  """Filter by the object’s `costCurrency` relation."""
  costCurrency: CurrencyFilter

  """A related `costCurrency` exists."""
  costCurrencyExists: Boolean

  """Filter by the object’s `costCurrencyId` field."""
  costCurrencyId: UUIDFilter

  """Filter by the object’s `costTax` relation."""
  costTax: CostTaxFilter

  """A related `costTax` exists."""
  costTaxExists: Boolean

  """Filter by the object’s `costTaxId` field."""
  costTaxId: UUIDFilter

  """Filter by the object’s `costType` field."""
  costType: CostTypeFilter

  """Filter by the object’s `costValue` field."""
  costValue: FloatFilter

  """Filter by the object’s `discountPercent` field."""
  discountPercent: FloatFilter

  """Filter by the object’s `discountQuantity` field."""
  discountQuantity: IntFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: CostItemFilter

  """Checks for any expressions in this list."""
  or: [CostItemFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """A related `organisation` exists."""
  organisationExists: Boolean

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `primaryQuantity` field."""
  primaryQuantity: IntFilter

  """Filter by the object’s `primaryType` field."""
  primaryType: StringFilter

  """Filter by the object’s `secondaryQuantity` field."""
  secondaryQuantity: IntFilter

  """Filter by the object’s `secondaryType` field."""
  secondaryType: StringFilter
}

"""An input for mutations affecting `CostItem`"""
input CostItemInput {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""The globally unique `ID` look up for the row to connect."""
input CostItemNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `costItem` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input CostItemNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `costItem` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CostItemOnCostItemForCostItemCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `costItem` to look up the row to update."""
input CostItemOnCostItemForCostItemCardIdFkeyUsingCostItemPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: updateCostItemOnCostItemForCostItemCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CostItemOnCostItemForCostItemCostCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currency` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: CurrencyPatch!
}

"""The fields on `costItem` to look up the row to update."""
input CostItemOnCostItemForCostItemCostCurrencyIdFkeyUsingCostItemPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: updateCostItemOnCostItemForCostItemCostCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CostItemOnCostItemForCostItemCostTaxIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costTax` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: CostTaxPatch!
}

"""The fields on `costItem` to look up the row to update."""
input CostItemOnCostItemForCostItemCostTaxIdFkeyUsingCostItemPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: updateCostItemOnCostItemForCostItemCostTaxIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CostItemOnCostItemForCostItemOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `costItem` to look up the row to update."""
input CostItemOnCostItemForCostItemOrganisationIdFkeyUsingCostItemPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: updateCostItemOnCostItemForCostItemOrganisationIdFkeyPatch!
}

"""The `costItem` to be created by this mutation."""
input CostItemOrganisationIdFkeyCostItemCreateInput {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""
Input for the nested mutation of `organisation` in the `CostItemInput` mutation.
"""
input CostItemOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnCostItemForCostItemOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: CostItemOnCostItemForCostItemOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `costItem` in the `OrganisationInput` mutation.
"""
input CostItemOrganisationIdFkeyInverseInput {
  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectById: [CostItemCostItemPkeyConnect!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  connectByNodeId: [CostItemNodeIdConnect!]

  """
  A `CostItemInput` object that will be created and connected to this object.
  """
  create: [CostItemOrganisationIdFkeyCostItemCreateInput!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteById: [CostItemCostItemPkeyDelete!]

  """
  The primary key(s) for `costItem` for the far side of the relationship.
  """
  deleteByNodeId: [CostItemNodeIdDelete!]

  """
  Flag indicating whether all other `costItem` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateById: [CostItemOnCostItemForCostItemOrganisationIdFkeyUsingCostItemPkeyUpdate!]

  """
  The primary key(s) and patch data for `costItem` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnCostItemForCostItemOrganisationIdFkeyNodeIdUpdate!]
}

"""
Represents an update to a `CostItem`. Fields that are set will be updated.
"""
input CostItemPatch {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""A connection to a list of `CostItem` values."""
type CostItemsConnection {
  """
  A list of edges which contains the `CostItem` and cursor to aid in pagination.
  """
  edges: [CostItemsEdge!]!

  """A list of `CostItem` objects."""
  nodes: [CostItem!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CostItem` you could get from the connection."""
  totalCount: Int!
}

"""A `CostItem` edge in the connection."""
type CostItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CostItem` at the end of the edge."""
  node: CostItem!
}

"""Methods to use when ordering `CostItem`."""
enum CostItemsOrderBy {
  AGENT_PROFIT_ASC
  AGENT_PROFIT_DESC
  CARD_ID_ASC
  CARD_ID_DESC
  COST_CONVERTED_ASC
  COST_CONVERTED_DESC
  COST_CURRENCY_ID_ASC
  COST_CURRENCY_ID_DESC
  COST_TAX_ID_ASC
  COST_TAX_ID_DESC
  COST_TYPE_ASC
  COST_TYPE_DESC
  COST_VALUE_ASC
  COST_VALUE_DESC
  DISCOUNT_PERCENT_ASC
  DISCOUNT_PERCENT_DESC
  DISCOUNT_QUANTITY_ASC
  DISCOUNT_QUANTITY_DESC
  ID_ASC
  ID_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PRIMARY_QUANTITY_ASC
  PRIMARY_QUANTITY_DESC
  PRIMARY_TYPE_ASC
  PRIMARY_TYPE_DESC
  SECONDARY_QUANTITY_ASC
  SECONDARY_QUANTITY_DESC
  SECONDARY_TYPE_ASC
  SECONDARY_TYPE_DESC
}

type CostTax implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads and enables pagination through a set of `CostItem`."""
  costItems(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsConnection!

  """Reads and enables pagination through a set of `CostItem`."""
  costItemsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!]
  ): [CostItem!]!

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Organisation` that is related to this `CostTax`."""
  organisation: Organisation
  organisationId: UUID

  """Reads and enables pagination through a set of `Organisation`."""
  organisations(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsConnection!

  """Reads and enables pagination through a set of `Organisation`."""
  organisationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!]
  ): [Organisation!]!

  """When this item was restored"""
  restoredAt: Datetime

  """When this item was updated"""
  updatedAt: Datetime
  value: Float!
}

"""
A condition to be used against `CostTax` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CostTaxCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `value` field."""
  value: Float
}

"""The fields on `costTax` to look up the row to connect."""
input CostTaxCostTaxPkeyConnect {
  id: UUID!
}

"""The fields on `costTax` to look up the row to delete."""
input CostTaxCostTaxPkeyDelete {
  id: UUID!
}

"""
A filter to be used against `CostTax` object types. All fields are combined with a logical ‘and.’
"""
input CostTaxFilter {
  """Checks for all expressions in this list."""
  and: [CostTaxFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `costItems` relation."""
  costItems: CostTaxToManyCostItemFilter

  """Some related `costItems` exist."""
  costItemsExist: Boolean

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CostTaxFilter

  """Checks for any expressions in this list."""
  or: [CostTaxFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """A related `organisation` exists."""
  organisationExists: Boolean

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `organisations` relation."""
  organisations: CostTaxToManyOrganisationFilter

  """Some related `organisations` exist."""
  organisationsExist: Boolean

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `value` field."""
  value: FloatFilter
}

"""An input for mutations affecting `CostTax`"""
input CostTaxInput {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID
  name: String!
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float!
}

"""The globally unique `ID` look up for the row to connect."""
input CostTaxNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `costTax` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input CostTaxNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `costTax` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CostTaxOnCardCostForCardCostCostTaxFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `cardCost` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `cardCost` being updated.
  """
  patch: CardCostPatch!
}

"""The fields on `costTax` to look up the row to update."""
input CostTaxOnCardCostForCardCostCostTaxFkeyUsingCostTaxPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: updateCostTaxOnCardCostForCardCostCostTaxFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CostTaxOnCostItemForCostItemCostTaxIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: CostItemPatch!
}

"""The fields on `costTax` to look up the row to update."""
input CostTaxOnCostItemForCostItemCostTaxIdFkeyUsingCostTaxPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: updateCostTaxOnCostItemForCostItemCostTaxIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CostTaxOnCostTaxForCostTaxOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `costTax` to look up the row to update."""
input CostTaxOnCostTaxForCostTaxOrganisationIdFkeyUsingCostTaxPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: updateCostTaxOnCostTaxForCostTaxOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CostTaxOnOrganisationForOrganisationCostTaxIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `costTax` to look up the row to update."""
input CostTaxOnOrganisationForOrganisationCostTaxIdFkeyUsingCostTaxPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: updateCostTaxOnOrganisationForOrganisationCostTaxIdFkeyPatch!
}

"""The `costTax` to be created by this mutation."""
input CostTaxOrganisationIdFkeyCostTaxCreateInput {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID
  name: String!
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float!
}

"""
Input for the nested mutation of `organisation` in the `CostTaxInput` mutation.
"""
input CostTaxOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnCostTaxForCostTaxOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: CostTaxOnCostTaxForCostTaxOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `costTax` in the `OrganisationInput` mutation.
"""
input CostTaxOrganisationIdFkeyInverseInput {
  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectById: [CostTaxCostTaxPkeyConnect!]

  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectByNodeId: [CostTaxNodeIdConnect!]

  """
  A `CostTaxInput` object that will be created and connected to this object.
  """
  create: [CostTaxOrganisationIdFkeyCostTaxCreateInput!]

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteById: [CostTaxCostTaxPkeyDelete!]

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteByNodeId: [CostTaxNodeIdDelete!]

  """
  Flag indicating whether all other `costTax` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateById: [CostTaxOnCostTaxForCostTaxOrganisationIdFkeyUsingCostTaxPkeyUpdate!]

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnCostTaxForCostTaxOrganisationIdFkeyNodeIdUpdate!]
}

"""
Represents an update to a `CostTax`. Fields that are set will be updated.
"""
input CostTaxPatch {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float
}

"""
A filter to be used against many `CostItem` object types. All fields are combined with a logical ‘and.’
"""
input CostTaxToManyCostItemFilter {
  """
  Every related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CostItemFilter

  """
  No related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CostItemFilter

  """
  Some related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CostItemFilter
}

"""
A filter to be used against many `Organisation` object types. All fields are combined with a logical ‘and.’
"""
input CostTaxToManyOrganisationFilter {
  """
  Every related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationFilter

  """
  No related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationFilter

  """
  Some related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationFilter
}

"""A connection to a list of `CostTax` values."""
type CostTaxesConnection {
  """
  A list of edges which contains the `CostTax` and cursor to aid in pagination.
  """
  edges: [CostTaxesEdge!]!

  """A list of `CostTax` objects."""
  nodes: [CostTax!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CostTax` you could get from the connection."""
  totalCount: Int!
}

"""A `CostTax` edge in the connection."""
type CostTaxesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CostTax` at the end of the edge."""
  node: CostTax!
}

"""Methods to use when ordering `CostTax`."""
enum CostTaxesOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VALUE_ASC
  VALUE_DESC
}

enum CostType {
  GROSS
  NET
}

"""
A filter to be used against CostType fields. All fields are combined with a logical ‘and.’
"""
input CostTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: CostType

  """Equal to the specified value."""
  equalTo: CostType

  """Greater than the specified value."""
  greaterThan: CostType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: CostType

  """Included in the specified list."""
  in: [CostType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: CostType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: CostType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: CostType

  """Not equal to the specified value."""
  notEqualTo: CostType

  """Not included in the specified list."""
  notIn: [CostType!]
}

"""A connection to a list of `Country` values."""
type CountriesConnection {
  """
  A list of edges which contains the `Country` and cursor to aid in pagination.
  """
  edges: [CountriesEdge!]!

  """A list of `Country` objects."""
  nodes: [Country!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Country` you could get from the connection."""
  totalCount: Int!
}

"""A `Country` edge in the connection."""
type CountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Country` at the end of the edge."""
  node: Country!
}

"""Methods to use when ordering `Country`."""
enum CountriesOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  AVERAGE_TEMPERATURE_ASC
  AVERAGE_TEMPERATURE_DESC
  COLLOQUIAL_ASC
  COLLOQUIAL_DESC
  CONTINENT_ID_ASC
  CONTINENT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  ISO3_ASC
  ISO3_DESC
  ISO_ASC
  ISO_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  LOCATION_ASC
  LOCATION_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SLUG_ASC
  SLUG_DESC
  SYNONYMS_ASC
  SYNONYMS_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VOLTAGE_ASC
  VOLTAGE_DESC
}

type Country implements Node {
  """Reads and enables pagination through a set of `Airport`."""
  airports(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): AirportsConnection!

  """Reads and enables pagination through a set of `Airport`."""
  airportsList(
    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [Airport!]!

  """When this item was archived"""
  archivedAt: Datetime
  averageTemperature: JSON
  colloquial: String

  """Reads a single `Continent` that is related to this `Country`."""
  continent: Continent
  continentId: UUID

  """When this item was created"""
  createdAt: Datetime

  """Reads and enables pagination through a set of `CurrencyCountry`."""
  currencies(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CurrencyCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyCountriesConnection!

  """Reads and enables pagination through a set of `CurrencyCountry`."""
  currenciesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CurrencyCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!]
  ): [CurrencyCountry!]!
  id: UUID!

  """Reads a single `Asset` that is related to this `Country`."""
  image: Asset
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String

  """Reads and enables pagination through a set of `LanguageCountry`."""
  languages(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LanguageCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguageCountriesConnection!

  """Reads and enables pagination through a set of `LanguageCountry`."""
  languagesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LanguageCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!]
  ): [LanguageCountry!]!
  location: Location
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `Organisation`."""
  organisations(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsConnection!

  """Reads and enables pagination through a set of `Organisation`."""
  organisationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!]
  ): [Organisation!]!

  """Reads and enables pagination through a set of `OutletCountry`."""
  outlets(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutletCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutletCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletCountriesConnection!

  """Reads and enables pagination through a set of `OutletCountry`."""
  outletsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutletCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutletCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!]
  ): [OutletCountry!]!

  """Reads and enables pagination through a set of `Region`."""
  regions(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsConnection!

  """Reads and enables pagination through a set of `Region`."""
  regionsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!]
  ): [Region!]!

  """When this item was restored"""
  restoredAt: Datetime
  slug: String
  synonyms: String
  timezones(timestamp: Datetime, tripId: UUID): TimezonesConnection!
  timezonesList(timestamp: Datetime, tripId: UUID): [Timezone]!

  """Reads and enables pagination through a set of `TripCountry`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripCountriesConnection!

  """Reads and enables pagination through a set of `TripCountry`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!]
  ): [TripCountry!]!

  """When this item was updated"""
  updatedAt: Datetime

  """Reads and enables pagination through a set of `User`."""
  users(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersConnection!

  """Reads and enables pagination through a set of `User`."""
  usersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
  ): [User!]!
  voltage: String
}

"""
A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CountryCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `averageTemperature` field."""
  averageTemperature: JSON

  """Checks for equality with the object’s `colloquial` field."""
  colloquial: String

  """Checks for equality with the object’s `continentId` field."""
  continentId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `iso` field."""
  iso: String

  """Checks for equality with the object’s `iso3` field."""
  iso3: String

  """Checks for equality with the object’s `location` field."""
  location: LocationInput

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `synonyms` field."""
  synonyms: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `voltage` field."""
  voltage: String
}

"""The `continent` to be created by this mutation."""
input CountryContinentIdFkeyContinentCreateInput {
  countries: CountryContinentIdFkeyInverseInput
  id: UUID
  name: String
}

"""The `country` to be created by this mutation."""
input CountryContinentIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `continent` in the `CountryInput` mutation.
"""
input CountryContinentIdFkeyInput {
  """
  The primary key(s) for `continent` for the far side of the relationship.
  """
  connectById: ContinentContinentPkeyConnect

  """
  The primary key(s) for `continent` for the far side of the relationship.
  """
  connectByName: ContinentContinentNameKeyConnect

  """
  The primary key(s) for `continent` for the far side of the relationship.
  """
  connectByNodeId: ContinentNodeIdConnect

  """
  A `ContinentInput` object that will be created and connected to this object.
  """
  create: CountryContinentIdFkeyContinentCreateInput

  """
  The primary key(s) for `continent` for the far side of the relationship.
  """
  deleteById: ContinentContinentPkeyDelete

  """
  The primary key(s) for `continent` for the far side of the relationship.
  """
  deleteByName: ContinentContinentNameKeyDelete

  """
  The primary key(s) for `continent` for the far side of the relationship.
  """
  deleteByNodeId: ContinentNodeIdDelete

  """
  The primary key(s) and patch data for `continent` for the far side of the relationship.
  """
  updateById: ContinentOnCountryForCountryContinentIdFkeyUsingContinentPkeyUpdate

  """
  The primary key(s) and patch data for `continent` for the far side of the relationship.
  """
  updateByName: ContinentOnCountryForCountryContinentIdFkeyUsingContinentNameKeyUpdate

  """
  The primary key(s) and patch data for `continent` for the far side of the relationship.
  """
  updateByNodeId: CountryOnCountryForCountryContinentIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `country` in the `ContinentInput` mutation.
"""
input CountryContinentIdFkeyInverseInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: [CountryCountryPkeyConnect!]

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: [CountryCountryNameKeyConnect!]

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: [CountryNodeIdConnect!]

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: [CountryCountrySlugKeyConnect!]

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: [CountryContinentIdFkeyCountryCreateInput!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: [CountryCountryPkeyDelete!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: [CountryCountryNameKeyDelete!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: [CountryNodeIdDelete!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: [CountryCountrySlugKeyDelete!]

  """
  Flag indicating whether all other `country` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: [CountryOnCountryForCountryContinentIdFkeyUsingCountryPkeyUpdate!]

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: [CountryOnCountryForCountryContinentIdFkeyUsingCountryNameKeyUpdate!]

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: [ContinentOnCountryForCountryContinentIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: [CountryOnCountryForCountryContinentIdFkeyUsingCountrySlugKeyUpdate!]
}

"""The fields on `country` to look up the row to connect."""
input CountryCountryNameKeyConnect {
  name: String!
}

"""The fields on `country` to look up the row to delete."""
input CountryCountryNameKeyDelete {
  name: String!
}

"""The fields on `country` to look up the row to connect."""
input CountryCountryPkeyConnect {
  id: UUID!
}

"""The fields on `country` to look up the row to delete."""
input CountryCountryPkeyDelete {
  id: UUID!
}

"""The fields on `country` to look up the row to connect."""
input CountryCountrySlugKeyConnect {
  slug: String!
}

"""The fields on `country` to look up the row to delete."""
input CountryCountrySlugKeyDelete {
  slug: String!
}

"""
A filter to be used against `Country` object types. All fields are combined with a logical ‘and.’
"""
input CountryFilter {
  """Checks for all expressions in this list."""
  and: [CountryFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `averageTemperature` field."""
  averageTemperature: JSONFilter

  """Filter by the object’s `colloquial` field."""
  colloquial: StringFilter

  """Filter by the object’s `continent` relation."""
  continent: ContinentFilter

  """A related `continent` exists."""
  continentExists: Boolean

  """Filter by the object’s `continentId` field."""
  continentId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `currencies` relation."""
  currencies: CountryToManyCurrencyCountryFilter

  """Some related `currencies` exist."""
  currenciesExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `image` relation."""
  image: AssetFilter

  """A related `image` exists."""
  imageExists: Boolean

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `iso` field."""
  iso: StringFilter

  """Filter by the object’s `iso3` field."""
  iso3: StringFilter

  """Filter by the object’s `languages` relation."""
  languages: CountryToManyLanguageCountryFilter

  """Some related `languages` exist."""
  languagesExist: Boolean

  """Filter by the object’s `location` field."""
  location: LocationFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CountryFilter

  """Checks for any expressions in this list."""
  or: [CountryFilter!]

  """Filter by the object’s `organisations` relation."""
  organisations: CountryToManyOrganisationFilter

  """Some related `organisations` exist."""
  organisationsExist: Boolean

  """Filter by the object’s `outlets` relation."""
  outlets: CountryToManyOutletCountryFilter

  """Some related `outlets` exist."""
  outletsExist: Boolean

  """Filter by the object’s `regions` relation."""
  regions: CountryToManyRegionFilter

  """Some related `regions` exist."""
  regionsExist: Boolean

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `slug` field."""
  slug: StringFilter

  """Filter by the object’s `synonyms` field."""
  synonyms: StringFilter

  """Filter by the object’s `trips` relation."""
  trips: CountryToManyTripCountryFilter

  """Some related `trips` exist."""
  tripsExist: Boolean

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `users` relation."""
  users: CountryToManyUserFilter

  """Some related `users` exist."""
  usersExist: Boolean

  """Filter by the object’s `voltage` field."""
  voltage: StringFilter
}

"""The `asset` to be created by this mutation."""
input CountryImageIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""The `country` to be created by this mutation."""
input CountryImageIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `asset` in the `CountryInput` mutation.
"""
input CountryImageIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: CountryImageIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnCountryForCountryImageIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: CountryOnCountryForCountryImageIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `country` in the `AssetInput` mutation.
"""
input CountryImageIdFkeyInverseInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: [CountryCountryPkeyConnect!]

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: [CountryCountryNameKeyConnect!]

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: [CountryNodeIdConnect!]

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: [CountryCountrySlugKeyConnect!]

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: [CountryImageIdFkeyCountryCreateInput!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: [CountryCountryPkeyDelete!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: [CountryCountryNameKeyDelete!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: [CountryNodeIdDelete!]

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: [CountryCountrySlugKeyDelete!]

  """
  Flag indicating whether all other `country` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: [CountryOnCountryForCountryImageIdFkeyUsingCountryPkeyUpdate!]

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: [CountryOnCountryForCountryImageIdFkeyUsingCountryNameKeyUpdate!]

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnCountryForCountryImageIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: [CountryOnCountryForCountryImageIdFkeyUsingCountrySlugKeyUpdate!]
}

"""An input for mutations affecting `Country`"""
input CountryInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""The globally unique `ID` look up for the row to connect."""
input CountryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input CountryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `country` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnAirportForAirportCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `airport` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `airport` being updated.
  """
  patch: AirportPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnAirportForAirportCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnAirportForAirportCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnAirportForAirportCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnAirportForAirportCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnAirportForAirportCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnAirportForAirportCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnCountryForCountryContinentIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `continent` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `continent` being updated.
  """
  patch: ContinentPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCountryForCountryContinentIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCountryForCountryContinentIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCountryForCountryContinentIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCountryForCountryContinentIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCountryForCountryContinentIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCountryForCountryContinentIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnCountryForCountryImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCountryForCountryImageIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCountryForCountryImageIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCountryForCountryImageIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCountryForCountryImageIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCountryForCountryImageIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCountryForCountryImageIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currencyCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currencyCountry` being updated.
  """
  patch: CurrencyCountryPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnLanguageCountryForLanguageCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `languageCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `languageCountry` being updated.
  """
  patch: LanguageCountryPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnLanguageCountryForLanguageCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnLanguageCountryForLanguageCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnLanguageCountryForLanguageCountryCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnOrganisationForOrganisationCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnOrganisationForOrganisationCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnOrganisationForOrganisationCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnOrganisationForOrganisationCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnOrganisationForOrganisationCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnOrganisationForOrganisationCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnOrganisationForOrganisationCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnOutletCountryForOutletCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `outletCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `outletCountry` being updated.
  """
  patch: OutletCountryPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnOutletCountryForOutletCountryCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnOutletCountryForOutletCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnOutletCountryForOutletCountryCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnOutletCountryForOutletCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnOutletCountryForOutletCountryCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnOutletCountryForOutletCountryCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnRegionForRegionCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `region` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: RegionPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnRegionForRegionCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnRegionForRegionCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnRegionForRegionCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnRegionForRegionCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnRegionForRegionCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnRegionForRegionCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnTripCountryForTripCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tripCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tripCountry` being updated.
  """
  patch: TripCountryPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnTripCountryForTripCountryCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnTripCountryForTripCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnTripCountryForTripCountryCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnTripCountryForTripCountryCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnTripCountryForTripCountryCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnTripCountryForTripCountryCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input CountryOnUserForUserCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnUserForUserCountryIdFkeyUsingCountryNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnUserForUserCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnUserForUserCountryIdFkeyUsingCountryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnUserForUserCountryIdFkeyPatch!
}

"""The fields on `country` to look up the row to update."""
input CountryOnUserForUserCountryIdFkeyUsingCountrySlugKeyUpdate {
  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: updateCountryOnUserForUserCountryIdFkeyPatch!
  slug: String!
}

"""
Represents an update to a `Country`. Fields that are set will be updated.
"""
input CountryPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
A filter to be used against many `CurrencyCountry` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyCurrencyCountryFilter {
  """
  Every related `CurrencyCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CurrencyCountryFilter

  """
  No related `CurrencyCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CurrencyCountryFilter

  """
  Some related `CurrencyCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CurrencyCountryFilter
}

"""
A filter to be used against many `LanguageCountry` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyLanguageCountryFilter {
  """
  Every related `LanguageCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: LanguageCountryFilter

  """
  No related `LanguageCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: LanguageCountryFilter

  """
  Some related `LanguageCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: LanguageCountryFilter
}

"""
A filter to be used against many `Organisation` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyOrganisationFilter {
  """
  Every related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationFilter

  """
  No related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationFilter

  """
  Some related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationFilter
}

"""
A filter to be used against many `OutletCountry` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyOutletCountryFilter {
  """
  Every related `OutletCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OutletCountryFilter

  """
  No related `OutletCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OutletCountryFilter

  """
  Some related `OutletCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OutletCountryFilter
}

"""
A filter to be used against many `Region` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyRegionFilter {
  """
  Every related `Region` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: RegionFilter

  """
  No related `Region` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: RegionFilter

  """
  Some related `Region` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: RegionFilter
}

"""
A filter to be used against many `TripCountry` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyTripCountryFilter {
  """
  Every related `TripCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripCountryFilter

  """
  No related `TripCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripCountryFilter

  """
  Some related `TripCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripCountryFilter
}

"""
A filter to be used against many `User` object types. All fields are combined with a logical ‘and.’
"""
input CountryToManyUserFilter {
  """
  Every related `User` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: UserFilter

  """
  No related `User` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: UserFilter

  """
  Some related `User` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: UserFilter
}

type CountryTripCount {
  archivedAt: Datetime
  averageTemperature: JSON
  colloquial: String
  continentId: UUID
  count: BigInt
  createdAt: Datetime
  id: UUID
  imageId: UUID
  isArchived: Boolean
  iso: String
  iso3: String
  location: Location
  name: String
  restoredAt: Datetime
  slug: String
  synonyms: String
  updatedAt: Datetime
  voltage: String
}

"""
A condition to be used against `CountryTripCount` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CountryTripCountCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `averageTemperature` field."""
  averageTemperature: JSON

  """Checks for equality with the object’s `colloquial` field."""
  colloquial: String

  """Checks for equality with the object’s `continentId` field."""
  continentId: UUID

  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `iso` field."""
  iso: String

  """Checks for equality with the object’s `iso3` field."""
  iso3: String

  """Checks for equality with the object’s `location` field."""
  location: LocationInput

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `synonyms` field."""
  synonyms: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `voltage` field."""
  voltage: String
}

"""
A filter to be used against `CountryTripCount` object types. All fields are combined with a logical ‘and.’
"""
input CountryTripCountFilter {
  """Checks for all expressions in this list."""
  and: [CountryTripCountFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `averageTemperature` field."""
  averageTemperature: JSONFilter

  """Filter by the object’s `colloquial` field."""
  colloquial: StringFilter

  """Filter by the object’s `continentId` field."""
  continentId: UUIDFilter

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `iso` field."""
  iso: StringFilter

  """Filter by the object’s `iso3` field."""
  iso3: StringFilter

  """Filter by the object’s `location` field."""
  location: LocationFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CountryTripCountFilter

  """Checks for any expressions in this list."""
  or: [CountryTripCountFilter!]

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `slug` field."""
  slug: StringFilter

  """Filter by the object’s `synonyms` field."""
  synonyms: StringFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `voltage` field."""
  voltage: StringFilter
}

"""A connection to a list of `CountryTripCount` values."""
type CountryTripCountsConnection {
  """
  A list of edges which contains the `CountryTripCount` and cursor to aid in pagination.
  """
  edges: [CountryTripCountsEdge!]!

  """A list of `CountryTripCount` objects."""
  nodes: [CountryTripCount!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CountryTripCount` you could get from the connection.
  """
  totalCount: Int!
}

"""A `CountryTripCount` edge in the connection."""
type CountryTripCountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CountryTripCount` at the end of the edge."""
  node: CountryTripCount!
}

"""Methods to use when ordering `CountryTripCount`."""
enum CountryTripCountsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  AVERAGE_TEMPERATURE_ASC
  AVERAGE_TEMPERATURE_DESC
  COLLOQUIAL_ASC
  COLLOQUIAL_DESC
  CONTINENT_ID_ASC
  CONTINENT_ID_DESC
  COUNT_ASC
  COUNT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  ISO3_ASC
  ISO3_DESC
  ISO_ASC
  ISO_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  LOCATION_ASC
  LOCATION_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SLUG_ASC
  SLUG_DESC
  SYNONYMS_ASC
  SYNONYMS_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VOLTAGE_ASC
  VOLTAGE_DESC
}

"""All input for the `createAgentTrip` mutation."""
input CreateAgentTripInput {
  clientId: UUID!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryIds: [UUID]
  days: Int
  fromTemplate: Boolean!
  name: String!
  regionIds: [UUID]
  templateId: UUID
}

"""The output of our `createAgentTrip` mutation."""
type CreateAgentTripPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  uuid: UUID
}

"""All input for the create `Asset` mutation."""
input CreateAssetInput {
  """The `Asset` to be created by this mutation."""
  asset: AssetInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Asset` mutation."""
type CreateAssetPayload {
  """The `Asset` that was created by this mutation."""
  asset: Asset

  """An edge for our `Asset`. May be used by Relay 1."""
  assetEdge(
    """The method to use when ordering `Asset`."""
    orderBy: [AssetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssetsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `User` that is related to this `Asset`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Attachment` mutation."""
input CreateAttachmentInput {
  """The `Attachment` to be created by this mutation."""
  attachment: AttachmentInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Attachment` mutation."""
type CreateAttachmentPayload {
  """The `Attachment` that was created by this mutation."""
  attachment: Attachment

  """An edge for our `Attachment`. May be used by Relay 1."""
  attachmentEdge(
    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttachmentsEdge

  """Reads a single `Card` that is related to this `Attachment`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `User` that is related to this `Attachment`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Attachment`."""
  trip: Trip
}

"""All input for the create `CardCost` mutation."""
input CreateCardCostInput {
  """The `CardCost` to be created by this mutation."""
  cardCost: CardCostInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `CardCost` mutation."""
type CreateCardCostPayload {
  """Reads a single `Card` that is related to this `CardCost`."""
  card: Card

  """The `CardCost` that was created by this mutation."""
  cardCost: CardCost

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `CostTax` that is related to this `CardCost`."""
  costTaxByCostTax: CostTax

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Card` mutation."""
input CreateCardInput {
  """The `Card` to be created by this mutation."""
  card: CardInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our create `Card` mutation."""
type CreateCardPayload {
  """The `Card` that was created by this mutation."""
  card: Card

  """An edge for our `Card`. May be used by Relay 1."""
  cardEdge(
    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Card`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Card`."""
  image: Asset

  """Reads a single `User` that is related to this `Card`."""
  owner: User

  """Reads a single `Card` that is related to this `Card`."""
  parent: Card

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Card`."""
  trip: Trip
}

"""All input for the create `Client` mutation."""
input CreateClientInput {
  """The `Client` to be created by this mutation."""
  client: ClientInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""All input for the create `ClientOrganisationContact` mutation."""
input CreateClientOrganisationContactInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ClientOrganisationContact` to be created by this mutation."""
  clientOrganisationContact: ClientOrganisationContactInput!
}

"""The output of our create `ClientOrganisationContact` mutation."""
type CreateClientOrganisationContactPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientOrganisationContact` that was created by this mutation."""
  clientOrganisationContact: ClientOrganisationContact

  """An edge for our `ClientOrganisationContact`. May be used by Relay 1."""
  clientOrganisationContactEdge(
    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationContactsEdge

  """
  Reads a single `ClientOrganisation` that is related to this `ClientOrganisationContact`.
  """
  organisation: ClientOrganisation

  """
  Reads a single `ClientPerson` that is related to this `ClientOrganisationContact`.
  """
  person: ClientPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `ClientOrganisation` mutation."""
input CreateClientOrganisationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ClientOrganisation` to be created by this mutation."""
  clientOrganisation: ClientOrganisationInput!
}

"""The output of our create `ClientOrganisation` mutation."""
type CreateClientOrganisationPayload {
  """Reads a single `Client` that is related to this `ClientOrganisation`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientOrganisation` that was created by this mutation."""
  clientOrganisation: ClientOrganisation

  """An edge for our `ClientOrganisation`. May be used by Relay 1."""
  clientOrganisationEdge(
    """The method to use when ordering `ClientOrganisation`."""
    orderBy: [ClientOrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""The output of our create `Client` mutation."""
type CreateClientPayload {
  """Reads a single `User` that is related to this `Client`."""
  author: User

  """The `Client` that was created by this mutation."""
  client: Client

  """An edge for our `Client`. May be used by Relay 1."""
  clientEdge(
    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Organisation` that is related to this `Client`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `ClientPerson` mutation."""
input CreateClientPersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ClientPerson` to be created by this mutation."""
  clientPerson: ClientPersonInput!
}

"""The output of our create `ClientPerson` mutation."""
type CreateClientPersonPayload {
  """Reads a single `Client` that is related to this `ClientPerson`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientPerson` that was created by this mutation."""
  clientPerson: ClientPerson

  """An edge for our `ClientPerson`. May be used by Relay 1."""
  clientPersonEdge(
    """The method to use when ordering `ClientPerson`."""
    orderBy: [ClientPeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientPeopleEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ClientPerson`."""
  user: User
}

"""All input for the create `Continent` mutation."""
input CreateContinentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Continent` to be created by this mutation."""
  continent: ContinentInput!
}

"""The output of our create `Continent` mutation."""
type CreateContinentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Continent` that was created by this mutation."""
  continent: Continent

  """An edge for our `Continent`. May be used by Relay 1."""
  continentEdge(
    """The method to use when ordering `Continent`."""
    orderBy: [ContinentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContinentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `CostItem` mutation."""
input CreateCostItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CostItem` to be created by this mutation."""
  costItem: CostItemInput!
}

"""The output of our create `CostItem` mutation."""
type CreateCostItemPayload {
  """Reads a single `Card` that is related to this `CostItem`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `CostItem`."""
  costCurrency: Currency

  """The `CostItem` that was created by this mutation."""
  costItem: CostItem

  """An edge for our `CostItem`. May be used by Relay 1."""
  costItemEdge(
    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsEdge

  """Reads a single `CostTax` that is related to this `CostItem`."""
  costTax: CostTax

  """Reads a single `Organisation` that is related to this `CostItem`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `CostTax` mutation."""
input CreateCostTaxInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CostTax` to be created by this mutation."""
  costTax: CostTaxInput!
}

"""The output of our create `CostTax` mutation."""
type CreateCostTaxPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CostTax` that was created by this mutation."""
  costTax: CostTax

  """An edge for our `CostTax`. May be used by Relay 1."""
  costTaxEdge(
    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostTaxesEdge

  """Reads a single `Organisation` that is related to this `CostTax`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Country` mutation."""
input CreateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Country` to be created by this mutation."""
  country: CountryInput!
}

"""The output of our create `Country` mutation."""
type CreateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Continent` that is related to this `Country`."""
  continent: Continent

  """The `Country` that was created by this mutation."""
  country: Country

  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge

  """Reads a single `Asset` that is related to this `Country`."""
  image: Asset

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `CurrencyCountry` mutation."""
input CreateCurrencyCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CurrencyCountry` to be created by this mutation."""
  currencyCountry: CurrencyCountryInput!
}

"""The output of our create `CurrencyCountry` mutation."""
type CreateCurrencyCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `CurrencyCountry`."""
  country: Country

  """Reads a single `Currency` that is related to this `CurrencyCountry`."""
  currency: Currency

  """The `CurrencyCountry` that was created by this mutation."""
  currencyCountry: CurrencyCountry

  """An edge for our `CurrencyCountry`. May be used by Relay 1."""
  currencyCountryEdge(
    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Currency` mutation."""
input CreateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Currency` to be created by this mutation."""
  currency: CurrencyInput!
}

"""The output of our create `Currency` mutation."""
type CreateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was created by this mutation."""
  currency: Currency

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Grati` mutation."""
input CreateGratiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Grati` to be created by this mutation."""
  grati: GratiInput!
}

"""The output of our create `Grati` mutation."""
type CreateGratiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Grati` that was created by this mutation."""
  grati: Grati @deprecated(reason: "Use Promo Codes")

  """An edge for our `Grati`. May be used by Relay 1."""
  gratiEdge(
    """The method to use when ordering `Grati`."""
    orderBy: [GratisOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisEdge @deprecated(reason: "Use Promo Codes")

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `GratisUsed` mutation."""
input CreateGratisUsedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `GratisUsed` to be created by this mutation."""
  gratisUsed: GratisUsedInput!
}

"""The output of our create `GratisUsed` mutation."""
type CreateGratisUsedPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Grati` that is related to this `GratisUsed`."""
  gratis: Grati

  """The `GratisUsed` that was created by this mutation."""
  gratisUsed: GratisUsed

  """An edge for our `GratisUsed`. May be used by Relay 1."""
  gratisUsedEdge(
    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisUsedsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `GratisUsed`."""
  user: User
}

input CreateInviteInput {
  clientMutationId: String
  invite: InviteInput!
}

type CreateInvitePayload {
  clientMutationId: String
}

"""All input for the create `LanguageCountry` mutation."""
input CreateLanguageCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `LanguageCountry` to be created by this mutation."""
  languageCountry: LanguageCountryInput!
}

"""The output of our create `LanguageCountry` mutation."""
type CreateLanguageCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `LanguageCountry`."""
  country: Country

  """Reads a single `Language` that is related to this `LanguageCountry`."""
  language: Language

  """The `LanguageCountry` that was created by this mutation."""
  languageCountry: LanguageCountry

  """An edge for our `LanguageCountry`. May be used by Relay 1."""
  languageCountryEdge(
    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguageCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Language` mutation."""
input CreateLanguageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Language` to be created by this mutation."""
  language: LanguageInput!
}

"""The output of our create `Language` mutation."""
type CreateLanguagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Language` that was created by this mutation."""
  language: Language

  """An edge for our `Language`. May be used by Relay 1."""
  languageEdge(
    """The method to use when ordering `Language`."""
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Meta` mutation."""
input CreateMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Meta` to be created by this mutation."""
  meta: MetaInput!
}

"""The output of our create `Meta` mutation."""
type CreateMetaPayload {
  """Reads a single `User` that is related to this `Meta`."""
  author: User

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `ClientOrganisation` that is related to this `Meta`."""
  clientOrganisation: ClientOrganisation

  """Reads a single `ClientPerson` that is related to this `Meta`."""
  clientPerson: ClientPerson

  """The `Meta` that was created by this mutation."""
  meta: Meta

  """An edge for our `Meta`. May be used by Relay 1."""
  metaEdge(
    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasEdge

  """Reads a single `Organisation` that is related to this `Meta`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Supplier` that is related to this `Meta`."""
  supplier: Supplier
}

"""All input for the `createOrganisation` mutation."""
input CreateOrganisationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the create `OrganisationInvite` mutation."""
input CreateOrganisationInviteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OrganisationInvite` to be created by this mutation."""
  organisationInvite: OrganisationInviteInput!
}

"""The output of our create `OrganisationInvite` mutation."""
type CreateOrganisationInvitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Organisation` that is related to this `OrganisationInvite`.
  """
  organisation: Organisation

  """The `OrganisationInvite` that was created by this mutation."""
  organisationInvite: OrganisationInvite

  """An edge for our `OrganisationInvite`. May be used by Relay 1."""
  organisationInviteEdge(
    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationInvitesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OrganisationInvite`."""
  user: User
}

"""The output of our `createOrganisation` mutation."""
type CreateOrganisationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `CostTax` that is related to this `Organisation`."""
  costTax: CostTax

  """Reads a single `Country` that is related to this `Organisation`."""
  country: Country

  """Reads a single `Currency` that is related to this `Organisation`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Organisation`."""
  logo: Asset
  organisation: Organisation

  """An edge for our `Organisation`. May be used by Relay 1."""
  organisationEdge(
    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `OrganisationTier` mutation."""
input CreateOrganisationTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OrganisationTier` to be created by this mutation."""
  organisationTier: OrganisationTierInput!
}

"""The output of our create `OrganisationTier` mutation."""
type CreateOrganisationTierPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OrganisationTier` that was created by this mutation."""
  organisationTier: OrganisationTier

  """An edge for our `OrganisationTier`. May be used by Relay 1."""
  organisationTierEdge(
    """The method to use when ordering `OrganisationTier`."""
    orderBy: [OrganisationTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationTiersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `OrganisationUser` mutation."""
input CreateOrganisationUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OrganisationUser` to be created by this mutation."""
  organisationUser: OrganisationUserInput!
}

"""The output of our create `OrganisationUser` mutation."""
type CreateOrganisationUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Organisation` that is related to this `OrganisationUser`.
  """
  organisation: Organisation

  """The `OrganisationUser` that was created by this mutation."""
  organisationUser: OrganisationUser

  """An edge for our `OrganisationUser`. May be used by Relay 1."""
  organisationUserEdge(
    """The method to use when ordering `OrganisationUser`."""
    orderBy: [OrganisationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationUsersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OrganisationUser`."""
  user: User
}

"""All input for the create `OutletCountry` mutation."""
input CreateOutletCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `OutletCountry` to be created by this mutation."""
  outletCountry: OutletCountryInput!
}

"""The output of our create `OutletCountry` mutation."""
type CreateOutletCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `OutletCountry`."""
  country: Country

  """Reads a single `Outlet` that is related to this `OutletCountry`."""
  outlet: Outlet

  """The `OutletCountry` that was created by this mutation."""
  outletCountry: OutletCountry

  """An edge for our `OutletCountry`. May be used by Relay 1."""
  outletCountryEdge(
    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Outlet` mutation."""
input CreateOutletInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Outlet` to be created by this mutation."""
  outlet: OutletInput!
}

"""The output of our create `Outlet` mutation."""
type CreateOutletPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Outlet` that was created by this mutation."""
  outlet: Outlet

  """An edge for our `Outlet`. May be used by Relay 1."""
  outletEdge(
    """The method to use when ordering `Outlet`."""
    orderBy: [OutletsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `PartnerPage` mutation."""
input CreatePartnerPageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PartnerPage` to be created by this mutation."""
  partnerPage: PartnerPageInput!
}

"""The output of our create `PartnerPage` mutation."""
type CreatePartnerPagePayload {
  """Reads a single `Asset` that is related to this `PartnerPage`."""
  background: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Grati` that is related to this `PartnerPage`."""
  gratis: Grati

  """Reads a single `Asset` that is related to this `PartnerPage`."""
  logo: Asset

  """The `PartnerPage` that was created by this mutation."""
  partnerPage: PartnerPage

  """An edge for our `PartnerPage`. May be used by Relay 1."""
  partnerPageEdge(
    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesEdge

  """Reads a single `PromoCode` that is related to this `PartnerPage`."""
  promoCode: PromoCode

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `createPastTrip` mutation."""
input CreatePastTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryIds: [UUID]!
  days: Int!
  startDate: Datetime!
}

"""The output of our `createPastTrip` mutation."""
type CreatePastTripPayload {
  """Reads a single `Client` that is related to this `Trip`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation

  """Reads a single `User` that is related to this `Trip`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip
  trip: Trip

  """An edge for our `Trip`. May be used by Relay 1."""
  tripEdge(
    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsEdge
}

"""All input for the create `Place` mutation."""
input CreatePlaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Place` to be created by this mutation."""
  place: PlaceInput!
}

"""The output of our create `Place` mutation."""
type CreatePlacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Place` that was created by this mutation."""
  place: Place

  """An edge for our `Place`. May be used by Relay 1."""
  placeEdge(
    """The method to use when ordering `Place`."""
    orderBy: [PlacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlacesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `PromoCodeAffiliate` mutation."""
input CreatePromoCodeAffiliateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PromoCodeAffiliate` to be created by this mutation."""
  promoCodeAffiliate: PromoCodeAffiliateInput!
}

"""The output of our create `PromoCodeAffiliate` mutation."""
type CreatePromoCodeAffiliatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `PromoCode` that is related to this `PromoCodeAffiliate`.
  """
  promoCode: PromoCode

  """The `PromoCodeAffiliate` that was created by this mutation."""
  promoCodeAffiliate: PromoCodeAffiliate

  """An edge for our `PromoCodeAffiliate`. May be used by Relay 1."""
  promoCodeAffiliateEdge(
    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeAffiliatesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `PromoCodeAffiliate`."""
  user: User
}

"""All input for the create `PromoCode` mutation."""
input CreatePromoCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PromoCode` to be created by this mutation."""
  promoCode: PromoCodeInput!
}

"""The output of our create `PromoCode` mutation."""
type CreatePromoCodePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PromoCode` that was created by this mutation."""
  promoCode: PromoCode

  """An edge for our `PromoCode`. May be used by Relay 1."""
  promoCodeEdge(
    """The method to use when ordering `PromoCode`."""
    orderBy: [PromoCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the create `Region` mutation."""
input CreateRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Region` to be created by this mutation."""
  region: RegionInput!
}

"""The output of our create `Region` mutation."""
type CreateRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `Region`."""
  country: Country

  """Reads a single `Asset` that is related to this `Region`."""
  image: Asset

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Region` that was created by this mutation."""
  region: Region

  """An edge for our `Region`. May be used by Relay 1."""
  regionEdge(
    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsEdge
}

"""All input for the create `Setting` mutation."""
input CreateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Setting` to be created by this mutation."""
  setting: SettingInput!
}

"""The output of our create `Setting` mutation."""
type CreateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Setting` that was created by this mutation."""
  setting: Setting @deprecated(reason: "Use Trip.appearance")

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge @deprecated(reason: "Use Trip.appearance")

  """Reads a single `User` that is related to this `Setting`."""
  user: User
}

"""All input for the create `SubscriptionLog` mutation."""
input CreateSubscriptionLogInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `SubscriptionLog` to be created by this mutation."""
  subscriptionLog: SubscriptionLogInput!
}

"""The output of our create `SubscriptionLog` mutation."""
type CreateSubscriptionLogPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `SubscriptionLog` that was created by this mutation."""
  subscriptionLog: SubscriptionLog

  """An edge for our `SubscriptionLog`. May be used by Relay 1."""
  subscriptionLogEdge(
    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionLogsEdge

  """Reads a single `User` that is related to this `SubscriptionLog`."""
  user: User
}

"""All input for the create `SupplierCategory` mutation."""
input CreateSupplierCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `SupplierCategory` to be created by this mutation."""
  supplierCategory: SupplierCategoryInput!
}

"""The output of our create `SupplierCategory` mutation."""
type CreateSupplierCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `SupplierCategory` that was created by this mutation."""
  supplierCategory: SupplierCategory

  """An edge for our `SupplierCategory`. May be used by Relay 1."""
  supplierCategoryEdge(
    """The method to use when ordering `SupplierCategory`."""
    orderBy: [SupplierCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierCategoriesEdge
}

"""All input for the create `Supplier` mutation."""
input CreateSupplierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Supplier` to be created by this mutation."""
  supplier: SupplierInput!
}

"""The output of our create `Supplier` mutation."""
type CreateSupplierPayload {
  """Reads a single `User` that is related to this `Supplier`."""
  author: User

  """Reads a single `SupplierCategory` that is related to this `Supplier`."""
  category: SupplierCategory

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Asset` that is related to this `Supplier`."""
  logo: Asset

  """Reads a single `Organisation` that is related to this `Supplier`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Supplier` that was created by this mutation."""
  supplier: Supplier

  """An edge for our `Supplier`. May be used by Relay 1."""
  supplierEdge(
    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersEdge
}

"""All input for the create `SupplierTag` mutation."""
input CreateSupplierTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `SupplierTag` to be created by this mutation."""
  supplierTag: SupplierTagInput!
}

"""The output of our create `SupplierTag` mutation."""
type CreateSupplierTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Supplier` that is related to this `SupplierTag`."""
  supplier: Supplier

  """The `SupplierTag` that was created by this mutation."""
  supplierTag: SupplierTag

  """An edge for our `SupplierTag`. May be used by Relay 1."""
  supplierTagEdge(
    """The method to use when ordering `SupplierTag`."""
    orderBy: [SupplierTagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierTagsEdge

  """Reads a single `Tag` that is related to this `SupplierTag`."""
  tag: Tag
}

"""All input for the create `Tag` mutation."""
input CreateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Tag` to be created by this mutation."""
  tag: TagInput!
}

"""The output of our create `Tag` mutation."""
type CreateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Organisation` that is related to this `Tag`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Tag` that was created by this mutation."""
  tag: Tag

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the create `TagTrip` mutation."""
input CreateTagTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TagTrip` to be created by this mutation."""
  tagTrip: TagTripInput!
}

"""The output of our create `TagTrip` mutation."""
type CreateTagTripPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Tag` that is related to this `TagTrip`."""
  tag: Tag

  """The `TagTrip` that was created by this mutation."""
  tagTrip: TagTrip

  """An edge for our `TagTrip`. May be used by Relay 1."""
  tagTripEdge(
    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagTripsEdge

  """Reads a single `Trip` that is related to this `TagTrip`."""
  trip: Trip
}

"""All input for the create `Task` mutation."""
input CreateTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Task` to be created by this mutation."""
  task: TaskInput!
}

"""The output of our create `Task` mutation."""
type CreateTaskPayload {
  """Reads a single `Card` that is related to this `Task`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Task` that was created by this mutation."""
  task: Task

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksEdge

  """Reads a single `Trip` that is related to this `Task`."""
  trip: Trip

  """Reads a single `User` that is related to this `Task`."""
  user: User
}

"""All input for the create `Template` mutation."""
input CreateTemplateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Template` to be created by this mutation."""
  template: TemplateInput!
}

"""The output of our create `Template` mutation."""
type CreateTemplatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Template` that was created by this mutation."""
  template: Template

  """An edge for our `Template`. May be used by Relay 1."""
  templateEdge(
    """The method to use when ordering `Template`."""
    orderBy: [TemplatesOrderBy!] = [NATURAL]
  ): TemplatesEdge
}

"""All input for the create `TripAssetImage` mutation."""
input CreateTripAssetImageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TripAssetImage` to be created by this mutation."""
  tripAssetImage: TripAssetImageInput!
}

"""The output of our create `TripAssetImage` mutation."""
type CreateTripAssetImagePayload {
  """Reads a single `Asset` that is related to this `TripAssetImage`."""
  asset: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `TripAssetImage`."""
  trip: Trip

  """The `TripAssetImage` that was created by this mutation."""
  tripAssetImage: TripAssetImage

  """An edge for our `TripAssetImage`. May be used by Relay 1."""
  tripAssetImageEdge(
    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripAssetImagesEdge
}

"""All input for the create `TripCountry` mutation."""
input CreateTripCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TripCountry` to be created by this mutation."""
  tripCountry: TripCountryInput!
}

"""The output of our create `TripCountry` mutation."""
type CreateTripCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `TripCountry`."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `TripCountry`."""
  trip: Trip

  """The `TripCountry` that was created by this mutation."""
  tripCountry: TripCountry

  """An edge for our `TripCountry`. May be used by Relay 1."""
  tripCountryEdge(
    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripCountriesEdge
}

"""All input for the create `Trip` mutation."""
input CreateTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Trip` to be created by this mutation."""
  trip: TripInput!
}

"""The output of our create `Trip` mutation."""
type CreateTripPayload {
  """Reads a single `Client` that is related to this `Trip`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation

  """Reads a single `User` that is related to this `Trip`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip

  """The `Trip` that was created by this mutation."""
  trip: Trip

  """An edge for our `Trip`. May be used by Relay 1."""
  tripEdge(
    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsEdge
}

"""All input for the create `TripRegion` mutation."""
input CreateTripRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `TripRegion` to be created by this mutation."""
  tripRegion: TripRegionInput!
}

"""The output of our create `TripRegion` mutation."""
type CreateTripRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Region` that is related to this `TripRegion`."""
  region: Region

  """Reads a single `Trip` that is related to this `TripRegion`."""
  trip: Trip

  """The `TripRegion` that was created by this mutation."""
  tripRegion: TripRegion

  """An edge for our `TripRegion`. May be used by Relay 1."""
  tripRegionEdge(
    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripRegionsEdge
}

"""A connection to a list of `Currency` values."""
type CurrenciesConnection {
  """
  A list of edges which contains the `Currency` and cursor to aid in pagination.
  """
  edges: [CurrenciesEdge!]!

  """A list of `Currency` objects."""
  nodes: [Currency!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Currency` you could get from the connection."""
  totalCount: Int!
}

"""A `Currency` edge in the connection."""
type CurrenciesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Currency` at the end of the edge."""
  node: Currency!
}

"""Methods to use when ordering `Currency`."""
enum CurrenciesOrderBy {
  CONVERSION_RATE_ASC
  CONVERSION_RATE_DESC
  ID_ASC
  ID_DESC
  ISO_ASC
  ISO_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Currency implements Node {
  """Reads and enables pagination through a set of `Card`."""
  cards(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsConnection!

  """Reads and enables pagination through a set of `Card`."""
  cardsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!]
  ): [Card!]!

  """Conversion rate to EUR"""
  conversionRate: Float

  """Reads and enables pagination through a set of `CostItem`."""
  costItemsByCostCurrencyId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsConnection!

  """Reads and enables pagination through a set of `CostItem`."""
  costItemsByCostCurrencyIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!]
  ): [CostItem!]!

  """Reads and enables pagination through a set of `CurrencyCountry`."""
  countries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CurrencyCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyCountriesConnection!

  """Reads and enables pagination through a set of `CurrencyCountry`."""
  countriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CurrencyCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!]
  ): [CurrencyCountry!]!
  id: UUID!
  iso: String
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `Organisation`."""
  organisations(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsConnection!

  """Reads and enables pagination through a set of `Organisation`."""
  organisationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!]
  ): [Organisation!]!

  """Reads and enables pagination through a set of `Trip`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]!
}

"""
A condition to be used against `Currency` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CurrencyCondition {
  """Checks for equality with the object’s `conversionRate` field."""
  conversionRate: Float

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `iso` field."""
  iso: String

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `CurrencyCountry` values."""
type CurrencyCountriesConnection {
  """
  A list of edges which contains the `CurrencyCountry` and cursor to aid in pagination.
  """
  edges: [CurrencyCountriesEdge!]!

  """A list of `CurrencyCountry` objects."""
  nodes: [CurrencyCountry!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `CurrencyCountry` you could get from the connection.
  """
  totalCount: Int!
}

"""A `CurrencyCountry` edge in the connection."""
type CurrencyCountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CurrencyCountry` at the end of the edge."""
  node: CurrencyCountry!
}

"""Methods to use when ordering `CurrencyCountry`."""
enum CurrencyCountriesOrderBy {
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  CURRENCY_ID_ASC
  CURRENCY_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORTING_ASC
  SORTING_DESC
}

type CurrencyCountry implements Node {
  """Reads a single `Country` that is related to this `CurrencyCountry`."""
  country: Country
  countryId: UUID!

  """Reads a single `Currency` that is related to this `CurrencyCountry`."""
  currency: Currency
  currencyId: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  sorting: Int
}

"""
A condition to be used against `CurrencyCountry` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CurrencyCountryCondition {
  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `currencyId` field."""
  currencyId: UUID

  """Checks for equality with the object’s `sorting` field."""
  sorting: Int
}

"""The `country` to be created by this mutation."""
input CurrencyCountryCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""The `currencyCountry` to be created by this mutation."""
input CurrencyCountryCountryIdFkeyCurrencyCountryCreateInput {
  country: CurrencyCountryCountryIdFkeyInput
  countryId: UUID
  currency: CurrencyCountryCurrencyIdFkeyInput
  currencyId: UUID
  sorting: Int
}

"""
Input for the nested mutation of `country` in the `CurrencyCountryInput` mutation.
"""
input CurrencyCountryCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: CurrencyCountryCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: CurrencyCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `currencyCountry` in the `CountryInput` mutation.
"""
input CurrencyCountryCountryIdFkeyInverseInput {
  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  connectByCurrencyIdAndCountryId: [CurrencyCountryCurrencyCountryPkeyConnect!]

  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  connectByNodeId: [CurrencyCountryNodeIdConnect!]

  """
  A `CurrencyCountryInput` object that will be created and connected to this object.
  """
  create: [CurrencyCountryCountryIdFkeyCurrencyCountryCreateInput!]

  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  deleteByCurrencyIdAndCountryId: [CurrencyCountryCurrencyCountryPkeyDelete!]

  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  deleteByNodeId: [CurrencyCountryNodeIdDelete!]

  """
  Flag indicating whether all other `currencyCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `currencyCountry` for the far side of the relationship.
  """
  updateByCurrencyIdAndCountryId: [CurrencyCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCurrencyCountryPkeyUpdate!]

  """
  The primary key(s) and patch data for `currencyCountry` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyNodeIdUpdate!]
}

"""The fields on `currencyCountry` to look up the row to connect."""
input CurrencyCountryCurrencyCountryPkeyConnect {
  countryId: UUID!
  currencyId: UUID!
}

"""The fields on `currencyCountry` to look up the row to delete."""
input CurrencyCountryCurrencyCountryPkeyDelete {
  countryId: UUID!
  currencyId: UUID!
}

"""The `currencyCountry` to be created by this mutation."""
input CurrencyCountryCurrencyIdFkeyCurrencyCountryCreateInput {
  country: CurrencyCountryCountryIdFkeyInput
  countryId: UUID
  currency: CurrencyCountryCurrencyIdFkeyInput
  currencyId: UUID
  sorting: Int
}

"""The `currency` to be created by this mutation."""
input CurrencyCountryCurrencyIdFkeyCurrencyCreateInput {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
Input for the nested mutation of `currency` in the `CurrencyCountryInput` mutation.
"""
input CurrencyCountryCurrencyIdFkeyInput {
  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectById: CurrencyCurrencyPkeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByIso: CurrencyCurrencyIsoKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByName: CurrencyCurrencyNameKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByNodeId: CurrencyNodeIdConnect

  """
  A `CurrencyInput` object that will be created and connected to this object.
  """
  create: CurrencyCountryCurrencyIdFkeyCurrencyCreateInput

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteById: CurrencyCurrencyPkeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByIso: CurrencyCurrencyIsoKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByName: CurrencyCurrencyNameKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByNodeId: CurrencyNodeIdDelete

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateById: CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyPkeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByIso: CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyIsoKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByName: CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyNameKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByNodeId: CurrencyCountryOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `currencyCountry` in the `CurrencyInput` mutation.
"""
input CurrencyCountryCurrencyIdFkeyInverseInput {
  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  connectByCurrencyIdAndCountryId: [CurrencyCountryCurrencyCountryPkeyConnect!]

  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  connectByNodeId: [CurrencyCountryNodeIdConnect!]

  """
  A `CurrencyCountryInput` object that will be created and connected to this object.
  """
  create: [CurrencyCountryCurrencyIdFkeyCurrencyCountryCreateInput!]

  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  deleteByCurrencyIdAndCountryId: [CurrencyCountryCurrencyCountryPkeyDelete!]

  """
  The primary key(s) for `currencyCountry` for the far side of the relationship.
  """
  deleteByNodeId: [CurrencyCountryNodeIdDelete!]

  """
  Flag indicating whether all other `currencyCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `currencyCountry` for the far side of the relationship.
  """
  updateByCurrencyIdAndCountryId: [CurrencyCountryOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyCountryPkeyUpdate!]

  """
  The primary key(s) and patch data for `currencyCountry` for the far side of the relationship.
  """
  updateByNodeId: [CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyNodeIdUpdate!]
}

"""
A filter to be used against `CurrencyCountry` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyCountryFilter {
  """Checks for all expressions in this list."""
  and: [CurrencyCountryFilter!]

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Filter by the object’s `currency` relation."""
  currency: CurrencyFilter

  """Filter by the object’s `currencyId` field."""
  currencyId: UUIDFilter

  """Negates the expression."""
  not: CurrencyCountryFilter

  """Checks for any expressions in this list."""
  or: [CurrencyCountryFilter!]

  """Filter by the object’s `sorting` field."""
  sorting: IntFilter
}

"""An input for mutations affecting `CurrencyCountry`"""
input CurrencyCountryInput {
  country: CurrencyCountryCountryIdFkeyInput
  countryId: UUID
  currency: CurrencyCountryCurrencyIdFkeyInput
  currencyId: UUID
  sorting: Int
}

"""The globally unique `ID` look up for the row to connect."""
input CurrencyCountryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `currencyCountry` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input CurrencyCountryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `currencyCountry` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `currencyCountry` to look up the row to update."""
input CurrencyCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyUsingCurrencyCountryPkeyUpdate {
  countryId: UUID!
  currencyId: UUID!

  """
  An object where the defined keys will be set on the `currencyCountry` being updated.
  """
  patch: updateCurrencyCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyCountryOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currency` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: CurrencyPatch!
}

"""The fields on `currencyCountry` to look up the row to update."""
input CurrencyCountryOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyCountryPkeyUpdate {
  countryId: UUID!
  currencyId: UUID!

  """
  An object where the defined keys will be set on the `currencyCountry` being updated.
  """
  patch: updateCurrencyCountryOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyPatch!
}

"""
Represents an update to a `CurrencyCountry`. Fields that are set will be updated.
"""
input CurrencyCountryPatch {
  country: CurrencyCountryCountryIdFkeyInput
  countryId: UUID
  currency: CurrencyCountryCurrencyIdFkeyInput
  currencyId: UUID
  sorting: Int
}

"""The fields on `currency` to look up the row to connect."""
input CurrencyCurrencyIsoKeyConnect {
  iso: String!
}

"""The fields on `currency` to look up the row to delete."""
input CurrencyCurrencyIsoKeyDelete {
  iso: String!
}

"""The fields on `currency` to look up the row to connect."""
input CurrencyCurrencyNameKeyConnect {
  name: String!
}

"""The fields on `currency` to look up the row to delete."""
input CurrencyCurrencyNameKeyDelete {
  name: String!
}

"""The fields on `currency` to look up the row to connect."""
input CurrencyCurrencyPkeyConnect {
  id: UUID!
}

"""The fields on `currency` to look up the row to delete."""
input CurrencyCurrencyPkeyDelete {
  id: UUID!
}

"""
A filter to be used against `Currency` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyFilter {
  """Checks for all expressions in this list."""
  and: [CurrencyFilter!]

  """Filter by the object’s `cards` relation."""
  cards: CurrencyToManyCardFilter

  """Some related `cards` exist."""
  cardsExist: Boolean

  """Filter by the object’s `conversionRate` field."""
  conversionRate: FloatFilter

  """Filter by the object’s `costItemsByCostCurrencyId` relation."""
  costItemsByCostCurrencyId: CurrencyToManyCostItemFilter

  """Some related `costItemsByCostCurrencyId` exist."""
  costItemsByCostCurrencyIdExist: Boolean

  """Filter by the object’s `countries` relation."""
  countries: CurrencyToManyCurrencyCountryFilter

  """Some related `countries` exist."""
  countriesExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `iso` field."""
  iso: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: CurrencyFilter

  """Checks for any expressions in this list."""
  or: [CurrencyFilter!]

  """Filter by the object’s `organisations` relation."""
  organisations: CurrencyToManyOrganisationFilter

  """Some related `organisations` exist."""
  organisationsExist: Boolean

  """Filter by the object’s `trips` relation."""
  trips: CurrencyToManyTripFilter

  """Some related `trips` exist."""
  tripsExist: Boolean
}

"""An input for mutations affecting `Currency`"""
input CurrencyInput {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to connect."""
input CurrencyNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `currency` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input CurrencyNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `currency` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyOnCardForCardCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCardForCardCurrencyIdFkeyUsingCurrencyIsoKeyUpdate {
  iso: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCardForCardCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCardForCardCurrencyIdFkeyUsingCurrencyNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCardForCardCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCardForCardCurrencyIdFkeyUsingCurrencyPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCardForCardCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyOnCostItemForCostItemCostCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: CostItemPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCostItemForCostItemCostCurrencyIdFkeyUsingCurrencyIsoKeyUpdate {
  iso: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCostItemForCostItemCostCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCostItemForCostItemCostCurrencyIdFkeyUsingCurrencyNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCostItemForCostItemCostCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCostItemForCostItemCostCurrencyIdFkeyUsingCurrencyPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCostItemForCostItemCostCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currencyCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currencyCountry` being updated.
  """
  patch: CurrencyCountryPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyIsoKeyUpdate {
  iso: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyUsingCurrencyPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyOnOrganisationForOrganisationCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnOrganisationForOrganisationCurrencyIdFkeyUsingCurrencyIsoKeyUpdate {
  iso: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnOrganisationForOrganisationCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnOrganisationForOrganisationCurrencyIdFkeyUsingCurrencyNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnOrganisationForOrganisationCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnOrganisationForOrganisationCurrencyIdFkeyUsingCurrencyPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnOrganisationForOrganisationCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input CurrencyOnTripForTripCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnTripForTripCurrencyIdFkeyUsingCurrencyIsoKeyUpdate {
  iso: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnTripForTripCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnTripForTripCurrencyIdFkeyUsingCurrencyNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnTripForTripCurrencyIdFkeyPatch!
}

"""The fields on `currency` to look up the row to update."""
input CurrencyOnTripForTripCurrencyIdFkeyUsingCurrencyPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: updateCurrencyOnTripForTripCurrencyIdFkeyPatch!
}

"""
Represents an update to a `Currency`. Fields that are set will be updated.
"""
input CurrencyPatch {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
A filter to be used against many `Card` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyToManyCardFilter {
  """
  Every related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CardFilter

  """
  No related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CardFilter

  """
  Some related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CardFilter
}

"""
A filter to be used against many `CostItem` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyToManyCostItemFilter {
  """
  Every related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CostItemFilter

  """
  No related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CostItemFilter

  """
  Some related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CostItemFilter
}

"""
A filter to be used against many `CurrencyCountry` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyToManyCurrencyCountryFilter {
  """
  Every related `CurrencyCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CurrencyCountryFilter

  """
  No related `CurrencyCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CurrencyCountryFilter

  """
  Some related `CurrencyCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CurrencyCountryFilter
}

"""
A filter to be used against many `Organisation` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyToManyOrganisationFilter {
  """
  Every related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationFilter

  """
  No related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationFilter

  """
  Some related `Organisation` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationFilter
}

"""
A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’
"""
input CurrencyToManyTripFilter {
  """
  Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripFilter

  """
  No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripFilter

  """
  Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripFilter
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""The day, does not include a time."""
scalar Date

"""
A filter to be used against Date fields. All fields are combined with a logical ‘and.’
"""
input DateFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Date

  """Equal to the specified value."""
  equalTo: Date

  """Greater than the specified value."""
  greaterThan: Date

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Date

  """Included in the specified list."""
  in: [Date!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Date

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Date

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Date

  """Not equal to the specified value."""
  notEqualTo: Date

  """Not included in the specified list."""
  notIn: [Date!]
}

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’
"""
input DatetimeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Datetime

  """Equal to the specified value."""
  equalTo: Datetime

  """Greater than the specified value."""
  greaterThan: Datetime

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Datetime

  """Included in the specified list."""
  in: [Datetime!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Datetime

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Datetime

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Datetime

  """Not equal to the specified value."""
  notEqualTo: Datetime

  """Not included in the specified list."""
  notIn: [Datetime!]
}

"""All input for the `deleteAccount` mutation."""
input DeleteAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `deleteAccount` mutation."""
type DeleteAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteAssetByNodeId` mutation."""
input DeleteAssetByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Asset` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAsset` mutation."""
input DeleteAssetInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Asset` mutation."""
type DeleteAssetPayload {
  """The `Asset` that was deleted by this mutation."""
  asset: Asset

  """An edge for our `Asset`. May be used by Relay 1."""
  assetEdge(
    """The method to use when ordering `Asset`."""
    orderBy: [AssetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssetsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAssetNodeId: ID

  """Reads a single `User` that is related to this `Asset`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteAttachmentByNodeId` mutation."""
input DeleteAttachmentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Attachment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAttachment` mutation."""
input DeleteAttachmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Attachment` mutation."""
type DeleteAttachmentPayload {
  """The `Attachment` that was deleted by this mutation."""
  attachment: Attachment

  """An edge for our `Attachment`. May be used by Relay 1."""
  attachmentEdge(
    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttachmentsEdge

  """Reads a single `Card` that is related to this `Attachment`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAttachmentNodeId: ID

  """Reads a single `User` that is related to this `Attachment`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Attachment`."""
  trip: Trip
}

"""All input for the `deleteByDay` mutation."""
input DeleteByDayInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  day: Int!
  tripId: UUID!
}

"""The output of our `deleteByDay` mutation."""
type DeleteByDayPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCardByNodeId` mutation."""
input DeleteCardByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Card` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCard` mutation."""
input DeleteCardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Card` mutation."""
type DeleteCardPayload {
  """The `Card` that was deleted by this mutation."""
  card: Card

  """An edge for our `Card`. May be used by Relay 1."""
  cardEdge(
    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Card`."""
  currency: Currency
  deletedCardNodeId: ID

  """Reads a single `Asset` that is related to this `Card`."""
  image: Asset

  """Reads a single `User` that is related to this `Card`."""
  owner: User

  """Reads a single `Card` that is related to this `Card`."""
  parent: Card

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Card`."""
  trip: Trip
}

"""All input for the `deleteClientByNodeId` mutation."""
input DeleteClientByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Client` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteClient` mutation."""
input DeleteClientInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""All input for the `deleteClientOrganisationContactByNodeId` mutation."""
input DeleteClientOrganisationContactByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ClientOrganisationContact` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteClientOrganisationContact` mutation."""
input DeleteClientOrganisationContactInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  organisationId: UUID!
  personId: UUID!
}

"""The output of our delete `ClientOrganisationContact` mutation."""
type DeleteClientOrganisationContactPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientOrganisationContact` that was deleted by this mutation."""
  clientOrganisationContact: ClientOrganisationContact

  """An edge for our `ClientOrganisationContact`. May be used by Relay 1."""
  clientOrganisationContactEdge(
    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationContactsEdge
  deletedClientOrganisationContactNodeId: ID

  """
  Reads a single `ClientOrganisation` that is related to this `ClientOrganisationContact`.
  """
  organisation: ClientOrganisation

  """
  Reads a single `ClientPerson` that is related to this `ClientOrganisationContact`.
  """
  person: ClientPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""The output of our delete `Client` mutation."""
type DeleteClientPayload {
  """Reads a single `User` that is related to this `Client`."""
  author: User

  """The `Client` that was deleted by this mutation."""
  client: Client

  """An edge for our `Client`. May be used by Relay 1."""
  clientEdge(
    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedClientNodeId: ID

  """Reads a single `Organisation` that is related to this `Client`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteContinentByName` mutation."""
input DeleteContinentByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteContinentByNodeId` mutation."""
input DeleteContinentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Continent` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteContinent` mutation."""
input DeleteContinentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Continent` mutation."""
type DeleteContinentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Continent` that was deleted by this mutation."""
  continent: Continent

  """An edge for our `Continent`. May be used by Relay 1."""
  continentEdge(
    """The method to use when ordering `Continent`."""
    orderBy: [ContinentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContinentsEdge
  deletedContinentNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCostItemByNodeId` mutation."""
input DeleteCostItemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CostItem` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCostItem` mutation."""
input DeleteCostItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `CostItem` mutation."""
type DeleteCostItemPayload {
  """Reads a single `Card` that is related to this `CostItem`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `CostItem`."""
  costCurrency: Currency

  """The `CostItem` that was deleted by this mutation."""
  costItem: CostItem

  """An edge for our `CostItem`. May be used by Relay 1."""
  costItemEdge(
    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsEdge

  """Reads a single `CostTax` that is related to this `CostItem`."""
  costTax: CostTax
  deletedCostItemNodeId: ID

  """Reads a single `Organisation` that is related to this `CostItem`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCostTaxByNodeId` mutation."""
input DeleteCostTaxByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CostTax` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCostTax` mutation."""
input DeleteCostTaxInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `CostTax` mutation."""
type DeleteCostTaxPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CostTax` that was deleted by this mutation."""
  costTax: CostTax

  """An edge for our `CostTax`. May be used by Relay 1."""
  costTaxEdge(
    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostTaxesEdge
  deletedCostTaxNodeId: ID

  """Reads a single `Organisation` that is related to this `CostTax`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCountryByName` mutation."""
input DeleteCountryByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteCountryByNodeId` mutation."""
input DeleteCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Country` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCountryBySlug` mutation."""
input DeleteCountryBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  slug: String!
}

"""All input for the `deleteCountry` mutation."""
input DeleteCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Country` mutation."""
type DeleteCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Continent` that is related to this `Country`."""
  continent: Continent

  """The `Country` that was deleted by this mutation."""
  country: Country

  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
  deletedCountryNodeId: ID

  """Reads a single `Asset` that is related to this `Country`."""
  image: Asset

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCurrencyByIso` mutation."""
input DeleteCurrencyByIsoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  iso: String!
}

"""All input for the `deleteCurrencyByName` mutation."""
input DeleteCurrencyByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteCurrencyByNodeId` mutation."""
input DeleteCurrencyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Currency` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCurrencyCountryByNodeId` mutation."""
input DeleteCurrencyCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CurrencyCountry` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCurrencyCountry` mutation."""
input DeleteCurrencyCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  currencyId: UUID!
}

"""The output of our delete `CurrencyCountry` mutation."""
type DeleteCurrencyCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `CurrencyCountry`."""
  country: Country

  """Reads a single `Currency` that is related to this `CurrencyCountry`."""
  currency: Currency

  """The `CurrencyCountry` that was deleted by this mutation."""
  currencyCountry: CurrencyCountry

  """An edge for our `CurrencyCountry`. May be used by Relay 1."""
  currencyCountryEdge(
    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyCountriesEdge
  deletedCurrencyCountryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteCurrency` mutation."""
input DeleteCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Currency` mutation."""
type DeleteCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was deleted by this mutation."""
  currency: Currency

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge
  deletedCurrencyNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteGratiByNodeId` mutation."""
input DeleteGratiByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Grati` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGrati` mutation."""
input DeleteGratiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Grati` mutation."""
type DeleteGratiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedGratiNodeId: ID

  """The `Grati` that was deleted by this mutation."""
  grati: Grati

  """An edge for our `Grati`. May be used by Relay 1."""
  gratiEdge(
    """The method to use when ordering `Grati`."""
    orderBy: [GratisOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisEdge @deprecated(reason: "Use Promo Codes")

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteGratisUsedByNodeId` mutation."""
input DeleteGratisUsedByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GratisUsed` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteGratisUsed` mutation."""
input DeleteGratisUsedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gratisId: UUID!
  userId: UUID!
}

"""The output of our delete `GratisUsed` mutation."""
type DeleteGratisUsedPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedGratisUsedNodeId: ID

  """Reads a single `Grati` that is related to this `GratisUsed`."""
  gratis: Grati

  """The `GratisUsed` that was deleted by this mutation."""
  gratisUsed: GratisUsed

  """An edge for our `GratisUsed`. May be used by Relay 1."""
  gratisUsedEdge(
    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisUsedsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `GratisUsed`."""
  user: User
}

"""All input for the `deleteLanguageByName` mutation."""
input DeleteLanguageByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteLanguageByNodeId` mutation."""
input DeleteLanguageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Language` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLanguageCountryByNodeId` mutation."""
input DeleteLanguageCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LanguageCountry` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLanguageCountry` mutation."""
input DeleteLanguageCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  languageId: UUID!
}

"""The output of our delete `LanguageCountry` mutation."""
type DeleteLanguageCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `LanguageCountry`."""
  country: Country
  deletedLanguageCountryNodeId: ID

  """Reads a single `Language` that is related to this `LanguageCountry`."""
  language: Language

  """The `LanguageCountry` that was deleted by this mutation."""
  languageCountry: LanguageCountry

  """An edge for our `LanguageCountry`. May be used by Relay 1."""
  languageCountryEdge(
    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguageCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteLanguage` mutation."""
input DeleteLanguageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Language` mutation."""
type DeleteLanguagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedLanguageNodeId: ID

  """The `Language` that was deleted by this mutation."""
  language: Language

  """An edge for our `Language`. May be used by Relay 1."""
  languageEdge(
    """The method to use when ordering `Language`."""
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteMetaByNodeId` mutation."""
input DeleteMetaByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Meta` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMeta` mutation."""
input DeleteMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Meta` mutation."""
type DeleteMetaPayload {
  """Reads a single `User` that is related to this `Meta`."""
  author: User

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `ClientOrganisation` that is related to this `Meta`."""
  clientOrganisation: ClientOrganisation

  """Reads a single `ClientPerson` that is related to this `Meta`."""
  clientPerson: ClientPerson
  deletedMetadatumNodeId: ID

  """The `Meta` that was deleted by this mutation."""
  meta: Meta

  """An edge for our `Meta`. May be used by Relay 1."""
  metaEdge(
    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasEdge

  """Reads a single `Organisation` that is related to this `Meta`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Supplier` that is related to this `Meta`."""
  supplier: Supplier
}

"""All input for the `deleteOrganisationInviteByCode` mutation."""
input DeleteOrganisationInviteByCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!
}

"""All input for the `deleteOrganisationInviteByNodeId` mutation."""
input DeleteOrganisationInviteByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OrganisationInvite` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteOrganisationInviteByOrganisationIdAndEmail` mutation.
"""
input DeleteOrganisationInviteByOrganisationIdAndEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!
  organisationId: UUID!
}

"""All input for the `deleteOrganisationInvite` mutation."""
input DeleteOrganisationInviteInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `OrganisationInvite` mutation."""
type DeleteOrganisationInvitePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedOrganisationInviteNodeId: ID

  """
  Reads a single `Organisation` that is related to this `OrganisationInvite`.
  """
  organisation: Organisation

  """The `OrganisationInvite` that was deleted by this mutation."""
  organisationInvite: OrganisationInvite

  """An edge for our `OrganisationInvite`. May be used by Relay 1."""
  organisationInviteEdge(
    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationInvitesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OrganisationInvite`."""
  user: User
}

"""All input for the `deleteOrganisationTierByName` mutation."""
input DeleteOrganisationTierByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteOrganisationTierByNodeId` mutation."""
input DeleteOrganisationTierByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OrganisationTier` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOrganisationTier` mutation."""
input DeleteOrganisationTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `OrganisationTier` mutation."""
type DeleteOrganisationTierPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedOrganisationTierNodeId: ID

  """The `OrganisationTier` that was deleted by this mutation."""
  organisationTier: OrganisationTier

  """An edge for our `OrganisationTier`. May be used by Relay 1."""
  organisationTierEdge(
    """The method to use when ordering `OrganisationTier`."""
    orderBy: [OrganisationTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationTiersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteOrganisationUserByNodeId` mutation."""
input DeleteOrganisationUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OrganisationUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOrganisationUser` mutation."""
input DeleteOrganisationUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  organisationId: UUID!
  userId: UUID!
}

"""The output of our delete `OrganisationUser` mutation."""
type DeleteOrganisationUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedOrganisationUserNodeId: ID

  """
  Reads a single `Organisation` that is related to this `OrganisationUser`.
  """
  organisation: Organisation

  """The `OrganisationUser` that was deleted by this mutation."""
  organisationUser: OrganisationUser

  """An edge for our `OrganisationUser`. May be used by Relay 1."""
  organisationUserEdge(
    """The method to use when ordering `OrganisationUser`."""
    orderBy: [OrganisationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationUsersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `OrganisationUser`."""
  user: User
}

"""All input for the `deleteOutletByName` mutation."""
input DeleteOutletByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteOutletByNodeId` mutation."""
input DeleteOutletByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Outlet` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOutletCountryByNodeId` mutation."""
input DeleteOutletCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OutletCountry` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteOutletCountry` mutation."""
input DeleteOutletCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  outletId: UUID!
}

"""The output of our delete `OutletCountry` mutation."""
type DeleteOutletCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `OutletCountry`."""
  country: Country
  deletedOutletCountryNodeId: ID

  """Reads a single `Outlet` that is related to this `OutletCountry`."""
  outlet: Outlet

  """The `OutletCountry` that was deleted by this mutation."""
  outletCountry: OutletCountry

  """An edge for our `OutletCountry`. May be used by Relay 1."""
  outletCountryEdge(
    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deleteOutlet` mutation."""
input DeleteOutletInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Outlet` mutation."""
type DeleteOutletPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedOutletNodeId: ID

  """The `Outlet` that was deleted by this mutation."""
  outlet: Outlet

  """An edge for our `Outlet`. May be used by Relay 1."""
  outletEdge(
    """The method to use when ordering `Outlet`."""
    orderBy: [OutletsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePartnerPageByNodeId` mutation."""
input DeletePartnerPageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PartnerPage` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePartnerPageBySlug` mutation."""
input DeletePartnerPageBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  slug: String!
}

"""All input for the `deletePartnerPage` mutation."""
input DeletePartnerPageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `PartnerPage` mutation."""
type DeletePartnerPagePayload {
  """Reads a single `Asset` that is related to this `PartnerPage`."""
  background: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedPartnerPageNodeId: ID

  """Reads a single `Grati` that is related to this `PartnerPage`."""
  gratis: Grati

  """Reads a single `Asset` that is related to this `PartnerPage`."""
  logo: Asset

  """The `PartnerPage` that was deleted by this mutation."""
  partnerPage: PartnerPage

  """An edge for our `PartnerPage`. May be used by Relay 1."""
  partnerPageEdge(
    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesEdge

  """Reads a single `PromoCode` that is related to this `PartnerPage`."""
  promoCode: PromoCode

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePlaceByNodeId` mutation."""
input DeletePlaceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Place` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePlace` mutation."""
input DeletePlaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!
}

"""The output of our delete `Place` mutation."""
type DeletePlacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedPlaceNodeId: ID

  """The `Place` that was deleted by this mutation."""
  place: Place

  """An edge for our `Place`. May be used by Relay 1."""
  placeEdge(
    """The method to use when ordering `Place`."""
    orderBy: [PlacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlacesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `deletePromoCodeAffiliateByNodeId` mutation."""
input DeletePromoCodeAffiliateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PromoCodeAffiliate` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePromoCodeAffiliate` mutation."""
input DeletePromoCodeAffiliateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  promoCodeId: UUID!
  userId: UUID!
}

"""The output of our delete `PromoCodeAffiliate` mutation."""
type DeletePromoCodeAffiliatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedPromoCodeAffiliateNodeId: ID

  """
  Reads a single `PromoCode` that is related to this `PromoCodeAffiliate`.
  """
  promoCode: PromoCode

  """The `PromoCodeAffiliate` that was deleted by this mutation."""
  promoCodeAffiliate: PromoCodeAffiliate

  """An edge for our `PromoCodeAffiliate`. May be used by Relay 1."""
  promoCodeAffiliateEdge(
    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeAffiliatesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `PromoCodeAffiliate`."""
  user: User
}

"""All input for the `deleteRegionByName` mutation."""
input DeleteRegionByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""All input for the `deleteRegionByNodeId` mutation."""
input DeleteRegionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Region` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRegionBySlug` mutation."""
input DeleteRegionBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  slug: String!
}

"""All input for the `deleteRegion` mutation."""
input DeleteRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Region` mutation."""
type DeleteRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `Region`."""
  country: Country
  deletedRegionNodeId: ID

  """Reads a single `Asset` that is related to this `Region`."""
  image: Asset

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Region` that was deleted by this mutation."""
  region: Region

  """An edge for our `Region`. May be used by Relay 1."""
  regionEdge(
    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsEdge
}

"""All input for the `deleteSettingByNodeId` mutation."""
input DeleteSettingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSetting` mutation."""
input DeleteSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  userId: UUID!
}

"""The output of our delete `Setting` mutation."""
type DeleteSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSettingNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Setting` that was deleted by this mutation."""
  setting: Setting

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge @deprecated(reason: "Use Trip.appearance")

  """Reads a single `User` that is related to this `Setting`."""
  user: User
}

"""All input for the `deleteSubscriptionLogByNodeId` mutation."""
input DeleteSubscriptionLogByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SubscriptionLog` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSubscriptionLog` mutation."""
input DeleteSubscriptionLogInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `SubscriptionLog` mutation."""
type DeleteSubscriptionLogPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSubscriptionLogNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `SubscriptionLog` that was deleted by this mutation."""
  subscriptionLog: SubscriptionLog

  """An edge for our `SubscriptionLog`. May be used by Relay 1."""
  subscriptionLogEdge(
    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionLogsEdge

  """Reads a single `User` that is related to this `SubscriptionLog`."""
  user: User
}

"""All input for the `deleteSupplierByNodeId` mutation."""
input DeleteSupplierByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Supplier` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSupplierCategoryByNodeId` mutation."""
input DeleteSupplierCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SupplierCategory` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSupplierCategory` mutation."""
input DeleteSupplierCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `SupplierCategory` mutation."""
type DeleteSupplierCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSupplierCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `SupplierCategory` that was deleted by this mutation."""
  supplierCategory: SupplierCategory

  """An edge for our `SupplierCategory`. May be used by Relay 1."""
  supplierCategoryEdge(
    """The method to use when ordering `SupplierCategory`."""
    orderBy: [SupplierCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierCategoriesEdge
}

"""All input for the `deleteSupplier` mutation."""
input DeleteSupplierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Supplier` mutation."""
type DeleteSupplierPayload {
  """Reads a single `User` that is related to this `Supplier`."""
  author: User

  """Reads a single `SupplierCategory` that is related to this `Supplier`."""
  category: SupplierCategory

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSupplierNodeId: ID

  """Reads a single `Asset` that is related to this `Supplier`."""
  logo: Asset

  """Reads a single `Organisation` that is related to this `Supplier`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Supplier` that was deleted by this mutation."""
  supplier: Supplier

  """An edge for our `Supplier`. May be used by Relay 1."""
  supplierEdge(
    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersEdge
}

"""All input for the `deleteSupplierTagByNodeId` mutation."""
input DeleteSupplierTagByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SupplierTag` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSupplierTag` mutation."""
input DeleteSupplierTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  supplierId: UUID!
  tagId: UUID!
}

"""The output of our delete `SupplierTag` mutation."""
type DeleteSupplierTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedSupplierTagNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Supplier` that is related to this `SupplierTag`."""
  supplier: Supplier

  """The `SupplierTag` that was deleted by this mutation."""
  supplierTag: SupplierTag

  """An edge for our `SupplierTag`. May be used by Relay 1."""
  supplierTagEdge(
    """The method to use when ordering `SupplierTag`."""
    orderBy: [SupplierTagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierTagsEdge

  """Reads a single `Tag` that is related to this `SupplierTag`."""
  tag: Tag
}

"""All input for the `deleteTagByNameAndTypeAndOrganisationId` mutation."""
input DeleteTagByNameAndTypeAndOrganisationIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
  organisationId: UUID!
  type: TagType!
}

"""All input for the `deleteTagByNodeId` mutation."""
input DeleteTagByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tag` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTag` mutation."""
input DeleteTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Tag` mutation."""
type DeleteTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedTagNodeId: ID

  """Reads a single `Organisation` that is related to this `Tag`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Tag` that was deleted by this mutation."""
  tag: Tag

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the `deleteTagTripByNodeId` mutation."""
input DeleteTagTripByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TagTrip` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTagTrip` mutation."""
input DeleteTagTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  tagId: UUID!
  tripId: UUID!
}

"""The output of our delete `TagTrip` mutation."""
type DeleteTagTripPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedTagTripNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Tag` that is related to this `TagTrip`."""
  tag: Tag

  """The `TagTrip` that was deleted by this mutation."""
  tagTrip: TagTrip

  """An edge for our `TagTrip`. May be used by Relay 1."""
  tagTripEdge(
    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagTripsEdge

  """Reads a single `Trip` that is related to this `TagTrip`."""
  trip: Trip
}

"""All input for the `deleteTaskByNodeId` mutation."""
input DeleteTaskByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Task` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTask` mutation."""
input DeleteTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Task` mutation."""
type DeleteTaskPayload {
  """Reads a single `Card` that is related to this `Task`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedTaskNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Task` that was deleted by this mutation."""
  task: Task

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksEdge

  """Reads a single `Trip` that is related to this `Task`."""
  trip: Trip

  """Reads a single `User` that is related to this `Task`."""
  user: User
}

"""All input for the `deleteTripAssetImageByNodeId` mutation."""
input DeleteTripAssetImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TripAssetImage` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTripAssetImage` mutation."""
input DeleteTripAssetImageInput {
  assetId: UUID!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  tripId: UUID!
}

"""The output of our delete `TripAssetImage` mutation."""
type DeleteTripAssetImagePayload {
  """Reads a single `Asset` that is related to this `TripAssetImage`."""
  asset: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedTripAssetImageNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `TripAssetImage`."""
  trip: Trip

  """The `TripAssetImage` that was deleted by this mutation."""
  tripAssetImage: TripAssetImage

  """An edge for our `TripAssetImage`. May be used by Relay 1."""
  tripAssetImageEdge(
    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripAssetImagesEdge
}

"""All input for the `deleteTripByNodeId` mutation."""
input DeleteTripByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Trip` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTripCountryByNodeId` mutation."""
input DeleteTripCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TripCountry` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTripCountry` mutation."""
input DeleteTripCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  tripId: UUID!
}

"""The output of our delete `TripCountry` mutation."""
type DeleteTripCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `TripCountry`."""
  country: Country
  deletedTripCountryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `TripCountry`."""
  trip: Trip

  """The `TripCountry` that was deleted by this mutation."""
  tripCountry: TripCountry

  """An edge for our `TripCountry`. May be used by Relay 1."""
  tripCountryEdge(
    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripCountriesEdge
}

"""All input for the `deleteTrip` mutation."""
input DeleteTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Trip` mutation."""
type DeleteTripPayload {
  """Reads a single `Client` that is related to this `Trip`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency
  deletedTripNodeId: ID

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation

  """Reads a single `User` that is related to this `Trip`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip

  """The `Trip` that was deleted by this mutation."""
  trip: Trip

  """An edge for our `Trip`. May be used by Relay 1."""
  tripEdge(
    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsEdge
}

"""All input for the `deleteTripRegionByNodeId` mutation."""
input DeleteTripRegionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TripRegion` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTripRegion` mutation."""
input DeleteTripRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  regionId: UUID!
  tripId: UUID!
}

"""The output of our delete `TripRegion` mutation."""
type DeleteTripRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedTripRegionNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Region` that is related to this `TripRegion`."""
  region: Region

  """Reads a single `Trip` that is related to this `TripRegion`."""
  trip: Trip

  """The `TripRegion` that was deleted by this mutation."""
  tripRegion: TripRegion

  """An edge for our `TripRegion`. May be used by Relay 1."""
  tripRegionEdge(
    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripRegionsEdge
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `deleteUser` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Discover implements Node {
  """Reads a single `Country` that is related to this `Discover`."""
  country: Country
  countryId: UUID
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Region` that is related to this `Discover`."""
  region: Region
  regionId: UUID

  """Reads a single `Tag` that is related to this `Discover`."""
  tag: Tag
  tagId: UUID
  terms: JSON

  """Reads a single `Trip` that is related to this `Discover`."""
  trip: Trip
  tripId: UUID
  type: String
  vector: String
}

"""
A filter to be used against `Discover` object types. All fields are combined with a logical ‘and.’
"""
input DiscoverFilter {
  """Checks for all expressions in this list."""
  and: [DiscoverFilter!]

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """A related `country` exists."""
  countryExists: Boolean

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: DiscoverFilter

  """Checks for any expressions in this list."""
  or: [DiscoverFilter!]

  """Filter by the object’s `region` relation."""
  region: RegionFilter

  """A related `region` exists."""
  regionExists: Boolean

  """Filter by the object’s `regionId` field."""
  regionId: UUIDFilter

  """Filter by the object’s `tag` relation."""
  tag: TagFilter

  """A related `tag` exists."""
  tagExists: Boolean

  """Filter by the object’s `tagId` field."""
  tagId: UUIDFilter

  """Filter by the object’s `terms` field."""
  terms: JSONFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """A related `trip` exists."""
  tripExists: Boolean

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter

  """Filter by the object’s `type` field."""
  type: StringFilter
}

"""A connection to a list of `Discover` values."""
type DiscoversConnection {
  """
  A list of edges which contains the `Discover` and cursor to aid in pagination.
  """
  edges: [DiscoversEdge!]!

  """A list of `Discover` objects."""
  nodes: [Discover!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Discover` you could get from the connection."""
  totalCount: Int!
}

"""A `Discover` edge in the connection."""
type DiscoversEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Discover` at the end of the edge."""
  node: Discover!
}

"""All input for the `duplicate` mutation."""
input DuplicateInput {
  cardId: UUID!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `duplicate` mutation."""
type DuplicatePayload {
  card: Card

  """An edge for our `Card`. May be used by Relay 1."""
  cardEdge(
    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Card`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Card`."""
  image: Asset

  """Reads a single `User` that is related to this `Card`."""
  owner: User

  """Reads a single `Card` that is related to this `Card`."""
  parent: Card

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Card`."""
  trip: Trip
}

type EditLock implements Node {
  key: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `User` that is related to this `EditLock`."""
  user: User
  userId: UUID
}

"""
A condition to be used against `EditLock` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input EditLockCondition {
  """Checks for equality with the object’s `key` field."""
  key: String

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""The fields on `editLock` to look up the row to connect."""
input EditLockEditLockPkeyConnect {
  key: String!
}

"""
A filter to be used against `EditLock` object types. All fields are combined with a logical ‘and.’
"""
input EditLockFilter {
  """Checks for all expressions in this list."""
  and: [EditLockFilter!]

  """Filter by the object’s `key` field."""
  key: StringFilter

  """Negates the expression."""
  not: EditLockFilter

  """Checks for any expressions in this list."""
  or: [EditLockFilter!]

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""The globally unique `ID` look up for the row to connect."""
input EditLockNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `editLock` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input EditLockOnEditLockForEditLockUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `editLock` to look up the row to update."""
input EditLockOnEditLockForEditLockUserIdFkeyUsingEditLockPkeyUpdate {
  key: String!

  """
  An object where the defined keys will be set on the `editLock` being updated.
  """
  patch: updateEditLockOnEditLockForEditLockUserIdFkeyPatch!
}

"""
Represents an update to a `EditLock`. Fields that are set will be updated.
"""
input EditLockPatch {
  key: String
  user: EditLockUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `user` in the `EditLockInput` mutation.
"""
input EditLockUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnEditLockForEditLockUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: EditLockOnEditLockForEditLockUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `editLock` in the `UserInput` mutation.
"""
input EditLockUserIdFkeyInverseInput {
  """
  The primary key(s) for `editLock` for the far side of the relationship.
  """
  connectByKey: [EditLockEditLockPkeyConnect!]

  """
  The primary key(s) for `editLock` for the far side of the relationship.
  """
  connectByNodeId: [EditLockNodeIdConnect!]

  """
  The primary key(s) and patch data for `editLock` for the far side of the relationship.
  """
  updateByKey: [EditLockOnEditLockForEditLockUserIdFkeyUsingEditLockPkeyUpdate!]

  """
  The primary key(s) and patch data for `editLock` for the far side of the relationship.
  """
  updateByNodeId: [UserOnEditLockForEditLockUserIdFkeyNodeIdUpdate!]
}

"""A connection to a list of `EditLock` values."""
type EditLocksConnection {
  """
  A list of edges which contains the `EditLock` and cursor to aid in pagination.
  """
  edges: [EditLocksEdge!]!

  """A list of `EditLock` objects."""
  nodes: [EditLock!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `EditLock` you could get from the connection."""
  totalCount: Int!
}

"""A `EditLock` edge in the connection."""
type EditLocksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `EditLock` at the end of the edge."""
  node: EditLock!
}

"""Methods to use when ordering `EditLock`."""
enum EditLocksOrderBy {
  KEY_ASC
  KEY_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""
Input for the nested mutation of `referrer` in the `AssetInput` mutation.
"""
input FakePublicReferrerForeignKey0InverseInput {
  """
  A `ReferrerInput` object that will be created and connected to this object.
  """
  create: [FakePublicReferrerForeignKey0ReferrerCreateInput!]
}

"""The `referrer` to be created by this mutation."""
input FakePublicReferrerForeignKey0ReferrerCreateInput {
  backgroundId: UUID
  discount: Int
  logoId: UUID
  name: String
}

"""
Input for the nested mutation of `referrer` in the `AssetInput` mutation.
"""
input FakePublicReferrerForeignKey1InverseInput {
  """
  A `ReferrerInput` object that will be created and connected to this object.
  """
  create: [FakePublicReferrerForeignKey1ReferrerCreateInput!]
}

"""The `referrer` to be created by this mutation."""
input FakePublicReferrerForeignKey1ReferrerCreateInput {
  backgroundId: UUID
  discount: Int
  logoId: UUID
  name: String
}

"""The `asset` to be created by this mutation."""
input FakePublicViewerOrganisationsForeignKey0AssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
Input for the nested mutation of `asset` in the `ViewerOrganisationInput` mutation.
"""
input FakePublicViewerOrganisationsForeignKey0Input {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: FakePublicViewerOrganisationsForeignKey0AssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnViewerOrganisationForFakePublicViewerOrganisationsForeignKey0UsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: ViewerOrganisationOnViewerOrganisationForFakePublicViewerOrganisationsForeignKey0NodeIdUpdate
}

"""
Input for the nested mutation of `viewerOrganisation` in the `AssetInput` mutation.
"""
input FakePublicViewerOrganisationsForeignKey0InverseInput {
  """
  A `ViewerOrganisationInput` object that will be created and connected to this object.
  """
  create: [FakePublicViewerOrganisationsForeignKey0ViewerOrganisationsCreateInput!]
}

"""The `viewerOrganisation` to be created by this mutation."""
input FakePublicViewerOrganisationsForeignKey0ViewerOrganisationsCreateInput {
  asset: FakePublicViewerOrganisationsForeignKey0Input
  id: UUID
  logoId: UUID
  name: String
  primaryColour: String
  secondaryColour: String
}

"""A merge of flight basic & live data"""
type Flight implements Node {
  """Reads a single `Airline` that is related to this `Flight`."""
  airline: Airline
  airlineIata: String
  arrBaggage: String
  arrDatetime: Datetime
  arrDatetimeUtc: Datetime
  arrEstimated: Datetime
  arrEstimatedUtc: Datetime
  arrGate: String
  arrIata: String
  arrTerminal: String
  arrTime: Datetime
  arrTimeUtc: Datetime

  """Reads a single `Airport` that is related to this `Flight`."""
  arrivalAirport: Airport
  delay: BigFloat
  delayed: Boolean
  depDate: Date
  depDatetime: Datetime
  depDatetimeUtc: Datetime
  depGate: String
  depIata: String
  depTerminal: String
  depTime: Datetime
  depTimeUtc: Datetime

  """Reads a single `Airport` that is related to this `Flight`."""
  departureAirport: Airport
  duration: BigInt
  fetchStatus: FlightFetchStatus
  flightIata: String
  id: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  updatedAt: Datetime
}

enum FlightFetchStatus {
  FAILURE
  PENDING
  SUCCESS
}

"""
A filter to be used against Float fields. All fields are combined with a logical ‘and.’
"""
input FloatFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Float

  """Equal to the specified value."""
  equalTo: Float

  """Greater than the specified value."""
  greaterThan: Float

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Float

  """Included in the specified list."""
  in: [Float!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Float

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Float

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Float

  """Not equal to the specified value."""
  notEqualTo: Float

  """Not included in the specified list."""
  notIn: [Float!]
}

"""All input for the `forceTripUpdate` mutation."""
input ForceTripUpdateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `forceTripUpdate` mutation."""
type ForceTripUpdatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type GlobalStat {
  totalCards: BigInt
  totalRevenue: Float
  totalTrips: BigInt
  totalUsers: BigInt
}

type Grati implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """The code users must enter to use the gratis"""
  code: String!

  """When this item was created"""
  createdAt: Datetime

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime

  """Reads and enables pagination through a set of `GratisUsed`."""
  gratisUsedsByGratisId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratisUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratisUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisUsedsConnection!

  """Reads and enables pagination through a set of `GratisUsed`."""
  gratisUsedsByGratisIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratisUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratisUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!]
  ): [GratisUsed!]!
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesByGratisId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesConnection!

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesByGratisIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!]
  ): [PartnerPage!]!

  """When this item was restored"""
  restoredAt: Datetime

  """When this item was updated"""
  updatedAt: Datetime

  """The number of times this code has been used"""
  usedCount: BigInt

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""
A condition to be used against `Grati` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input GratiCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `duration` field."""
  duration: Int

  """Checks for equality with the object’s `expiresAt` field."""
  expiresAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `uses` field."""
  uses: Int

  """Checks for equality with the object’s `validFrom` field."""
  validFrom: Datetime
}

"""
A filter to be used against `Grati` object types. All fields are combined with a logical ‘and.’
"""
input GratiFilter {
  """Checks for all expressions in this list."""
  and: [GratiFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `code` field."""
  code: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `duration` field."""
  duration: IntFilter

  """Filter by the object’s `expiresAt` field."""
  expiresAt: DatetimeFilter

  """Filter by the object’s `gratisUsedsByGratisId` relation."""
  gratisUsedsByGratisId: GratiToManyGratisUsedFilter

  """Some related `gratisUsedsByGratisId` exist."""
  gratisUsedsByGratisIdExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: GratiFilter

  """Checks for any expressions in this list."""
  or: [GratiFilter!]

  """Filter by the object’s `partnerPagesByGratisId` relation."""
  partnerPagesByGratisId: GratiToManyPartnerPageFilter

  """Some related `partnerPagesByGratisId` exist."""
  partnerPagesByGratisIdExist: Boolean

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `usedCount` field."""
  usedCount: BigIntFilter

  """Filter by the object’s `uses` field."""
  uses: IntFilter

  """Filter by the object’s `validFrom` field."""
  validFrom: DatetimeFilter
}

"""The fields on `grati` to look up the row to connect."""
input GratiGratisPkeyConnect {
  id: UUID!
}

"""The fields on `grati` to look up the row to delete."""
input GratiGratisPkeyDelete {
  id: UUID!
}

"""An input for mutations affecting `Grati`"""
input GratiInput {
  """The code users must enter to use the gratis"""
  code: String!

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime
  gratisUseds: GratisUsedGratisIdFkeyInverseInput
  id: UUID
  name: String!
  partnerPages: PartnerPageGratisIdFkeyInverseInput

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""The globally unique `ID` look up for the row to connect."""
input GratiNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `grati` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input GratiNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `grati` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input GratiOnGratisUsedForGratisUsedGratisIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gratisUsed` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gratisUsed` being updated.
  """
  patch: GratisUsedPatch!
}

"""The fields on `grati` to look up the row to update."""
input GratiOnGratisUsedForGratisUsedGratisIdFkeyUsingGratisPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `grati` being updated.
  """
  patch: updateGratiOnGratisUsedForGratisUsedGratisIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input GratiOnPartnerPageForPartnerPageGratisIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `partnerPage` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: PartnerPagePatch!
}

"""The fields on `grati` to look up the row to update."""
input GratiOnPartnerPageForPartnerPageGratisIdFkeyUsingGratisPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `grati` being updated.
  """
  patch: updateGratiOnPartnerPageForPartnerPageGratisIdFkeyPatch!
}

"""
Represents an update to a `Grati`. Fields that are set will be updated.
"""
input GratiPatch {
  """The code users must enter to use the gratis"""
  code: String

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime
  gratisUseds: GratisUsedGratisIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPageGratisIdFkeyInverseInput

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""
A filter to be used against many `GratisUsed` object types. All fields are combined with a logical ‘and.’
"""
input GratiToManyGratisUsedFilter {
  """
  Every related `GratisUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: GratisUsedFilter

  """
  No related `GratisUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: GratisUsedFilter

  """
  Some related `GratisUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: GratisUsedFilter
}

"""
A filter to be used against many `PartnerPage` object types. All fields are combined with a logical ‘and.’
"""
input GratiToManyPartnerPageFilter {
  """
  Every related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PartnerPageFilter

  """
  No related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PartnerPageFilter

  """
  Some related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PartnerPageFilter
}

"""A connection to a list of `Grati` values."""
type GratisConnection {
  """
  A list of edges which contains the `Grati` and cursor to aid in pagination.
  """
  edges: [GratisEdge!]!

  """A list of `Grati` objects."""
  nodes: [Grati!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Grati` you could get from the connection."""
  totalCount: Int!
}

"""A `Grati` edge in the connection."""
type GratisEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Grati` at the end of the edge."""
  node: Grati!
}

"""Methods to use when ordering `Grati`."""
enum GratisOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CODE_ASC
  CODE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  DURATION_ASC
  DURATION_DESC
  EXPIRES_AT_ASC
  EXPIRES_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USES_ASC
  USES_DESC
  VALID_FROM_ASC
  VALID_FROM_DESC
}

type GratisUsed implements Node {
  createdAt: Datetime

  """Reads a single `Grati` that is related to this `GratisUsed`."""
  gratis: Grati
  gratisId: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `User` that is related to this `GratisUsed`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `GratisUsed` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input GratisUsedCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `gratisId` field."""
  gratisId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `GratisUsed` object types. All fields are combined with a logical ‘and.’
"""
input GratisUsedFilter {
  """Checks for all expressions in this list."""
  and: [GratisUsedFilter!]

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `gratis` relation."""
  gratis: GratiFilter

  """Filter by the object’s `gratisId` field."""
  gratisId: UUIDFilter

  """Negates the expression."""
  not: GratisUsedFilter

  """Checks for any expressions in this list."""
  or: [GratisUsedFilter!]

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""The `grati` to be created by this mutation."""
input GratisUsedGratisIdFkeyGratisCreateInput {
  """The code users must enter to use the gratis"""
  code: String!

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime
  gratisUseds: GratisUsedGratisIdFkeyInverseInput
  id: UUID
  name: String!
  partnerPages: PartnerPageGratisIdFkeyInverseInput

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""The `gratisUsed` to be created by this mutation."""
input GratisUsedGratisIdFkeyGratisUsedCreateInput {
  createdAt: Datetime
  grati: GratisUsedGratisIdFkeyInput
  gratisId: UUID
  user: GratisUsedUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `grati` in the `GratisUsedInput` mutation.
"""
input GratisUsedGratisIdFkeyInput {
  """The primary key(s) for `grati` for the far side of the relationship."""
  connectById: GratiGratisPkeyConnect

  """The primary key(s) for `grati` for the far side of the relationship."""
  connectByNodeId: GratiNodeIdConnect

  """
  A `GratiInput` object that will be created and connected to this object.
  """
  create: GratisUsedGratisIdFkeyGratisCreateInput

  """The primary key(s) for `grati` for the far side of the relationship."""
  deleteById: GratiGratisPkeyDelete

  """The primary key(s) for `grati` for the far side of the relationship."""
  deleteByNodeId: GratiNodeIdDelete

  """
  The primary key(s) and patch data for `grati` for the far side of the relationship.
  """
  updateById: GratiOnGratisUsedForGratisUsedGratisIdFkeyUsingGratisPkeyUpdate

  """
  The primary key(s) and patch data for `grati` for the far side of the relationship.
  """
  updateByNodeId: GratisUsedOnGratisUsedForGratisUsedGratisIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `gratisUsed` in the `GratiInput` mutation.
"""
input GratisUsedGratisIdFkeyInverseInput {
  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  connectByGratisIdAndUserId: [GratisUsedGratisUsedPkeyConnect!]

  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  connectByNodeId: [GratisUsedNodeIdConnect!]

  """
  A `GratisUsedInput` object that will be created and connected to this object.
  """
  create: [GratisUsedGratisIdFkeyGratisUsedCreateInput!]

  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  deleteByGratisIdAndUserId: [GratisUsedGratisUsedPkeyDelete!]

  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  deleteByNodeId: [GratisUsedNodeIdDelete!]

  """
  Flag indicating whether all other `gratisUsed` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `gratisUsed` for the far side of the relationship.
  """
  updateByGratisIdAndUserId: [GratisUsedOnGratisUsedForGratisUsedGratisIdFkeyUsingGratisUsedPkeyUpdate!]

  """
  The primary key(s) and patch data for `gratisUsed` for the far side of the relationship.
  """
  updateByNodeId: [GratiOnGratisUsedForGratisUsedGratisIdFkeyNodeIdUpdate!]
}

"""The fields on `gratisUsed` to look up the row to connect."""
input GratisUsedGratisUsedPkeyConnect {
  gratisId: UUID!
  userId: UUID!
}

"""The fields on `gratisUsed` to look up the row to delete."""
input GratisUsedGratisUsedPkeyDelete {
  gratisId: UUID!
  userId: UUID!
}

"""An input for mutations affecting `GratisUsed`"""
input GratisUsedInput {
  createdAt: Datetime
  grati: GratisUsedGratisIdFkeyInput
  gratisId: UUID
  user: GratisUsedUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input GratisUsedNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `gratisUsed` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input GratisUsedNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `gratisUsed` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input GratisUsedOnGratisUsedForGratisUsedGratisIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `grati` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `grati` being updated.
  """
  patch: GratiPatch!
}

"""The fields on `gratisUsed` to look up the row to update."""
input GratisUsedOnGratisUsedForGratisUsedGratisIdFkeyUsingGratisUsedPkeyUpdate {
  gratisId: UUID!

  """
  An object where the defined keys will be set on the `gratisUsed` being updated.
  """
  patch: updateGratisUsedOnGratisUsedForGratisUsedGratisIdFkeyPatch!
  userId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input GratisUsedOnGratisUsedForGratisUsedUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `gratisUsed` to look up the row to update."""
input GratisUsedOnGratisUsedForGratisUsedUserIdFkeyUsingGratisUsedPkeyUpdate {
  gratisId: UUID!

  """
  An object where the defined keys will be set on the `gratisUsed` being updated.
  """
  patch: updateGratisUsedOnGratisUsedForGratisUsedUserIdFkeyPatch!
  userId: UUID!
}

"""
Represents an update to a `GratisUsed`. Fields that are set will be updated.
"""
input GratisUsedPatch {
  createdAt: Datetime
  grati: GratisUsedGratisIdFkeyInput
  gratisId: UUID
  user: GratisUsedUserIdFkeyInput
  userId: UUID
}

"""The `gratisUsed` to be created by this mutation."""
input GratisUsedUserIdFkeyGratisUsedCreateInput {
  createdAt: Datetime
  grati: GratisUsedGratisIdFkeyInput
  gratisId: UUID
  user: GratisUsedUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `user` in the `GratisUsedInput` mutation.
"""
input GratisUsedUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnGratisUsedForGratisUsedUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: GratisUsedOnGratisUsedForGratisUsedUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `gratisUsed` in the `UserInput` mutation.
"""
input GratisUsedUserIdFkeyInverseInput {
  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  connectByGratisIdAndUserId: [GratisUsedGratisUsedPkeyConnect!]

  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  connectByNodeId: [GratisUsedNodeIdConnect!]

  """
  A `GratisUsedInput` object that will be created and connected to this object.
  """
  create: [GratisUsedUserIdFkeyGratisUsedCreateInput!]

  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  deleteByGratisIdAndUserId: [GratisUsedGratisUsedPkeyDelete!]

  """
  The primary key(s) for `gratisUsed` for the far side of the relationship.
  """
  deleteByNodeId: [GratisUsedNodeIdDelete!]

  """
  Flag indicating whether all other `gratisUsed` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `gratisUsed` for the far side of the relationship.
  """
  updateByGratisIdAndUserId: [GratisUsedOnGratisUsedForGratisUsedUserIdFkeyUsingGratisUsedPkeyUpdate!]

  """
  The primary key(s) and patch data for `gratisUsed` for the far side of the relationship.
  """
  updateByNodeId: [UserOnGratisUsedForGratisUsedUserIdFkeyNodeIdUpdate!]
}

"""A connection to a list of `GratisUsed` values."""
type GratisUsedsConnection {
  """
  A list of edges which contains the `GratisUsed` and cursor to aid in pagination.
  """
  edges: [GratisUsedsEdge!]!

  """A list of `GratisUsed` objects."""
  nodes: [GratisUsed!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `GratisUsed` you could get from the connection."""
  totalCount: Int!
}

"""A `GratisUsed` edge in the connection."""
type GratisUsedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `GratisUsed` at the end of the edge."""
  node: GratisUsed!
}

"""Methods to use when ordering `GratisUsed`."""
enum GratisUsedsOrderBy {
  CREATED_AT_ASC
  CREATED_AT_DESC
  GRATIS_ID_ASC
  GRATIS_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  USER_ID_ASC
  USER_ID_DESC
}

enum Honorific {
  MISS
  MR
  MRS
  MS
}

"""
A filter to be used against Honorific fields. All fields are combined with a logical ‘and.’
"""
input HonorificFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Honorific

  """Equal to the specified value."""
  equalTo: Honorific

  """Greater than the specified value."""
  greaterThan: Honorific

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Honorific

  """Included in the specified list."""
  in: [Honorific!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Honorific

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Honorific

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Honorific

  """Not equal to the specified value."""
  notEqualTo: Honorific

  """Not included in the specified list."""
  notIn: [Honorific!]
}

"""
A filter to be used against Int fields. All fields are combined with a logical ‘and.’
"""
input IntFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Int

  """Equal to the specified value."""
  equalTo: Int

  """Greater than the specified value."""
  greaterThan: Int

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Int

  """Included in the specified list."""
  in: [Int!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Int

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Int

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Int

  """Not equal to the specified value."""
  notEqualTo: Int

  """Not included in the specified list."""
  notIn: [Int!]
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
type Interval {
  """A quantity of days."""
  days: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of minutes."""
  minutes: Int

  """A quantity of months."""
  months: Int

  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals don’t
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of years."""
  years: Int
}

"""
A filter to be used against Interval fields. All fields are combined with a logical ‘and.’
"""
input IntervalFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: IntervalInput

  """Equal to the specified value."""
  equalTo: IntervalInput

  """Greater than the specified value."""
  greaterThan: IntervalInput

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: IntervalInput

  """Included in the specified list."""
  in: [IntervalInput!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: IntervalInput

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: IntervalInput

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: IntervalInput

  """Not equal to the specified value."""
  notEqualTo: IntervalInput

  """Not included in the specified list."""
  notIn: [IntervalInput!]
}

"""
An interval of time that has passed where the smallest distinct unit is a second.
"""
input IntervalInput {
  """A quantity of days."""
  days: Int

  """A quantity of hours."""
  hours: Int

  """A quantity of minutes."""
  minutes: Int

  """A quantity of months."""
  months: Int

  """
  A quantity of seconds. This is the only non-integer field, as all the other
  fields will dump their overflow into a smaller unit of time. Intervals don’t
  have a smaller unit than seconds.
  """
  seconds: Float

  """A quantity of years."""
  years: Int
}

"""All input for the `inviteAccept` mutation."""
input InviteAcceptInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!
}

"""The output of our `inviteAccept` mutation."""
type InviteAcceptPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  uuid: UUID
}

"""All input for the `inviteCreate` mutation."""
input InviteCreateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!
  permissions: [Permission]
  role: CollaborationRole
  tripId: UUID!
}

"""The output of our `inviteCreate` mutation."""
type InviteCreatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

input InviteInput {
  email: String!
  id: UUID
  permissions: [TripPermission]!
  tripId: UUID
  userId: UUID
}

"""All input for the `invitePurge` mutation."""
input InvitePurgeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `invitePurge` mutation."""
type InvitePurgePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `inviteRevoke` mutation."""
input InviteRevokeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `inviteRevoke` mutation."""
type InviteRevokePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `inviteSendEmail` mutation."""
input InviteSendEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `inviteSendEmail` mutation."""
type InviteSendEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
Input for the nested mutation of `trip` in the `InviteV2Input` mutation.
"""
input InviteTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: InviteTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnInviteV2ForInviteTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: InviteV2OnInviteV2ForInviteTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `inviteV2` in the `TripInput` mutation.
"""
input InviteTripIdFkeyInverseInput {
  """
  The primary key(s) for `inviteV2` for the far side of the relationship.
  """
  connectByCode: [InviteV2InviteCodeKeyConnect!]

  """
  The primary key(s) for `inviteV2` for the far side of the relationship.
  """
  connectByEmailAndTripId: [InviteV2InviteEmailTripIdKeyConnect!]

  """
  The primary key(s) for `inviteV2` for the far side of the relationship.
  """
  connectById: [InviteV2InvitePkeyConnect!]

  """
  The primary key(s) for `inviteV2` for the far side of the relationship.
  """
  connectByNodeId: [InviteV2NodeIdConnect!]

  """
  The primary key(s) and patch data for `inviteV2` for the far side of the relationship.
  """
  updateByCode: [InviteV2OnInviteV2ForInviteTripIdFkeyUsingInviteCodeKeyUpdate!]

  """
  The primary key(s) and patch data for `inviteV2` for the far side of the relationship.
  """
  updateByEmailAndTripId: [InviteV2OnInviteV2ForInviteTripIdFkeyUsingInviteEmailTripIdKeyUpdate!]

  """
  The primary key(s) and patch data for `inviteV2` for the far side of the relationship.
  """
  updateById: [InviteV2OnInviteV2ForInviteTripIdFkeyUsingInvitePkeyUpdate!]

  """
  The primary key(s) and patch data for `inviteV2` for the far side of the relationship.
  """
  updateByNodeId: [TripOnInviteV2ForInviteTripIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input InviteTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

type InviteV2 implements Node {
  code: String

  """When this item was created"""
  createdAt: Datetime
  email: String!
  expires: Datetime!
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  permissions: [Permission] @deprecated(reason: "Use role")
  role: CollaborationRole!

  """Reads a single `Trip` that is related to this `InviteV2`."""
  trip: Trip
  tripId: UUID!

  """When this item was updated"""
  updatedAt: Datetime
}

"""
A condition to be used against `InviteV2` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input InviteV2Condition {
  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `expires` field."""
  expires: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `permissions` field."""
  permissions: [Permission]

  """Checks for equality with the object’s `role` field."""
  role: CollaborationRole

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `InviteV2` object types. All fields are combined with a logical ‘and.’
"""
input InviteV2Filter {
  """Checks for all expressions in this list."""
  and: [InviteV2Filter!]

  """Filter by the object’s `code` field."""
  code: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `expires` field."""
  expires: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: InviteV2Filter

  """Checks for any expressions in this list."""
  or: [InviteV2Filter!]

  """Filter by the object’s `permissions` field."""
  permissions: PermissionListFilter

  """Filter by the object’s `role` field."""
  role: CollaborationRoleFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""The fields on `inviteV2` to look up the row to connect."""
input InviteV2InviteCodeKeyConnect {
  code: String!
}

"""The fields on `inviteV2` to look up the row to connect."""
input InviteV2InviteEmailTripIdKeyConnect {
  email: String!
  tripId: UUID!
}

"""The fields on `inviteV2` to look up the row to connect."""
input InviteV2InvitePkeyConnect {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input InviteV2NodeIdConnect {
  """
  The globally unique `ID` which identifies a single `inviteV2` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input InviteV2OnInviteV2ForInviteTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `inviteV2` to look up the row to update."""
input InviteV2OnInviteV2ForInviteTripIdFkeyUsingInviteCodeKeyUpdate {
  code: String!

  """
  An object where the defined keys will be set on the `inviteV2` being updated.
  """
  patch: updateInviteV2OnInviteV2ForInviteTripIdFkeyPatch!
}

"""The fields on `inviteV2` to look up the row to update."""
input InviteV2OnInviteV2ForInviteTripIdFkeyUsingInviteEmailTripIdKeyUpdate {
  email: String!

  """
  An object where the defined keys will be set on the `inviteV2` being updated.
  """
  patch: updateInviteV2OnInviteV2ForInviteTripIdFkeyPatch!
  tripId: UUID!
}

"""The fields on `inviteV2` to look up the row to update."""
input InviteV2OnInviteV2ForInviteTripIdFkeyUsingInvitePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `inviteV2` being updated.
  """
  patch: updateInviteV2OnInviteV2ForInviteTripIdFkeyPatch!
}

"""
Represents an update to a `InviteV2`. Fields that are set will be updated.
"""
input InviteV2Patch {
  code: String
  email: String
  expires: Datetime
  id: UUID
  permissions: [Permission]
  role: CollaborationRole
  trip: InviteTripIdFkeyInput
  tripId: UUID
}

"""A connection to a list of `InviteV2` values."""
type InviteV2sConnection {
  """
  A list of edges which contains the `InviteV2` and cursor to aid in pagination.
  """
  edges: [InviteV2sEdge!]!

  """A list of `InviteV2` objects."""
  nodes: [InviteV2!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `InviteV2` you could get from the connection."""
  totalCount: Int!
}

"""A `InviteV2` edge in the connection."""
type InviteV2sEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `InviteV2` at the end of the edge."""
  node: InviteV2!
}

"""Methods to use when ordering `InviteV2`."""
enum InviteV2sOrderBy {
  CODE_ASC
  CODE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  EXPIRES_ASC
  EXPIRES_DESC
  ID_ASC
  ID_DESC
  NATURAL
  PERMISSIONS_ASC
  PERMISSIONS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROLE_ASC
  ROLE_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
A filter to be used against JSON fields. All fields are combined with a logical ‘and.’
"""
input JSONFilter {
  """Contained by the specified JSON."""
  containedBy: JSON

  """Contains the specified JSON."""
  contains: JSON

  """Contains all of the specified keys."""
  containsAllKeys: [String!]

  """Contains any of the specified keys."""
  containsAnyKeys: [String!]

  """Contains the specified key."""
  containsKey: String

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: JSON

  """Equal to the specified value."""
  equalTo: JSON

  """Greater than the specified value."""
  greaterThan: JSON

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: JSON

  """Included in the specified list."""
  in: [JSON!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: JSON

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: JSON

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: JSON

  """Not equal to the specified value."""
  notEqualTo: JSON

  """Not included in the specified list."""
  notIn: [JSON!]
}

type Job {
  attempts: Int!
  createdAt: Datetime!
  flags: JSON
  id: BigInt!
  key: String
  lastError: String
  lockedAt: Datetime
  lockedBy: String
  maxAttempts: Int!
  payload: JSON!
  priority: Int!
  queueName: String
  revision: Int!
  runAt: Datetime!
  taskIdentifier: String!
  updatedAt: Datetime!
}

"""
A filter to be used against `Job` object types. All fields are combined with a logical ‘and.’
"""
input JobFilter {
  """Checks for all expressions in this list."""
  and: [JobFilter!]

  """Filter by the object’s `attempts` field."""
  attempts: IntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `flags` field."""
  flags: JSONFilter

  """Filter by the object’s `id` field."""
  id: BigIntFilter

  """Filter by the object’s `key` field."""
  key: StringFilter

  """Filter by the object’s `lastError` field."""
  lastError: StringFilter

  """Filter by the object’s `lockedAt` field."""
  lockedAt: DatetimeFilter

  """Filter by the object’s `lockedBy` field."""
  lockedBy: StringFilter

  """Filter by the object’s `maxAttempts` field."""
  maxAttempts: IntFilter

  """Negates the expression."""
  not: JobFilter

  """Checks for any expressions in this list."""
  or: [JobFilter!]

  """Filter by the object’s `priority` field."""
  priority: IntFilter

  """Filter by the object’s `queueName` field."""
  queueName: StringFilter

  """Filter by the object’s `revision` field."""
  revision: IntFilter

  """Filter by the object’s `runAt` field."""
  runAt: DatetimeFilter

  """Filter by the object’s `taskIdentifier` field."""
  taskIdentifier: StringFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""A connection to a list of `Job` values."""
type JobsConnection {
  """
  A list of edges which contains the `Job` and cursor to aid in pagination.
  """
  edges: [JobsEdge!]!

  """A list of `Job` objects."""
  nodes: [Job!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Job` you could get from the connection."""
  totalCount: Int!
}

"""A `Job` edge in the connection."""
type JobsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Job` at the end of the edge."""
  node: Job!
}

type Language implements Node {
  """Reads and enables pagination through a set of `LanguageCountry`."""
  countries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LanguageCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguageCountriesConnection!

  """Reads and enables pagination through a set of `LanguageCountry`."""
  countriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LanguageCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!]
  ): [LanguageCountry!]!
  id: UUID!
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `Language` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LanguageCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `LanguageCountry` values."""
type LanguageCountriesConnection {
  """
  A list of edges which contains the `LanguageCountry` and cursor to aid in pagination.
  """
  edges: [LanguageCountriesEdge!]!

  """A list of `LanguageCountry` objects."""
  nodes: [LanguageCountry!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `LanguageCountry` you could get from the connection.
  """
  totalCount: Int!
}

"""A `LanguageCountry` edge in the connection."""
type LanguageCountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `LanguageCountry` at the end of the edge."""
  node: LanguageCountry!
}

"""Methods to use when ordering `LanguageCountry`."""
enum LanguageCountriesOrderBy {
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  LANGUAGE_ID_ASC
  LANGUAGE_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORTING_ASC
  SORTING_DESC
}

type LanguageCountry implements Node {
  """Reads a single `Country` that is related to this `LanguageCountry`."""
  country: Country
  countryId: UUID!

  """Reads a single `Language` that is related to this `LanguageCountry`."""
  language: Language
  languageId: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  sorting: Int
}

"""
A condition to be used against `LanguageCountry` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input LanguageCountryCondition {
  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `languageId` field."""
  languageId: UUID

  """Checks for equality with the object’s `sorting` field."""
  sorting: Int
}

"""The `country` to be created by this mutation."""
input LanguageCountryCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `LanguageCountryInput` mutation.
"""
input LanguageCountryCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: LanguageCountryCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: LanguageCountryOnLanguageCountryForLanguageCountryCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `languageCountry` in the `CountryInput` mutation.
"""
input LanguageCountryCountryIdFkeyInverseInput {
  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  connectByLanguageIdAndCountryId: [LanguageCountryLanguageCountryPkeyConnect!]

  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  connectByNodeId: [LanguageCountryNodeIdConnect!]

  """
  A `LanguageCountryInput` object that will be created and connected to this object.
  """
  create: [LanguageCountryCountryIdFkeyLanguageCountryCreateInput!]

  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  deleteByLanguageIdAndCountryId: [LanguageCountryLanguageCountryPkeyDelete!]

  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  deleteByNodeId: [LanguageCountryNodeIdDelete!]

  """
  Flag indicating whether all other `languageCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `languageCountry` for the far side of the relationship.
  """
  updateByLanguageIdAndCountryId: [LanguageCountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingLanguageCountryPkeyUpdate!]

  """
  The primary key(s) and patch data for `languageCountry` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnLanguageCountryForLanguageCountryCountryIdFkeyNodeIdUpdate!]
}

"""The `languageCountry` to be created by this mutation."""
input LanguageCountryCountryIdFkeyLanguageCountryCreateInput {
  country: LanguageCountryCountryIdFkeyInput
  countryId: UUID
  language: LanguageCountryLanguageIdFkeyInput
  languageId: UUID
  sorting: Int
}

"""
A filter to be used against `LanguageCountry` object types. All fields are combined with a logical ‘and.’
"""
input LanguageCountryFilter {
  """Checks for all expressions in this list."""
  and: [LanguageCountryFilter!]

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Filter by the object’s `language` relation."""
  language: LanguageFilter

  """Filter by the object’s `languageId` field."""
  languageId: UUIDFilter

  """Negates the expression."""
  not: LanguageCountryFilter

  """Checks for any expressions in this list."""
  or: [LanguageCountryFilter!]

  """Filter by the object’s `sorting` field."""
  sorting: IntFilter
}

"""An input for mutations affecting `LanguageCountry`"""
input LanguageCountryInput {
  country: LanguageCountryCountryIdFkeyInput
  countryId: UUID
  language: LanguageCountryLanguageIdFkeyInput
  languageId: UUID
  sorting: Int
}

"""The fields on `languageCountry` to look up the row to connect."""
input LanguageCountryLanguageCountryPkeyConnect {
  countryId: UUID!
  languageId: UUID!
}

"""The fields on `languageCountry` to look up the row to delete."""
input LanguageCountryLanguageCountryPkeyDelete {
  countryId: UUID!
  languageId: UUID!
}

"""
Input for the nested mutation of `language` in the `LanguageCountryInput` mutation.
"""
input LanguageCountryLanguageIdFkeyInput {
  """
  The primary key(s) for `language` for the far side of the relationship.
  """
  connectById: LanguageLanguagePkeyConnect

  """
  The primary key(s) for `language` for the far side of the relationship.
  """
  connectByName: LanguageLanguageNameKeyConnect

  """
  The primary key(s) for `language` for the far side of the relationship.
  """
  connectByNodeId: LanguageNodeIdConnect

  """
  A `LanguageInput` object that will be created and connected to this object.
  """
  create: LanguageCountryLanguageIdFkeyLanguageCreateInput

  """
  The primary key(s) for `language` for the far side of the relationship.
  """
  deleteById: LanguageLanguagePkeyDelete

  """
  The primary key(s) for `language` for the far side of the relationship.
  """
  deleteByName: LanguageLanguageNameKeyDelete

  """
  The primary key(s) for `language` for the far side of the relationship.
  """
  deleteByNodeId: LanguageNodeIdDelete

  """
  The primary key(s) and patch data for `language` for the far side of the relationship.
  """
  updateById: LanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyUsingLanguagePkeyUpdate

  """
  The primary key(s) and patch data for `language` for the far side of the relationship.
  """
  updateByName: LanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyUsingLanguageNameKeyUpdate

  """
  The primary key(s) and patch data for `language` for the far side of the relationship.
  """
  updateByNodeId: LanguageCountryOnLanguageCountryForLanguageCountryLanguageIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `languageCountry` in the `LanguageInput` mutation.
"""
input LanguageCountryLanguageIdFkeyInverseInput {
  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  connectByLanguageIdAndCountryId: [LanguageCountryLanguageCountryPkeyConnect!]

  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  connectByNodeId: [LanguageCountryNodeIdConnect!]

  """
  A `LanguageCountryInput` object that will be created and connected to this object.
  """
  create: [LanguageCountryLanguageIdFkeyLanguageCountryCreateInput!]

  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  deleteByLanguageIdAndCountryId: [LanguageCountryLanguageCountryPkeyDelete!]

  """
  The primary key(s) for `languageCountry` for the far side of the relationship.
  """
  deleteByNodeId: [LanguageCountryNodeIdDelete!]

  """
  Flag indicating whether all other `languageCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `languageCountry` for the far side of the relationship.
  """
  updateByLanguageIdAndCountryId: [LanguageCountryOnLanguageCountryForLanguageCountryLanguageIdFkeyUsingLanguageCountryPkeyUpdate!]

  """
  The primary key(s) and patch data for `languageCountry` for the far side of the relationship.
  """
  updateByNodeId: [LanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyNodeIdUpdate!]
}

"""The `languageCountry` to be created by this mutation."""
input LanguageCountryLanguageIdFkeyLanguageCountryCreateInput {
  country: LanguageCountryCountryIdFkeyInput
  countryId: UUID
  language: LanguageCountryLanguageIdFkeyInput
  languageId: UUID
  sorting: Int
}

"""The `language` to be created by this mutation."""
input LanguageCountryLanguageIdFkeyLanguageCreateInput {
  countries: LanguageCountryLanguageIdFkeyInverseInput
  id: UUID
  name: String
}

"""The globally unique `ID` look up for the row to connect."""
input LanguageCountryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `languageCountry` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input LanguageCountryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `languageCountry` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input LanguageCountryOnLanguageCountryForLanguageCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `languageCountry` to look up the row to update."""
input LanguageCountryOnLanguageCountryForLanguageCountryCountryIdFkeyUsingLanguageCountryPkeyUpdate {
  countryId: UUID!
  languageId: UUID!

  """
  An object where the defined keys will be set on the `languageCountry` being updated.
  """
  patch: updateLanguageCountryOnLanguageCountryForLanguageCountryCountryIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input LanguageCountryOnLanguageCountryForLanguageCountryLanguageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `language` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `language` being updated.
  """
  patch: LanguagePatch!
}

"""The fields on `languageCountry` to look up the row to update."""
input LanguageCountryOnLanguageCountryForLanguageCountryLanguageIdFkeyUsingLanguageCountryPkeyUpdate {
  countryId: UUID!
  languageId: UUID!

  """
  An object where the defined keys will be set on the `languageCountry` being updated.
  """
  patch: updateLanguageCountryOnLanguageCountryForLanguageCountryLanguageIdFkeyPatch!
}

"""
Represents an update to a `LanguageCountry`. Fields that are set will be updated.
"""
input LanguageCountryPatch {
  country: LanguageCountryCountryIdFkeyInput
  countryId: UUID
  language: LanguageCountryLanguageIdFkeyInput
  languageId: UUID
  sorting: Int
}

"""
A filter to be used against `Language` object types. All fields are combined with a logical ‘and.’
"""
input LanguageFilter {
  """Checks for all expressions in this list."""
  and: [LanguageFilter!]

  """Filter by the object’s `countries` relation."""
  countries: LanguageToManyLanguageCountryFilter

  """Some related `countries` exist."""
  countriesExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: LanguageFilter

  """Checks for any expressions in this list."""
  or: [LanguageFilter!]
}

"""An input for mutations affecting `Language`"""
input LanguageInput {
  countries: LanguageCountryLanguageIdFkeyInverseInput
  id: UUID
  name: String
}

"""The fields on `language` to look up the row to connect."""
input LanguageLanguageNameKeyConnect {
  name: String!
}

"""The fields on `language` to look up the row to delete."""
input LanguageLanguageNameKeyDelete {
  name: String!
}

"""The fields on `language` to look up the row to connect."""
input LanguageLanguagePkeyConnect {
  id: UUID!
}

"""The fields on `language` to look up the row to delete."""
input LanguageLanguagePkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input LanguageNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `language` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input LanguageNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `language` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input LanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `languageCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `languageCountry` being updated.
  """
  patch: LanguageCountryPatch!
}

"""The fields on `language` to look up the row to update."""
input LanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyUsingLanguageNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `language` being updated.
  """
  patch: updateLanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyPatch!
}

"""The fields on `language` to look up the row to update."""
input LanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyUsingLanguagePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `language` being updated.
  """
  patch: updateLanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyPatch!
}

"""
Represents an update to a `Language`. Fields that are set will be updated.
"""
input LanguagePatch {
  countries: LanguageCountryLanguageIdFkeyInverseInput
  id: UUID
  name: String
}

"""
A filter to be used against many `LanguageCountry` object types. All fields are combined with a logical ‘and.’
"""
input LanguageToManyLanguageCountryFilter {
  """
  Every related `LanguageCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: LanguageCountryFilter

  """
  No related `LanguageCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: LanguageCountryFilter

  """
  Some related `LanguageCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: LanguageCountryFilter
}

"""A connection to a list of `Language` values."""
type LanguagesConnection {
  """
  A list of edges which contains the `Language` and cursor to aid in pagination.
  """
  edges: [LanguagesEdge!]!

  """A list of `Language` objects."""
  nodes: [Language!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Language` you could get from the connection."""
  totalCount: Int!
}

"""A `Language` edge in the connection."""
type LanguagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Language` at the end of the edge."""
  node: Language!
}

"""Methods to use when ordering `Language`."""
enum LanguagesOrderBy {
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type ListenPayload {
  """
  Our root query field type. Allows us to run any query from our subscription payload.
  """
  query: Query
  relatedNode: Node
  relatedNodeId: ID
}

type Location {
  address: String
  lat: Float
  lng: Float
}

"""
A filter to be used against `Location` object types. All fields are combined with a logical ‘and.’
"""
input LocationFilter {
  """Filter by the object’s `address` field."""
  address: StringFilter

  """Checks for all expressions in this list."""
  and: [LocationFilter!]

  """Filter by the object’s `lat` field."""
  lat: FloatFilter

  """Filter by the object’s `lng` field."""
  lng: FloatFilter

  """Negates the expression."""
  not: LocationFilter

  """Checks for any expressions in this list."""
  or: [LocationFilter!]
}

"""An input for mutations affecting `Location`"""
input LocationInput {
  address: String
  lat: Float
  lng: Float
}

input LogoutInput {
  clientMutationId: String
}

type LogoutPayload {
  clientMutationId: String
  success: Boolean
}

type Marker {
  lat: Float
  lng: Float
  meta: JSON
  to: String
  type: String
}

type Meta implements Node {
  """Reads a single `User` that is related to this `Meta`."""
  author: User
  authorId: UUID

  """Reads a single `ClientOrganisation` that is related to this `Meta`."""
  clientOrganisation: ClientOrganisation
  clientOrganisationId: UUID

  """Reads a single `ClientPerson` that is related to this `Meta`."""
  clientPerson: ClientPerson
  clientPersonId: UUID

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Organisation` that is related to this `Meta`."""
  organisation: Organisation
  organisationId: UUID!
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType

  """Reads a single `Supplier` that is related to this `Meta`."""
  supplier: Supplier
  supplierId: UUID

  """When this item was updated"""
  updatedAt: Datetime
  value: String
}

"""
A condition to be used against `Meta` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MetaCondition {
  """Checks for equality with the object’s `authorId` field."""
  authorId: UUID

  """Checks for equality with the object’s `clientOrganisationId` field."""
  clientOrganisationId: UUID

  """Checks for equality with the object’s `clientPersonId` field."""
  clientPersonId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `primaryType` field."""
  primaryType: MetadataPrimaryType

  """Checks for equality with the object’s `secondaryType` field."""
  secondaryType: MetadataSecondaryType

  """Checks for equality with the object’s `supplierId` field."""
  supplierId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `value` field."""
  value: String
}

"""
A filter to be used against `Meta` object types. All fields are combined with a logical ‘and.’
"""
input MetaFilter {
  """Checks for all expressions in this list."""
  and: [MetaFilter!]

  """Filter by the object’s `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the object’s `authorId` field."""
  authorId: UUIDFilter

  """Filter by the object’s `clientOrganisation` relation."""
  clientOrganisation: ClientOrganisationFilter

  """A related `clientOrganisation` exists."""
  clientOrganisationExists: Boolean

  """Filter by the object’s `clientOrganisationId` field."""
  clientOrganisationId: UUIDFilter

  """Filter by the object’s `clientPerson` relation."""
  clientPerson: ClientPersonFilter

  """A related `clientPerson` exists."""
  clientPersonExists: Boolean

  """Filter by the object’s `clientPersonId` field."""
  clientPersonId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Negates the expression."""
  not: MetaFilter

  """Checks for any expressions in this list."""
  or: [MetaFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `primaryType` field."""
  primaryType: MetadataPrimaryTypeFilter

  """Filter by the object’s `secondaryType` field."""
  secondaryType: MetadataSecondaryTypeFilter

  """Filter by the object’s `supplier` relation."""
  supplier: SupplierFilter

  """A related `supplier` exists."""
  supplierExists: Boolean

  """Filter by the object’s `supplierId` field."""
  supplierId: UUIDFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `value` field."""
  value: StringFilter
}

"""An input for mutations affecting `Meta`"""
input MetaInput {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""The fields on `meta` to look up the row to connect."""
input MetaMetadataPkeyConnect {
  id: UUID!
}

"""The fields on `meta` to look up the row to delete."""
input MetaMetadataPkeyDelete {
  id: UUID!
}

"""The globally unique `ID` look up for the row to connect."""
input MetaNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `meta` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input MetaNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `meta` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input MetaOnMetaForMetadataAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `meta` to look up the row to update."""
input MetaOnMetaForMetadataAuthorIdFkeyUsingMetadataPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: updateMetaOnMetaForMetadataAuthorIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input MetaOnMetaForMetadataClientOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientOrganisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientOrganisation` being updated.
  """
  patch: ClientOrganisationPatch!
}

"""The fields on `meta` to look up the row to update."""
input MetaOnMetaForMetadataClientOrganisationIdFkeyUsingMetadataPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: updateMetaOnMetaForMetadataClientOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input MetaOnMetaForMetadataClientPersonIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientPerson` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: ClientPersonPatch!
}

"""The fields on `meta` to look up the row to update."""
input MetaOnMetaForMetadataClientPersonIdFkeyUsingMetadataPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: updateMetaOnMetaForMetadataClientPersonIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input MetaOnMetaForMetadataOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `meta` to look up the row to update."""
input MetaOnMetaForMetadataOrganisationIdFkeyUsingMetadataPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: updateMetaOnMetaForMetadataOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input MetaOnMetaForMetadataSupplierIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The fields on `meta` to look up the row to update."""
input MetaOnMetaForMetadataSupplierIdFkeyUsingMetadataPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: updateMetaOnMetaForMetadataSupplierIdFkeyPatch!
}

"""Represents an update to a `Meta`. Fields that are set will be updated."""
input MetaPatch {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""Input for the nested mutation of `user` in the `MetaInput` mutation."""
input MetadataAuthorIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnMetaForMetadataAuthorIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: MetaOnMetaForMetadataAuthorIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `meta` in the `UserInput` mutation."""
input MetadataAuthorIdFkeyInverseInput {
  """The primary key(s) for `meta` for the far side of the relationship."""
  connectById: [MetaMetadataPkeyConnect!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  connectByNodeId: [MetaNodeIdConnect!]

  """
  A `MetaInput` object that will be created and connected to this object.
  """
  create: [MetadataAuthorIdFkeyMetadataCreateInput!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteById: [MetaMetadataPkeyDelete!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteByNodeId: [MetaNodeIdDelete!]

  """
  Flag indicating whether all other `meta` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateById: [MetaOnMetaForMetadataAuthorIdFkeyUsingMetadataPkeyUpdate!]

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateByNodeId: [UserOnMetaForMetadataAuthorIdFkeyNodeIdUpdate!]
}

"""The `meta` to be created by this mutation."""
input MetadataAuthorIdFkeyMetadataCreateInput {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""The `clientOrganisation` to be created by this mutation."""
input MetadataClientOrganisationIdFkeyClientOrganisationCreateInput {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String!
}

"""
Input for the nested mutation of `clientOrganisation` in the `MetaInput` mutation.
"""
input MetadataClientOrganisationIdFkeyInput {
  """
  The primary key(s) for `clientOrganisation` for the far side of the relationship.
  """
  connectById: ClientOrganisationClientOrganisationPkeyConnect

  """
  The primary key(s) for `clientOrganisation` for the far side of the relationship.
  """
  connectByNodeId: ClientOrganisationNodeIdConnect

  """
  A `ClientOrganisationInput` object that will be created and connected to this object.
  """
  create: MetadataClientOrganisationIdFkeyClientOrganisationCreateInput

  """
  The primary key(s) and patch data for `clientOrganisation` for the far side of the relationship.
  """
  updateById: ClientOrganisationOnMetaForMetadataClientOrganisationIdFkeyUsingClientOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `clientOrganisation` for the far side of the relationship.
  """
  updateByNodeId: MetaOnMetaForMetadataClientOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `meta` in the `ClientOrganisationInput` mutation.
"""
input MetadataClientOrganisationIdFkeyInverseInput {
  """The primary key(s) for `meta` for the far side of the relationship."""
  connectById: [MetaMetadataPkeyConnect!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  connectByNodeId: [MetaNodeIdConnect!]

  """
  A `MetaInput` object that will be created and connected to this object.
  """
  create: [MetadataClientOrganisationIdFkeyMetadataCreateInput!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteById: [MetaMetadataPkeyDelete!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteByNodeId: [MetaNodeIdDelete!]

  """
  Flag indicating whether all other `meta` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateById: [MetaOnMetaForMetadataClientOrganisationIdFkeyUsingMetadataPkeyUpdate!]

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateByNodeId: [ClientOrganisationOnMetaForMetadataClientOrganisationIdFkeyNodeIdUpdate!]
}

"""The `meta` to be created by this mutation."""
input MetadataClientOrganisationIdFkeyMetadataCreateInput {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""The `clientPerson` to be created by this mutation."""
input MetadataClientPersonIdFkeyClientPersonCreateInput {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String!
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String!
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `clientPerson` in the `MetaInput` mutation.
"""
input MetadataClientPersonIdFkeyInput {
  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectById: ClientPersonClientPersonPkeyConnect

  """
  The primary key(s) for `clientPerson` for the far side of the relationship.
  """
  connectByNodeId: ClientPersonNodeIdConnect

  """
  A `ClientPersonInput` object that will be created and connected to this object.
  """
  create: MetadataClientPersonIdFkeyClientPersonCreateInput

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateById: ClientPersonOnMetaForMetadataClientPersonIdFkeyUsingClientPersonPkeyUpdate

  """
  The primary key(s) and patch data for `clientPerson` for the far side of the relationship.
  """
  updateByNodeId: MetaOnMetaForMetadataClientPersonIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `meta` in the `ClientPersonInput` mutation.
"""
input MetadataClientPersonIdFkeyInverseInput {
  """The primary key(s) for `meta` for the far side of the relationship."""
  connectById: [MetaMetadataPkeyConnect!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  connectByNodeId: [MetaNodeIdConnect!]

  """
  A `MetaInput` object that will be created and connected to this object.
  """
  create: [MetadataClientPersonIdFkeyMetadataCreateInput!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteById: [MetaMetadataPkeyDelete!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteByNodeId: [MetaNodeIdDelete!]

  """
  Flag indicating whether all other `meta` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateById: [MetaOnMetaForMetadataClientPersonIdFkeyUsingMetadataPkeyUpdate!]

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateByNodeId: [ClientPersonOnMetaForMetadataClientPersonIdFkeyNodeIdUpdate!]
}

"""The `meta` to be created by this mutation."""
input MetadataClientPersonIdFkeyMetadataCreateInput {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""
Input for the nested mutation of `organisation` in the `MetaInput` mutation.
"""
input MetadataOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnMetaForMetadataOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: MetaOnMetaForMetadataOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `meta` in the `OrganisationInput` mutation.
"""
input MetadataOrganisationIdFkeyInverseInput {
  """The primary key(s) for `meta` for the far side of the relationship."""
  connectById: [MetaMetadataPkeyConnect!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  connectByNodeId: [MetaNodeIdConnect!]

  """
  A `MetaInput` object that will be created and connected to this object.
  """
  create: [MetadataOrganisationIdFkeyMetadataCreateInput!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteById: [MetaMetadataPkeyDelete!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteByNodeId: [MetaNodeIdDelete!]

  """
  Flag indicating whether all other `meta` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateById: [MetaOnMetaForMetadataOrganisationIdFkeyUsingMetadataPkeyUpdate!]

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnMetaForMetadataOrganisationIdFkeyNodeIdUpdate!]
}

"""The `meta` to be created by this mutation."""
input MetadataOrganisationIdFkeyMetadataCreateInput {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

enum MetadataPrimaryType {
  ADDRESS
  EMAIL
  LINK
  NOTES
  PHONE
}

"""
A filter to be used against MetadataPrimaryType fields. All fields are combined with a logical ‘and.’
"""
input MetadataPrimaryTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: MetadataPrimaryType

  """Equal to the specified value."""
  equalTo: MetadataPrimaryType

  """Greater than the specified value."""
  greaterThan: MetadataPrimaryType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: MetadataPrimaryType

  """Included in the specified list."""
  in: [MetadataPrimaryType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: MetadataPrimaryType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: MetadataPrimaryType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: MetadataPrimaryType

  """Not equal to the specified value."""
  notEqualTo: MetadataPrimaryType

  """Not included in the specified list."""
  notIn: [MetadataPrimaryType!]
}

enum MetadataSecondaryType {
  ADDRESS_HOME
  ADDRESS_OTHER
  ADDRESS_SCHOOL
  ADDRESS_WORK
  EMAIL_ACCOUNTS
  EMAIL_ADMIN
  EMAIL_BOOKING
  EMAIL_OTHER
  EMAIL_PERSONAL
  EMAIL_SCHOOL
  EMAIL_WORK
  LINK_FACEBOOK
  LINK_INSTAGRAM
  LINK_LINKEDIN
  LINK_OTHER
  LINK_TWITTER
  LINK_WEBSITE
  LINK_YOUTUBE
  PHONE_LANDLINE
  PHONE_MOBILE
  PHONE_OTHER
  PHONE_PERSONAL
  PHONE_SCHOOL
  PHONE_WORK
}

"""
A filter to be used against MetadataSecondaryType fields. All fields are combined with a logical ‘and.’
"""
input MetadataSecondaryTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: MetadataSecondaryType

  """Equal to the specified value."""
  equalTo: MetadataSecondaryType

  """Greater than the specified value."""
  greaterThan: MetadataSecondaryType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: MetadataSecondaryType

  """Included in the specified list."""
  in: [MetadataSecondaryType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: MetadataSecondaryType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: MetadataSecondaryType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: MetadataSecondaryType

  """Not equal to the specified value."""
  notEqualTo: MetadataSecondaryType

  """Not included in the specified list."""
  notIn: [MetadataSecondaryType!]
}

"""
Input for the nested mutation of `supplier` in the `MetaInput` mutation.
"""
input MetadataSupplierIdFkeyInput {
  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectById: SupplierSupplierPkeyConnect

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectByNodeId: SupplierNodeIdConnect

  """
  A `SupplierInput` object that will be created and connected to this object.
  """
  create: MetadataSupplierIdFkeySupplierCreateInput

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteById: SupplierSupplierPkeyDelete

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteByNodeId: SupplierNodeIdDelete

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateById: SupplierOnMetaForMetadataSupplierIdFkeyUsingSupplierPkeyUpdate

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateByNodeId: MetaOnMetaForMetadataSupplierIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `meta` in the `SupplierInput` mutation.
"""
input MetadataSupplierIdFkeyInverseInput {
  """The primary key(s) for `meta` for the far side of the relationship."""
  connectById: [MetaMetadataPkeyConnect!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  connectByNodeId: [MetaNodeIdConnect!]

  """
  A `MetaInput` object that will be created and connected to this object.
  """
  create: [MetadataSupplierIdFkeyMetadataCreateInput!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteById: [MetaMetadataPkeyDelete!]

  """The primary key(s) for `meta` for the far side of the relationship."""
  deleteByNodeId: [MetaNodeIdDelete!]

  """
  Flag indicating whether all other `meta` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateById: [MetaOnMetaForMetadataSupplierIdFkeyUsingMetadataPkeyUpdate!]

  """
  The primary key(s) and patch data for `meta` for the far side of the relationship.
  """
  updateByNodeId: [SupplierOnMetaForMetadataSupplierIdFkeyNodeIdUpdate!]
}

"""The `meta` to be created by this mutation."""
input MetadataSupplierIdFkeyMetadataCreateInput {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType!
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""The `supplier` to be created by this mutation."""
input MetadataSupplierIdFkeySupplierCreateInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""A connection to a list of `Meta` values."""
type MetasConnection {
  """
  A list of edges which contains the `Meta` and cursor to aid in pagination.
  """
  edges: [MetasEdge!]!

  """A list of `Meta` objects."""
  nodes: [Meta!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Meta` you could get from the connection."""
  totalCount: Int!
}

"""A `Meta` edge in the connection."""
type MetasEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Meta` at the end of the edge."""
  node: Meta!
}

"""Methods to use when ordering `Meta`."""
enum MetasOrderBy {
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  CLIENT_ORGANISATION_ID_ASC
  CLIENT_ORGANISATION_ID_DESC
  CLIENT_PERSON_ID_ASC
  CLIENT_PERSON_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PRIMARY_TYPE_ASC
  PRIMARY_TYPE_DESC
  SECONDARY_TYPE_ASC
  SECONDARY_TYPE_DESC
  SUPPLIER_ID_ASC
  SUPPLIER_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VALUE_ASC
  VALUE_DESC
}

type MiscTripStat {
  per: String
  percent: Float
  value: BigInt
  with: String
}

"""All input for the `moveColumn` mutation."""
input MoveColumnInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  from: Int!
  to: Int!
  tripId: UUID!
}

"""The output of our `moveColumn` mutation."""
type MoveColumnPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `move` mutation."""
input MoveInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  day: Int!
  id: UUID!
  sorting: Int!
}

"""The output of our `move` mutation."""
type MovePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  acquireLock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AcquireLockInput!
  ): AcquireLockPayload
  addColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AddColumnInput!
  ): AddColumnPayload
  addExpoPushToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AddExpoPushTokenInput!
  ): AddExpoPushTokenPayload

  """Returns the one-time URL for affiliate on-boarding"""
  affiliateOnBoardingUrl: String

  """Returns the one-time URL for the affiliate Stripe dashboard"""
  affiliateStripeDashboardUrl: String
  agentDeleteAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AgentDeleteAccountInput!
  ): AgentDeleteAccountPayload

  """Archives all the cards in a given day"""
  archiveByDay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ArchiveByDayInput!
  ): ArchiveByDayPayload
  assetFromUnsplashId(id: String!): Asset!
  authNoop(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AuthNoopInput!
  ): AuthNoopPayload

  """Authenticate a user by login details"""
  authenticate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AuthenticateInput!
  ): AuthenticatePayload!

  """A presigned URL to the attachment, expires after 60 seconds"""
  authenticateOauth(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: AuthenticateOauthInput!
  ): SessionToken!
  cardCostDuplicate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CardCostDuplicateInput!
  ): CardCostDuplicatePayload
  clearCountryRelations(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ClearCountryRelationsInput!
  ): ClearCountryRelationsPayload
  clearUserAffiliatePromoCodes(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ClearUserAffiliatePromoCodesInput!
  ): ClearUserAffiliatePromoCodesPayload

  """
  Duplicates a trip by the given ID, along with it's cards, tasks, and other relations (except collaborators)
  """
  cloneTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CloneTripInput!
  ): CloneTripPayload

  """
  Used to remove or leave a trip. If `userId` is null, it will fallback to the session user.
  """
  collaboratorRevoke(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CollaboratorRevokeInput!
  ): CollaboratorRevokePayload
  costItemDuplicate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CostItemDuplicateInput!
  ): CostItemDuplicatePayload
  createAgentTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAgentTripInput!
  ): CreateAgentTripPayload

  """Creates a single `Asset`."""
  createAsset(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAssetInput!
  ): CreateAssetPayload

  """Creates a single `Attachment`."""
  createAttachment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAttachmentInput!
  ): CreateAttachmentPayload

  """Creates a single `Card`."""
  createCard(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCardInput!
  ): CreateCardPayload

  """Creates a single `CardCost`."""
  createCardCost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCardCostInput!
  ): CreateCardCostPayload

  """Creates a single `Client`."""
  createClient(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClientInput!
  ): CreateClientPayload

  """Creates a single `ClientOrganisation`."""
  createClientOrganisation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClientOrganisationInput!
  ): CreateClientOrganisationPayload

  """Creates a single `ClientOrganisationContact`."""
  createClientOrganisationContact(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClientOrganisationContactInput!
  ): CreateClientOrganisationContactPayload

  """Creates a single `ClientPerson`."""
  createClientPerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateClientPersonInput!
  ): CreateClientPersonPayload

  """Creates a single `Continent`."""
  createContinent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateContinentInput!
  ): CreateContinentPayload

  """Creates a single `CostItem`."""
  createCostItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCostItemInput!
  ): CreateCostItemPayload

  """Creates a single `CostTax`."""
  createCostTax(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCostTaxInput!
  ): CreateCostTaxPayload

  """Creates a single `Country`."""
  createCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCountryInput!
  ): CreateCountryPayload

  """Creates a single `Currency`."""
  createCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCurrencyInput!
  ): CreateCurrencyPayload

  """Creates a single `CurrencyCountry`."""
  createCurrencyCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCurrencyCountryInput!
  ): CreateCurrencyCountryPayload

  """Creates a single `Grati`."""
  createGrati(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGratiInput!
  ): CreateGratiPayload @deprecated(reason: "Use Promo Codes")

  """Creates a single `GratisUsed`."""
  createGratisUsed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateGratisUsedInput!
  ): CreateGratisUsedPayload
  createInvite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateInviteInput!
  ): CreateInvitePayload @deprecated(reason: "Use `inviteCreate`")

  """Creates a single `Language`."""
  createLanguage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLanguageInput!
  ): CreateLanguagePayload

  """Creates a single `LanguageCountry`."""
  createLanguageCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLanguageCountryInput!
  ): CreateLanguageCountryPayload

  """Creates a single `Meta`."""
  createMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMetaInput!
  ): CreateMetaPayload
  createOrganisation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOrganisationInput!
  ): CreateOrganisationPayload

  """Creates a single `OrganisationInvite`."""
  createOrganisationInvite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOrganisationInviteInput!
  ): CreateOrganisationInvitePayload

  """Creates a single `OrganisationTier`."""
  createOrganisationTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOrganisationTierInput!
  ): CreateOrganisationTierPayload

  """Creates a single `OrganisationUser`."""
  createOrganisationUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOrganisationUserInput!
  ): CreateOrganisationUserPayload

  """Creates a single `Outlet`."""
  createOutlet(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOutletInput!
  ): CreateOutletPayload

  """Creates a single `OutletCountry`."""
  createOutletCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateOutletCountryInput!
  ): CreateOutletCountryPayload

  """Creates a single `PartnerPage`."""
  createPartnerPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePartnerPageInput!
  ): CreatePartnerPagePayload
  createPastTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePastTripInput!
  ): CreatePastTripPayload

  """Creates a single `Place`."""
  createPlace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlaceInput!
  ): CreatePlacePayload

  """Creates a single `PromoCode`."""
  createPromoCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePromoCodeInput!
  ): CreatePromoCodePayload

  """Creates a single `PromoCodeAffiliate`."""
  createPromoCodeAffiliate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePromoCodeAffiliateInput!
  ): CreatePromoCodeAffiliatePayload

  """Creates a single `Region`."""
  createRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRegionInput!
  ): CreateRegionPayload

  """Creates a single `Setting`."""
  createSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSettingInput!
  ): CreateSettingPayload @deprecated(reason: "Use Trip.appearance")

  """Creates a single `SubscriptionLog`."""
  createSubscriptionLog(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSubscriptionLogInput!
  ): CreateSubscriptionLogPayload

  """Creates a single `Supplier`."""
  createSupplier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSupplierInput!
  ): CreateSupplierPayload

  """Creates a single `SupplierCategory`."""
  createSupplierCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSupplierCategoryInput!
  ): CreateSupplierCategoryPayload

  """Creates a single `SupplierTag`."""
  createSupplierTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSupplierTagInput!
  ): CreateSupplierTagPayload

  """Creates a single `Tag`."""
  createTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTagInput!
  ): CreateTagPayload

  """Creates a single `TagTrip`."""
  createTagTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTagTripInput!
  ): CreateTagTripPayload

  """Creates a single `Task`."""
  createTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTaskInput!
  ): CreateTaskPayload

  """Creates a single `Template`."""
  createTemplate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTemplateInput!
  ): CreateTemplatePayload

  """Creates a single `Trip`."""
  createTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTripInput!
  ): CreateTripPayload

  """Creates a single `TripAssetImage`."""
  createTripAssetImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTripAssetImageInput!
  ): CreateTripAssetImagePayload

  """Creates a single `TripCountry`."""
  createTripCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTripCountryInput!
  ): CreateTripCountryPayload

  """Creates a single `TripRegion`."""
  createTripRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTripRegionInput!
  ): CreateTripRegionPayload
  deleteAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountInput!
  ): DeleteAccountPayload

  """Attempts to delete the users connected Stripe Account"""
  deleteAffiliateStripeAccount(userId: UUID!): Boolean

  """Deletes a single `Asset` using a unique key."""
  deleteAsset(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAssetInput!
  ): DeleteAssetPayload

  """Deletes a single `Asset` using its globally unique id."""
  deleteAssetByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAssetByNodeIdInput!
  ): DeleteAssetPayload

  """Deletes a single `Attachment` using a unique key."""
  deleteAttachment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAttachmentInput!
  ): DeleteAttachmentPayload

  """Deletes a single `Attachment` using its globally unique id."""
  deleteAttachmentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAttachmentByNodeIdInput!
  ): DeleteAttachmentPayload

  """Deletes all the cards in a given day"""
  deleteByDay(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteByDayInput!
  ): DeleteByDayPayload

  """Deletes a single `Card` using a unique key."""
  deleteCard(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCardInput!
  ): DeleteCardPayload

  """Deletes a single `Card` using its globally unique id."""
  deleteCardByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCardByNodeIdInput!
  ): DeleteCardPayload

  """Deletes a single `Client` using a unique key."""
  deleteClient(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClientInput!
  ): DeleteClientPayload

  """Deletes a single `Client` using its globally unique id."""
  deleteClientByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClientByNodeIdInput!
  ): DeleteClientPayload

  """Deletes a single `ClientOrganisationContact` using a unique key."""
  deleteClientOrganisationContact(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClientOrganisationContactInput!
  ): DeleteClientOrganisationContactPayload

  """
  Deletes a single `ClientOrganisationContact` using its globally unique id.
  """
  deleteClientOrganisationContactByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteClientOrganisationContactByNodeIdInput!
  ): DeleteClientOrganisationContactPayload

  """Deletes a single `Continent` using a unique key."""
  deleteContinent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContinentInput!
  ): DeleteContinentPayload

  """Deletes a single `Continent` using a unique key."""
  deleteContinentByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContinentByNameInput!
  ): DeleteContinentPayload

  """Deletes a single `Continent` using its globally unique id."""
  deleteContinentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContinentByNodeIdInput!
  ): DeleteContinentPayload

  """Deletes a single `CostItem` using a unique key."""
  deleteCostItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCostItemInput!
  ): DeleteCostItemPayload

  """Deletes a single `CostItem` using its globally unique id."""
  deleteCostItemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCostItemByNodeIdInput!
  ): DeleteCostItemPayload

  """Deletes a single `CostTax` using a unique key."""
  deleteCostTax(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCostTaxInput!
  ): DeleteCostTaxPayload

  """Deletes a single `CostTax` using its globally unique id."""
  deleteCostTaxByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCostTaxByNodeIdInput!
  ): DeleteCostTaxPayload

  """Deletes a single `Country` using a unique key."""
  deleteCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryInput!
  ): DeleteCountryPayload

  """Deletes a single `Country` using a unique key."""
  deleteCountryByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryByNameInput!
  ): DeleteCountryPayload

  """Deletes a single `Country` using its globally unique id."""
  deleteCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryByNodeIdInput!
  ): DeleteCountryPayload

  """Deletes a single `Country` using a unique key."""
  deleteCountryBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryBySlugInput!
  ): DeleteCountryPayload

  """Deletes a single `Currency` using a unique key."""
  deleteCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Currency` using a unique key."""
  deleteCurrencyByIso(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyByIsoInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Currency` using a unique key."""
  deleteCurrencyByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyByNameInput!
  ): DeleteCurrencyPayload

  """Deletes a single `Currency` using its globally unique id."""
  deleteCurrencyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyByNodeIdInput!
  ): DeleteCurrencyPayload

  """Deletes a single `CurrencyCountry` using a unique key."""
  deleteCurrencyCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyCountryInput!
  ): DeleteCurrencyCountryPayload

  """Deletes a single `CurrencyCountry` using its globally unique id."""
  deleteCurrencyCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCurrencyCountryByNodeIdInput!
  ): DeleteCurrencyCountryPayload

  """Deletes a single `Grati` using a unique key."""
  deleteGrati(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGratiInput!
  ): DeleteGratiPayload @deprecated(reason: "Use Promo Codes")

  """Deletes a single `Grati` using its globally unique id."""
  deleteGratiByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGratiByNodeIdInput!
  ): DeleteGratiPayload @deprecated(reason: "Use Promo Codes")

  """Deletes a single `GratisUsed` using a unique key."""
  deleteGratisUsed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGratisUsedInput!
  ): DeleteGratisUsedPayload

  """Deletes a single `GratisUsed` using its globally unique id."""
  deleteGratisUsedByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteGratisUsedByNodeIdInput!
  ): DeleteGratisUsedPayload

  """Deletes a single `Language` using a unique key."""
  deleteLanguage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageInput!
  ): DeleteLanguagePayload

  """Deletes a single `Language` using a unique key."""
  deleteLanguageByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageByNameInput!
  ): DeleteLanguagePayload

  """Deletes a single `Language` using its globally unique id."""
  deleteLanguageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageByNodeIdInput!
  ): DeleteLanguagePayload

  """Deletes a single `LanguageCountry` using a unique key."""
  deleteLanguageCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageCountryInput!
  ): DeleteLanguageCountryPayload

  """Deletes a single `LanguageCountry` using its globally unique id."""
  deleteLanguageCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageCountryByNodeIdInput!
  ): DeleteLanguageCountryPayload

  """Deletes a single `Meta` using a unique key."""
  deleteMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMetaInput!
  ): DeleteMetaPayload

  """Deletes a single `Meta` using its globally unique id."""
  deleteMetaByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMetaByNodeIdInput!
  ): DeleteMetaPayload

  """Deletes a single `OrganisationInvite` using a unique key."""
  deleteOrganisationInvite(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationInviteInput!
  ): DeleteOrganisationInvitePayload

  """Deletes a single `OrganisationInvite` using a unique key."""
  deleteOrganisationInviteByCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationInviteByCodeInput!
  ): DeleteOrganisationInvitePayload

  """Deletes a single `OrganisationInvite` using its globally unique id."""
  deleteOrganisationInviteByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationInviteByNodeIdInput!
  ): DeleteOrganisationInvitePayload

  """Deletes a single `OrganisationInvite` using a unique key."""
  deleteOrganisationInviteByOrganisationIdAndEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationInviteByOrganisationIdAndEmailInput!
  ): DeleteOrganisationInvitePayload

  """Deletes a single `OrganisationTier` using a unique key."""
  deleteOrganisationTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationTierInput!
  ): DeleteOrganisationTierPayload

  """Deletes a single `OrganisationTier` using a unique key."""
  deleteOrganisationTierByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationTierByNameInput!
  ): DeleteOrganisationTierPayload

  """Deletes a single `OrganisationTier` using its globally unique id."""
  deleteOrganisationTierByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationTierByNodeIdInput!
  ): DeleteOrganisationTierPayload

  """Deletes a single `OrganisationUser` using a unique key."""
  deleteOrganisationUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationUserInput!
  ): DeleteOrganisationUserPayload

  """Deletes a single `OrganisationUser` using its globally unique id."""
  deleteOrganisationUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOrganisationUserByNodeIdInput!
  ): DeleteOrganisationUserPayload

  """Deletes a single `Outlet` using a unique key."""
  deleteOutlet(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutletInput!
  ): DeleteOutletPayload

  """Deletes a single `Outlet` using a unique key."""
  deleteOutletByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutletByNameInput!
  ): DeleteOutletPayload

  """Deletes a single `Outlet` using its globally unique id."""
  deleteOutletByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutletByNodeIdInput!
  ): DeleteOutletPayload

  """Deletes a single `OutletCountry` using a unique key."""
  deleteOutletCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutletCountryInput!
  ): DeleteOutletCountryPayload

  """Deletes a single `OutletCountry` using its globally unique id."""
  deleteOutletCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteOutletCountryByNodeIdInput!
  ): DeleteOutletCountryPayload

  """Deletes a single `PartnerPage` using a unique key."""
  deletePartnerPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePartnerPageInput!
  ): DeletePartnerPagePayload

  """Deletes a single `PartnerPage` using its globally unique id."""
  deletePartnerPageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePartnerPageByNodeIdInput!
  ): DeletePartnerPagePayload

  """Deletes a single `PartnerPage` using a unique key."""
  deletePartnerPageBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePartnerPageBySlugInput!
  ): DeletePartnerPagePayload

  """Deletes a single `Place` using a unique key."""
  deletePlace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaceInput!
  ): DeletePlacePayload

  """Deletes a single `Place` using its globally unique id."""
  deletePlaceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlaceByNodeIdInput!
  ): DeletePlacePayload

  """Deletes a single `PromoCodeAffiliate` using a unique key."""
  deletePromoCodeAffiliate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePromoCodeAffiliateInput!
  ): DeletePromoCodeAffiliatePayload

  """Deletes a single `PromoCodeAffiliate` using its globally unique id."""
  deletePromoCodeAffiliateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePromoCodeAffiliateByNodeIdInput!
  ): DeletePromoCodeAffiliatePayload

  """Deletes a single `Region` using a unique key."""
  deleteRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRegionInput!
  ): DeleteRegionPayload

  """Deletes a single `Region` using a unique key."""
  deleteRegionByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRegionByNameInput!
  ): DeleteRegionPayload

  """Deletes a single `Region` using its globally unique id."""
  deleteRegionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRegionByNodeIdInput!
  ): DeleteRegionPayload

  """Deletes a single `Region` using a unique key."""
  deleteRegionBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRegionBySlugInput!
  ): DeleteRegionPayload

  """Deletes a single `Setting` using a unique key."""
  deleteSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSettingInput!
  ): DeleteSettingPayload @deprecated(reason: "Use Trip.appearance")

  """Deletes a single `Setting` using its globally unique id."""
  deleteSettingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSettingByNodeIdInput!
  ): DeleteSettingPayload @deprecated(reason: "Use Trip.appearance")

  """Deletes a single `SubscriptionLog` using a unique key."""
  deleteSubscriptionLog(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSubscriptionLogInput!
  ): DeleteSubscriptionLogPayload

  """Deletes a single `SubscriptionLog` using its globally unique id."""
  deleteSubscriptionLogByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSubscriptionLogByNodeIdInput!
  ): DeleteSubscriptionLogPayload

  """Deletes a single `Supplier` using a unique key."""
  deleteSupplier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSupplierInput!
  ): DeleteSupplierPayload

  """Deletes a single `Supplier` using its globally unique id."""
  deleteSupplierByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSupplierByNodeIdInput!
  ): DeleteSupplierPayload

  """Deletes a single `SupplierCategory` using a unique key."""
  deleteSupplierCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSupplierCategoryInput!
  ): DeleteSupplierCategoryPayload

  """Deletes a single `SupplierCategory` using its globally unique id."""
  deleteSupplierCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSupplierCategoryByNodeIdInput!
  ): DeleteSupplierCategoryPayload

  """Deletes a single `SupplierTag` using a unique key."""
  deleteSupplierTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSupplierTagInput!
  ): DeleteSupplierTagPayload

  """Deletes a single `SupplierTag` using its globally unique id."""
  deleteSupplierTagByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSupplierTagByNodeIdInput!
  ): DeleteSupplierTagPayload

  """Deletes a single `Tag` using a unique key."""
  deleteTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagInput!
  ): DeleteTagPayload

  """Deletes a single `Tag` using a unique key."""
  deleteTagByNameAndTypeAndOrganisationId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagByNameAndTypeAndOrganisationIdInput!
  ): DeleteTagPayload

  """Deletes a single `Tag` using its globally unique id."""
  deleteTagByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagByNodeIdInput!
  ): DeleteTagPayload

  """Deletes a single `TagTrip` using a unique key."""
  deleteTagTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagTripInput!
  ): DeleteTagTripPayload

  """Deletes a single `TagTrip` using its globally unique id."""
  deleteTagTripByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTagTripByNodeIdInput!
  ): DeleteTagTripPayload

  """Deletes a single `Task` using a unique key."""
  deleteTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaskInput!
  ): DeleteTaskPayload

  """Deletes a single `Task` using its globally unique id."""
  deleteTaskByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTaskByNodeIdInput!
  ): DeleteTaskPayload

  """Deletes a single `Trip` using a unique key."""
  deleteTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripInput!
  ): DeleteTripPayload

  """Deletes a single `TripAssetImage` using a unique key."""
  deleteTripAssetImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripAssetImageInput!
  ): DeleteTripAssetImagePayload

  """Deletes a single `TripAssetImage` using its globally unique id."""
  deleteTripAssetImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripAssetImageByNodeIdInput!
  ): DeleteTripAssetImagePayload

  """Deletes a single `Trip` using its globally unique id."""
  deleteTripByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripByNodeIdInput!
  ): DeleteTripPayload

  """Deletes a single `TripCountry` using a unique key."""
  deleteTripCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripCountryInput!
  ): DeleteTripCountryPayload

  """Deletes a single `TripCountry` using its globally unique id."""
  deleteTripCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripCountryByNodeIdInput!
  ): DeleteTripCountryPayload

  """Deletes a single `TripRegion` using a unique key."""
  deleteTripRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripRegionInput!
  ): DeleteTripRegionPayload

  """Deletes a single `TripRegion` using its globally unique id."""
  deleteTripRegionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTripRegionByNodeIdInput!
  ): DeleteTripRegionPayload
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Marks the user as not affiliate"""
  disableAffiliate(userId: UUID!): Boolean

  """
  Duplicates the selected card. Will throw `card_not_found` if ID is incorrect or card is archived.
  """
  duplicate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DuplicateInput!
  ): DuplicatePayload

  """
  Marks the user as affiliate, emails a link to Stripe on-board if necessary
  """
  enableAffiliate(userId: UUID!): Boolean
  forceTripUpdate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ForceTripUpdateInput!
  ): ForceTripUpdatePayload
  getSubscriptionHistory(userId: UUID!): JSON
  impersonate(id: UUID!): Boolean!

  """
  Accept the trip invite. Will be accepted by the currently authenticated user (if they're not already a collaborator).
  """
  inviteAccept(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InviteAcceptInput!
  ): InviteAcceptPayload

  """
  Create an invite code for the given trip ID with the given permissions and send to email
  """
  inviteCreate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InviteCreateInput!
  ): InviteCreatePayload
  invitePurge(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InvitePurgeInput!
  ): InvitePurgePayload
  inviteRevoke(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InviteRevokeInput!
  ): InviteRevokePayload
  inviteSendEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InviteSendEmailInput!
  ): InviteSendEmailPayload

  """Log out the user. Deletes the token or cookie session accordingly."""
  logout(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: LogoutInput
  ): LogoutPayload
  manageSubscription(referrer: String!): String

  """
  Move the card to a new position. Will throw `card_not_found` if ID is incorrect or card is archived.
  """
  move(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MoveInput!
  ): MovePayload

  """Move all cards in the given column to a new position."""
  moveColumn(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: MoveColumnInput!
  ): MoveColumnPayload
  organisationAccept(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: OrganisationAcceptInput!
  ): OrganisationAcceptPayload

  """Accepts an organisation invite and registers an agent"""
  organisationRegisterAndAccept(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: OrganisationRegisterAndAcceptInput!
  ): AuthenticatePayload!
  pay(cancelUrl: String!, price: String!, trip: UUID!): String!
  promoCodeApply(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: PromoCodeApplyInput!
  ): PromoCodeApplyPayload
  proposalRespond(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ProposalRespondInput!
  ): ProposalRespondPayload
  queueJob(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: QueueJobInput!
  ): QueueJobPayload

  """Registers a user"""
  register(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RegisterInput!
  ): AuthenticatePayload!
  releaseLock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ReleaseLockInput!
  ): ReleaseLockPayload
  removeExpoPushToken(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RemoveExpoPushTokenInput!
  ): RemoveExpoPushTokenPayload
  requestPasswordReset(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RequestPasswordResetInput!
  ): RequestPasswordResetPayload
  resendOrgInviteEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ResendOrgInviteEmailInput!
  ): ResendOrgInviteEmailPayload
  resendVerification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ResendVerificationInput!
  ): ResendVerificationPayload

  """For use when resetting a **FORGOTTEN** password"""
  resetPassword(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ResetPasswordInput!
  ): ResetPasswordPayload
  saveAttachmentVisibilitySettings(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: SaveAttachmentVisibilitySettingsInput!
  ): SaveAttachmentVisibilitySettingsPayload
  saveTripAppearance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: SaveTripAppearanceInput!
  ): SaveTripAppearancePayload
  sendProposal(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: SendProposalInput!
  ): SendProposalPayload
  setCollaboratorRole(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: SetCollaboratorRoleInput!
  ): SetCollaboratorRolePayload

  """For use when **CHANGING** a password"""
  setPassword(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: SetPasswordInput!
  ): SetPasswordPayload

  """Sorts all the cards in the given column by start time."""
  sortByTime(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: SortByTimeInput!
  ): SortByTimePayload
  subscribe(price: String!, referrer: String!): String!

  """Switch active organisation. Can be null to switch to personal account."""
  switchOrganisation(id: UUID): Query
  toggleAttachmentVisibility(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: ToggleAttachmentVisibilityInput!
  ): ToggleAttachmentVisibilityPayload
  transferOrganisationOwnership(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TransferOrganisationOwnershipInput!
  ): TransferOrganisationOwnershipPayload
  tripClearCountryRelations(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TripClearCountryRelationsInput!
  ): TripClearCountryRelationsPayload
  tripClearImageRelations(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TripClearImageRelationsInput!
  ): TripClearImageRelationsPayload
  tripClearRegionRelations(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TripClearRegionRelationsInput!
  ): TripClearRegionRelationsPayload
  tripClearTagRelations(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: TripClearTagRelationsInput!
  ): TripClearTagRelationsPayload

  """Updates a single `Account` using a unique key and a patch."""
  updateAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountInput!
  ): UpdateAccountPayload

  """Updates a single `Account` using a unique key and a patch."""
  updateAccountByEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByEmailInput!
  ): UpdateAccountPayload

  """Updates a single `Account` using its globally unique id and a patch."""
  updateAccountByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByNodeIdInput!
  ): UpdateAccountPayload

  """Updates a single `Account` using a unique key and a patch."""
  updateAccountByStripeCustomerId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByStripeCustomerIdInput!
  ): UpdateAccountPayload
  updateAssetAttribution(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAssetAttributionInput!
  ): UpdateAssetAttributionPayload

  """Updates a single `Card` using a unique key and a patch."""
  updateCard(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCardInput!
  ): UpdateCardPayload

  """Updates a single `Card` using its globally unique id and a patch."""
  updateCardByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCardByNodeIdInput!
  ): UpdateCardPayload

  """Updates a single `CardCost` using a unique key and a patch."""
  updateCardCost(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCardCostInput!
  ): UpdateCardCostPayload

  """Updates a single `CardCost` using a unique key and a patch."""
  updateCardCostByCardId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCardCostByCardIdInput!
  ): UpdateCardCostPayload

  """Updates a single `CardCost` using its globally unique id and a patch."""
  updateCardCostByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCardCostByNodeIdInput!
  ): UpdateCardCostPayload

  """Updates a single `Client` using a unique key and a patch."""
  updateClient(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientInput!
  ): UpdateClientPayload

  """Updates a single `Client` using its globally unique id and a patch."""
  updateClientByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientByNodeIdInput!
  ): UpdateClientPayload

  """Updates a single `ClientOrganisation` using a unique key and a patch."""
  updateClientOrganisation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientOrganisationInput!
  ): UpdateClientOrganisationPayload

  """
  Updates a single `ClientOrganisation` using its globally unique id and a patch.
  """
  updateClientOrganisationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientOrganisationByNodeIdInput!
  ): UpdateClientOrganisationPayload

  """
  Updates a single `ClientOrganisationContact` using a unique key and a patch.
  """
  updateClientOrganisationContact(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientOrganisationContactInput!
  ): UpdateClientOrganisationContactPayload

  """
  Updates a single `ClientOrganisationContact` using its globally unique id and a patch.
  """
  updateClientOrganisationContactByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientOrganisationContactByNodeIdInput!
  ): UpdateClientOrganisationContactPayload

  """Updates a single `ClientPerson` using a unique key and a patch."""
  updateClientPerson(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientPersonInput!
  ): UpdateClientPersonPayload

  """
  Updates a single `ClientPerson` using its globally unique id and a patch.
  """
  updateClientPersonByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateClientPersonByNodeIdInput!
  ): UpdateClientPersonPayload

  """Updates a single `Continent` using a unique key and a patch."""
  updateContinent(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContinentInput!
  ): UpdateContinentPayload

  """Updates a single `Continent` using a unique key and a patch."""
  updateContinentByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContinentByNameInput!
  ): UpdateContinentPayload

  """Updates a single `Continent` using its globally unique id and a patch."""
  updateContinentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContinentByNodeIdInput!
  ): UpdateContinentPayload

  """Updates a single `CostItem` using a unique key and a patch."""
  updateCostItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCostItemInput!
  ): UpdateCostItemPayload

  """Updates a single `CostItem` using its globally unique id and a patch."""
  updateCostItemByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCostItemByNodeIdInput!
  ): UpdateCostItemPayload

  """Updates a single `CostTax` using a unique key and a patch."""
  updateCostTax(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCostTaxInput!
  ): UpdateCostTaxPayload

  """Updates a single `CostTax` using its globally unique id and a patch."""
  updateCostTaxByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCostTaxByNodeIdInput!
  ): UpdateCostTaxPayload

  """Updates a single `Country` using a unique key and a patch."""
  updateCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryInput!
  ): UpdateCountryPayload

  """Updates a single `Country` using a unique key and a patch."""
  updateCountryByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryByNameInput!
  ): UpdateCountryPayload

  """Updates a single `Country` using its globally unique id and a patch."""
  updateCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryByNodeIdInput!
  ): UpdateCountryPayload

  """Updates a single `Country` using a unique key and a patch."""
  updateCountryBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryBySlugInput!
  ): UpdateCountryPayload

  """Updates a single `Currency` using a unique key and a patch."""
  updateCurrency(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyInput!
  ): UpdateCurrencyPayload

  """Updates a single `Currency` using a unique key and a patch."""
  updateCurrencyByIso(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyByIsoInput!
  ): UpdateCurrencyPayload

  """Updates a single `Currency` using a unique key and a patch."""
  updateCurrencyByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyByNameInput!
  ): UpdateCurrencyPayload

  """Updates a single `Currency` using its globally unique id and a patch."""
  updateCurrencyByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyByNodeIdInput!
  ): UpdateCurrencyPayload

  """Updates a single `CurrencyCountry` using a unique key and a patch."""
  updateCurrencyCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyCountryInput!
  ): UpdateCurrencyCountryPayload

  """
  Updates a single `CurrencyCountry` using its globally unique id and a patch.
  """
  updateCurrencyCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCurrencyCountryByNodeIdInput!
  ): UpdateCurrencyCountryPayload

  """Updates a single `Grati` using a unique key and a patch."""
  updateGrati(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGratiInput!
  ): UpdateGratiPayload @deprecated(reason: "Use Promo Codes")

  """Updates a single `Grati` using its globally unique id and a patch."""
  updateGratiByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGratiByNodeIdInput!
  ): UpdateGratiPayload @deprecated(reason: "Use Promo Codes")

  """Updates a single `GratisUsed` using a unique key and a patch."""
  updateGratisUsed(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGratisUsedInput!
  ): UpdateGratisUsedPayload

  """
  Updates a single `GratisUsed` using its globally unique id and a patch.
  """
  updateGratisUsedByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateGratisUsedByNodeIdInput!
  ): UpdateGratisUsedPayload

  """Updates a single `Language` using a unique key and a patch."""
  updateLanguage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageInput!
  ): UpdateLanguagePayload

  """Updates a single `Language` using a unique key and a patch."""
  updateLanguageByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageByNameInput!
  ): UpdateLanguagePayload

  """Updates a single `Language` using its globally unique id and a patch."""
  updateLanguageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageByNodeIdInput!
  ): UpdateLanguagePayload

  """Updates a single `LanguageCountry` using a unique key and a patch."""
  updateLanguageCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageCountryInput!
  ): UpdateLanguageCountryPayload

  """
  Updates a single `LanguageCountry` using its globally unique id and a patch.
  """
  updateLanguageCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageCountryByNodeIdInput!
  ): UpdateLanguageCountryPayload

  """Updates a single `Meta` using a unique key and a patch."""
  updateMeta(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMetaInput!
  ): UpdateMetaPayload

  """Updates a single `Meta` using its globally unique id and a patch."""
  updateMetaByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMetaByNodeIdInput!
  ): UpdateMetaPayload

  """Updates a single `Organisation` using a unique key and a patch."""
  updateOrganisation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrganisationInput!
  ): UpdateOrganisationPayload

  """
  Updates a single `Organisation` using its globally unique id and a patch.
  """
  updateOrganisationByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrganisationByNodeIdInput!
  ): UpdateOrganisationPayload

  """Updates a single `OrganisationTier` using a unique key and a patch."""
  updateOrganisationTier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrganisationTierInput!
  ): UpdateOrganisationTierPayload

  """Updates a single `OrganisationTier` using a unique key and a patch."""
  updateOrganisationTierByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrganisationTierByNameInput!
  ): UpdateOrganisationTierPayload

  """
  Updates a single `OrganisationTier` using its globally unique id and a patch.
  """
  updateOrganisationTierByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOrganisationTierByNodeIdInput!
  ): UpdateOrganisationTierPayload

  """Updates a single `Outlet` using a unique key and a patch."""
  updateOutlet(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutletInput!
  ): UpdateOutletPayload

  """Updates a single `Outlet` using a unique key and a patch."""
  updateOutletByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutletByNameInput!
  ): UpdateOutletPayload

  """Updates a single `Outlet` using its globally unique id and a patch."""
  updateOutletByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutletByNodeIdInput!
  ): UpdateOutletPayload

  """Updates a single `OutletCountry` using a unique key and a patch."""
  updateOutletCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutletCountryInput!
  ): UpdateOutletCountryPayload

  """
  Updates a single `OutletCountry` using its globally unique id and a patch.
  """
  updateOutletCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateOutletCountryByNodeIdInput!
  ): UpdateOutletCountryPayload

  """Updates a single `PartnerPage` using a unique key and a patch."""
  updatePartnerPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePartnerPageInput!
  ): UpdatePartnerPagePayload

  """
  Updates a single `PartnerPage` using its globally unique id and a patch.
  """
  updatePartnerPageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePartnerPageByNodeIdInput!
  ): UpdatePartnerPagePayload

  """Updates a single `PartnerPage` using a unique key and a patch."""
  updatePartnerPageBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePartnerPageBySlugInput!
  ): UpdatePartnerPagePayload

  """Updates a single `Place` using a unique key and a patch."""
  updatePlace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaceInput!
  ): UpdatePlacePayload

  """Updates a single `Place` using its globally unique id and a patch."""
  updatePlaceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlaceByNodeIdInput!
  ): UpdatePlacePayload

  """Updates a single `PromoCode` using a unique key and a patch."""
  updatePromoCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePromoCodeInput!
  ): UpdatePromoCodePayload

  """Updates a single `PromoCodeAffiliate` using a unique key and a patch."""
  updatePromoCodeAffiliate(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePromoCodeAffiliateInput!
  ): UpdatePromoCodeAffiliatePayload

  """
  Updates a single `PromoCodeAffiliate` using its globally unique id and a patch.
  """
  updatePromoCodeAffiliateByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePromoCodeAffiliateByNodeIdInput!
  ): UpdatePromoCodeAffiliatePayload

  """Updates a single `PromoCode` using a unique key and a patch."""
  updatePromoCodeByCode(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePromoCodeByCodeInput!
  ): UpdatePromoCodePayload

  """Updates a single `PromoCode` using its globally unique id and a patch."""
  updatePromoCodeByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePromoCodeByNodeIdInput!
  ): UpdatePromoCodePayload

  """Updates a single `Region` using a unique key and a patch."""
  updateRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRegionInput!
  ): UpdateRegionPayload

  """Updates a single `Region` using a unique key and a patch."""
  updateRegionByName(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRegionByNameInput!
  ): UpdateRegionPayload

  """Updates a single `Region` using its globally unique id and a patch."""
  updateRegionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRegionByNodeIdInput!
  ): UpdateRegionPayload

  """Updates a single `Region` using a unique key and a patch."""
  updateRegionBySlug(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRegionBySlugInput!
  ): UpdateRegionPayload

  """Updates a single `Setting` using a unique key and a patch."""
  updateSetting(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSettingInput!
  ): UpdateSettingPayload @deprecated(reason: "Use Trip.appearance")

  """Updates a single `Setting` using its globally unique id and a patch."""
  updateSettingByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSettingByNodeIdInput!
  ): UpdateSettingPayload @deprecated(reason: "Use Trip.appearance")

  """Updates a single `SubscriptionLog` using a unique key and a patch."""
  updateSubscriptionLog(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSubscriptionLogInput!
  ): UpdateSubscriptionLogPayload

  """
  Updates a single `SubscriptionLog` using its globally unique id and a patch.
  """
  updateSubscriptionLogByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSubscriptionLogByNodeIdInput!
  ): UpdateSubscriptionLogPayload

  """Updates a single `Supplier` using a unique key and a patch."""
  updateSupplier(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSupplierInput!
  ): UpdateSupplierPayload

  """Updates a single `Supplier` using its globally unique id and a patch."""
  updateSupplierByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSupplierByNodeIdInput!
  ): UpdateSupplierPayload

  """Updates a single `SupplierCategory` using a unique key and a patch."""
  updateSupplierCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSupplierCategoryInput!
  ): UpdateSupplierCategoryPayload

  """
  Updates a single `SupplierCategory` using its globally unique id and a patch.
  """
  updateSupplierCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSupplierCategoryByNodeIdInput!
  ): UpdateSupplierCategoryPayload
  updateSupplierTags(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSupplierTagsInput!
  ): UpdateSupplierTagsPayload

  """Updates a single `Tag` using a unique key and a patch."""
  updateTag(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagInput!
  ): UpdateTagPayload

  """Updates a single `Tag` using a unique key and a patch."""
  updateTagByNameAndTypeAndOrganisationId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagByNameAndTypeAndOrganisationIdInput!
  ): UpdateTagPayload

  """Updates a single `Tag` using its globally unique id and a patch."""
  updateTagByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagByNodeIdInput!
  ): UpdateTagPayload

  """Updates a single `TagTrip` using a unique key and a patch."""
  updateTagTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagTripInput!
  ): UpdateTagTripPayload

  """Updates a single `TagTrip` using its globally unique id and a patch."""
  updateTagTripByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTagTripByNodeIdInput!
  ): UpdateTagTripPayload

  """Updates a single `Task` using a unique key and a patch."""
  updateTask(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaskInput!
  ): UpdateTaskPayload

  """Updates a single `Task` using its globally unique id and a patch."""
  updateTaskByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTaskByNodeIdInput!
  ): UpdateTaskPayload

  """Updates a single `Trip` using a unique key and a patch."""
  updateTrip(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripInput!
  ): UpdateTripPayload

  """Updates a single `TripAssetImage` using a unique key and a patch."""
  updateTripAssetImage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripAssetImageInput!
  ): UpdateTripAssetImagePayload

  """
  Updates a single `TripAssetImage` using its globally unique id and a patch.
  """
  updateTripAssetImageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripAssetImageByNodeIdInput!
  ): UpdateTripAssetImagePayload

  """Updates a single `Trip` using its globally unique id and a patch."""
  updateTripByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripByNodeIdInput!
  ): UpdateTripPayload

  """Updates a single `TripCountry` using a unique key and a patch."""
  updateTripCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripCountryInput!
  ): UpdateTripCountryPayload

  """
  Updates a single `TripCountry` using its globally unique id and a patch.
  """
  updateTripCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripCountryByNodeIdInput!
  ): UpdateTripCountryPayload

  """Updates a single `TripRegion` using a unique key and a patch."""
  updateTripRegion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripRegionInput!
  ): UpdateTripRegionPayload

  """
  Updates a single `TripRegion` using its globally unique id and a patch.
  """
  updateTripRegionByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripRegionByNodeIdInput!
  ): UpdateTripRegionPayload
  updateTripTags(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTripTagsInput!
  ): UpdateTripTagsPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUserByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByNodeIdInput!
  ): UpdateUserPayload

  """Updates a single `UserPreference` using a unique key and a patch."""
  updateUserPreference(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserPreferenceInput!
  ): UpdateUserPreferencePayload

  """
  Updates a single `UserPreference` using its globally unique id and a patch.
  """
  updateUserPreferenceByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserPreferenceByNodeIdInput!
  ): UpdateUserPreferencePayload
  verify(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: VerifyInput!
  ): VerifyPayload
  verifySubscription(
    """`transactionReceipt` for ios, `purchaseToken` for android"""
    identifier: String!
    origin: SubscriptionOrigin!

    """**Android Only**"""
    packageName: String

    """**Android Only**"""
    subscriptionId: String
  ): Boolean!
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

enum OauthProvider {
  APPLE
  GOOGLE
}

type Organisation implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads and enables pagination through a set of `Client`."""
  clients(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientsConnection!

  """Reads and enables pagination through a set of `Client`."""
  clientsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!]
  ): [Client!]!

  """Reads and enables pagination through a set of `CostItem`."""
  costItems(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsConnection!

  """Reads and enables pagination through a set of `CostItem`."""
  costItemsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostItemCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostItemFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!]
  ): [CostItem!]!

  """Reads a single `CostTax` that is related to this `Organisation`."""
  costTax: CostTax
  costTaxId: UUID

  """Reads and enables pagination through a set of `CostTax`."""
  costTaxes(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostTaxCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostTaxFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostTaxesConnection!

  """Reads and enables pagination through a set of `CostTax`."""
  costTaxesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostTaxCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostTaxFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!]
  ): [CostTax!]!
  costType: CostType!

  """Reads a single `Country` that is related to this `Organisation`."""
  country: Country
  countryId: UUID

  """When this item was created"""
  createdAt: Datetime

  """Reads a single `Currency` that is related to this `Organisation`."""
  currency: Currency
  currencyId: UUID
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Is the current viewer an owner of this organisation"""
  isOwner: Boolean
  itineraryCap: Int

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int

  """Reads a single `Asset` that is related to this `Organisation`."""
  logo: Asset
  logoId: UUID

  """Reads and enables pagination through a set of `Meta`."""
  metas(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasConnection!

  """Reads and enables pagination through a set of `Meta`."""
  metasList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]
  ): [Meta!]!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `OrganisationInvite`."""
  organisationInvites(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationInviteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationInviteFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationInvitesConnection!

  """Reads and enables pagination through a set of `OrganisationInvite`."""
  organisationInvitesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationInviteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationInviteFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!]
  ): [OrganisationInvite!]!
  owner: User
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """When this item was restored"""
  restoredAt: Datetime

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String

  """Reads and enables pagination through a set of `Supplier`."""
  suppliers(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersConnection!

  """Reads and enables pagination through a set of `Supplier`."""
  suppliersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!]
  ): [Supplier!]!

  """Reads and enables pagination through a set of `Tag`."""
  tags(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsConnection!

  """Reads and enables pagination through a set of `Tag`."""
  tagsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!]
  ): [Tag!]!
  templateCap: Int

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tier: OrganisationTier
  tierId: UUID

  """Reads and enables pagination through a set of `Trip`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]!

  """When this item was updated"""
  updatedAt: Datetime

  """Reads and enables pagination through a set of `OrganisationUser`."""
  users(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationUserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OrganisationUser`."""
    orderBy: [OrganisationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationUsersConnection!

  """Reads and enables pagination through a set of `OrganisationUser`."""
  usersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationUserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OrganisationUser`."""
    orderBy: [OrganisationUsersOrderBy!]
  ): [OrganisationUser!]!
}

"""All input for the `organisationAccept` mutation."""
input OrganisationAcceptInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!
}

"""The output of our `organisationAccept` mutation."""
type OrganisationAcceptPayload {
  boolean: Boolean

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A condition to be used against `Organisation` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OrganisationCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `costTaxId` field."""
  costTaxId: UUID

  """Checks for equality with the object’s `costType` field."""
  costType: CostType

  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `currencyId` field."""
  currencyId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `itineraryCapAdditional` field."""
  itineraryCapAdditional: Int

  """Checks for equality with the object’s `logoId` field."""
  logoId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `phone` field."""
  phone: String

  """Checks for equality with the object’s `primaryColour` field."""
  primaryColour: String

  """Checks for equality with the object’s `proposalDefaultMessage` field."""
  proposalDefaultMessage: String

  """Checks for equality with the object’s `requireTermsAcceptance` field."""
  requireTermsAcceptance: Boolean

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `secondaryColour` field."""
  secondaryColour: String

  """Checks for equality with the object’s `supplierDefaultMessage` field."""
  supplierDefaultMessage: String

  """Checks for equality with the object’s `templateCapAdditional` field."""
  templateCapAdditional: Int

  """Checks for equality with the object’s `terms` field."""
  terms: String

  """Checks for equality with the object’s `tierId` field."""
  tierId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""The `costTax` to be created by this mutation."""
input OrganisationCostTaxIdFkeyCostTaxCreateInput {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID
  name: String!
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float!
}

"""
Input for the nested mutation of `costTax` in the `OrganisationInput` mutation.
"""
input OrganisationCostTaxIdFkeyInput {
  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectById: CostTaxCostTaxPkeyConnect

  """The primary key(s) for `costTax` for the far side of the relationship."""
  connectByNodeId: CostTaxNodeIdConnect

  """
  A `CostTaxInput` object that will be created and connected to this object.
  """
  create: OrganisationCostTaxIdFkeyCostTaxCreateInput

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteById: CostTaxCostTaxPkeyDelete

  """The primary key(s) for `costTax` for the far side of the relationship."""
  deleteByNodeId: CostTaxNodeIdDelete

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateById: CostTaxOnOrganisationForOrganisationCostTaxIdFkeyUsingCostTaxPkeyUpdate

  """
  The primary key(s) and patch data for `costTax` for the far side of the relationship.
  """
  updateByNodeId: OrganisationOnOrganisationForOrganisationCostTaxIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisation` in the `CostTaxInput` mutation.
"""
input OrganisationCostTaxIdFkeyInverseInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: [OrganisationOrganisationPkeyConnect!]

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationNodeIdConnect!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: [OrganisationOnOrganisationForOrganisationCostTaxIdFkeyUsingOrganisationPkeyUpdate!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: [CostTaxOnOrganisationForOrganisationCostTaxIdFkeyNodeIdUpdate!]
}

"""The `country` to be created by this mutation."""
input OrganisationCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `OrganisationInput` mutation.
"""
input OrganisationCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: OrganisationCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnOrganisationForOrganisationCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnOrganisationForOrganisationCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: OrganisationOnOrganisationForOrganisationCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnOrganisationForOrganisationCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `organisation` in the `CountryInput` mutation.
"""
input OrganisationCountryIdFkeyInverseInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: [OrganisationOrganisationPkeyConnect!]

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationNodeIdConnect!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: [OrganisationOnOrganisationForOrganisationCountryIdFkeyUsingOrganisationPkeyUpdate!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnOrganisationForOrganisationCountryIdFkeyNodeIdUpdate!]
}

"""The `currency` to be created by this mutation."""
input OrganisationCurrencyIdFkeyCurrencyCreateInput {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
Input for the nested mutation of `currency` in the `OrganisationInput` mutation.
"""
input OrganisationCurrencyIdFkeyInput {
  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectById: CurrencyCurrencyPkeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByIso: CurrencyCurrencyIsoKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByName: CurrencyCurrencyNameKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByNodeId: CurrencyNodeIdConnect

  """
  A `CurrencyInput` object that will be created and connected to this object.
  """
  create: OrganisationCurrencyIdFkeyCurrencyCreateInput

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteById: CurrencyCurrencyPkeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByIso: CurrencyCurrencyIsoKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByName: CurrencyCurrencyNameKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByNodeId: CurrencyNodeIdDelete

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateById: CurrencyOnOrganisationForOrganisationCurrencyIdFkeyUsingCurrencyPkeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByIso: CurrencyOnOrganisationForOrganisationCurrencyIdFkeyUsingCurrencyIsoKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByName: CurrencyOnOrganisationForOrganisationCurrencyIdFkeyUsingCurrencyNameKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByNodeId: OrganisationOnOrganisationForOrganisationCurrencyIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisation` in the `CurrencyInput` mutation.
"""
input OrganisationCurrencyIdFkeyInverseInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: [OrganisationOrganisationPkeyConnect!]

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationNodeIdConnect!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: [OrganisationOnOrganisationForOrganisationCurrencyIdFkeyUsingOrganisationPkeyUpdate!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: [CurrencyOnOrganisationForOrganisationCurrencyIdFkeyNodeIdUpdate!]
}

"""
A filter to be used against `Organisation` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationFilter {
  """Checks for all expressions in this list."""
  and: [OrganisationFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `clients` relation."""
  clients: OrganisationToManyClientFilter

  """Some related `clients` exist."""
  clientsExist: Boolean

  """Filter by the object’s `costItems` relation."""
  costItems: OrganisationToManyCostItemFilter

  """Some related `costItems` exist."""
  costItemsExist: Boolean

  """Filter by the object’s `costTax` relation."""
  costTax: CostTaxFilter

  """A related `costTax` exists."""
  costTaxExists: Boolean

  """Filter by the object’s `costTaxId` field."""
  costTaxId: UUIDFilter

  """Filter by the object’s `costTaxes` relation."""
  costTaxes: OrganisationToManyCostTaxFilter

  """Some related `costTaxes` exist."""
  costTaxesExist: Boolean

  """Filter by the object’s `costType` field."""
  costType: CostTypeFilter

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """A related `country` exists."""
  countryExists: Boolean

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `currency` relation."""
  currency: CurrencyFilter

  """A related `currency` exists."""
  currencyExists: Boolean

  """Filter by the object’s `currencyId` field."""
  currencyId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `isOwner` field."""
  isOwner: BooleanFilter

  """Filter by the object’s `itineraryCap` field."""
  itineraryCap: IntFilter

  """Filter by the object’s `itineraryCapAdditional` field."""
  itineraryCapAdditional: IntFilter

  """Filter by the object’s `logo` relation."""
  logo: AssetFilter

  """A related `logo` exists."""
  logoExists: Boolean

  """Filter by the object’s `logoId` field."""
  logoId: UUIDFilter

  """Filter by the object’s `metas` relation."""
  metas: OrganisationToManyMetaFilter

  """Some related `metas` exist."""
  metasExist: Boolean

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: OrganisationFilter

  """Checks for any expressions in this list."""
  or: [OrganisationFilter!]

  """Filter by the object’s `organisationInvites` relation."""
  organisationInvites: OrganisationToManyOrganisationInviteFilter

  """Some related `organisationInvites` exist."""
  organisationInvitesExist: Boolean

  """Filter by the object’s `phone` field."""
  phone: StringFilter

  """Filter by the object’s `primaryColour` field."""
  primaryColour: StringFilter

  """Filter by the object’s `proposalDefaultMessage` field."""
  proposalDefaultMessage: StringFilter

  """Filter by the object’s `requireTermsAcceptance` field."""
  requireTermsAcceptance: BooleanFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `secondaryColour` field."""
  secondaryColour: StringFilter

  """Filter by the object’s `supplierDefaultMessage` field."""
  supplierDefaultMessage: StringFilter

  """Filter by the object’s `suppliers` relation."""
  suppliers: OrganisationToManySupplierFilter

  """Some related `suppliers` exist."""
  suppliersExist: Boolean

  """Filter by the object’s `tags` relation."""
  tags: OrganisationToManyTagFilter

  """Some related `tags` exist."""
  tagsExist: Boolean

  """Filter by the object’s `templateCap` field."""
  templateCap: IntFilter

  """Filter by the object’s `templateCapAdditional` field."""
  templateCapAdditional: IntFilter

  """Filter by the object’s `terms` field."""
  terms: StringFilter

  """Filter by the object’s `tierId` field."""
  tierId: UUIDFilter

  """Filter by the object’s `trips` relation."""
  trips: OrganisationToManyTripFilter

  """Some related `trips` exist."""
  tripsExist: Boolean

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `users` relation."""
  users: OrganisationToManyOrganisationUserFilter

  """Some related `users` exist."""
  usersExist: Boolean
}

type OrganisationInvite implements Node {
  code: String

  """When this item was created"""
  createdAt: Datetime
  email: String!
  id: UUID!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Organisation` that is related to this `OrganisationInvite`.
  """
  organisation: Organisation
  organisationId: UUID

  """When this item was updated"""
  updatedAt: Datetime

  """Reads a single `User` that is related to this `OrganisationInvite`."""
  user: User
  userId: UUID
}

"""
A condition to be used against `OrganisationInvite` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OrganisationInviteCondition {
  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `OrganisationInvite` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationInviteFilter {
  """Checks for all expressions in this list."""
  and: [OrganisationInviteFilter!]

  """Filter by the object’s `code` field."""
  code: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: OrganisationInviteFilter

  """Checks for any expressions in this list."""
  or: [OrganisationInviteFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """A related `organisation` exists."""
  organisationExists: Boolean

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `OrganisationInvite`"""
input OrganisationInviteInput {
  code: String
  email: String!
  id: UUID
  name: String!
  organisation: OrganisationInviteOrganisationIdFkeyInput
  organisationId: UUID
  user: OrganisationInviteUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input OrganisationInviteNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `organisationInvite` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input OrganisationInviteNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `organisationInvite` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `organisationInvite` to look up the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationInviteCodeKeyUpdate {
  code: String!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: updateOrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyPatch!
}

"""The fields on `organisationInvite` to look up the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationInviteOrganisationIdEmailKeyUpdate {
  email: String!
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: updateOrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyPatch!
}

"""The fields on `organisationInvite` to look up the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationInvitePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: updateOrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `organisationInvite` to look up the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingOrganisationInviteCodeKeyUpdate {
  code: String!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: updateOrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyPatch!
}

"""The fields on `organisationInvite` to look up the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingOrganisationInviteOrganisationIdEmailKeyUpdate {
  email: String!
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: updateOrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyPatch!
}

"""The fields on `organisationInvite` to look up the row to update."""
input OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingOrganisationInvitePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: updateOrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyPatch!
}

"""
Input for the nested mutation of `organisation` in the `OrganisationInviteInput` mutation.
"""
input OrganisationInviteOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisationInvite` in the `OrganisationInput` mutation.
"""
input OrganisationInviteOrganisationIdFkeyInverseInput {
  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectByCode: [OrganisationInviteOrganisationInviteCodeKeyConnect!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectById: [OrganisationInviteOrganisationInvitePkeyConnect!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationInviteNodeIdConnect!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectByOrganisationIdAndEmail: [OrganisationInviteOrganisationInviteOrganisationIdEmailKeyConnect!]

  """
  A `OrganisationInviteInput` object that will be created and connected to this object.
  """
  create: [OrganisationInviteOrganisationIdFkeyOrganisationInviteCreateInput!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteByCode: [OrganisationInviteOrganisationInviteCodeKeyDelete!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteById: [OrganisationInviteOrganisationInvitePkeyDelete!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteByNodeId: [OrganisationInviteNodeIdDelete!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteByOrganisationIdAndEmail: [OrganisationInviteOrganisationInviteOrganisationIdEmailKeyDelete!]

  """
  Flag indicating whether all other `organisationInvite` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateByCode: [OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationInviteCodeKeyUpdate!]

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateById: [OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationInvitePkeyUpdate!]

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateByOrganisationIdAndEmail: [OrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationInviteOrganisationIdEmailKeyUpdate!]
}

"""The `organisationInvite` to be created by this mutation."""
input OrganisationInviteOrganisationIdFkeyOrganisationInviteCreateInput {
  code: String
  email: String!
  id: UUID
  name: String!
  organisation: OrganisationInviteOrganisationIdFkeyInput
  organisationId: UUID
  user: OrganisationInviteUserIdFkeyInput
  userId: UUID
}

"""The fields on `organisationInvite` to look up the row to connect."""
input OrganisationInviteOrganisationInviteCodeKeyConnect {
  code: String!
}

"""The fields on `organisationInvite` to look up the row to delete."""
input OrganisationInviteOrganisationInviteCodeKeyDelete {
  code: String!
}

"""The fields on `organisationInvite` to look up the row to connect."""
input OrganisationInviteOrganisationInviteOrganisationIdEmailKeyConnect {
  email: String!
  organisationId: UUID!
}

"""The fields on `organisationInvite` to look up the row to delete."""
input OrganisationInviteOrganisationInviteOrganisationIdEmailKeyDelete {
  email: String!
  organisationId: UUID!
}

"""The fields on `organisationInvite` to look up the row to connect."""
input OrganisationInviteOrganisationInvitePkeyConnect {
  id: UUID!
}

"""The fields on `organisationInvite` to look up the row to delete."""
input OrganisationInviteOrganisationInvitePkeyDelete {
  id: UUID!
}

"""
Represents an update to a `OrganisationInvite`. Fields that are set will be updated.
"""
input OrganisationInvitePatch {
  code: String
  email: String
  id: UUID
  name: String
  organisation: OrganisationInviteOrganisationIdFkeyInput
  organisationId: UUID
  user: OrganisationInviteUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `user` in the `OrganisationInviteInput` mutation.
"""
input OrganisationInviteUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisationInvite` in the `UserInput` mutation.
"""
input OrganisationInviteUserIdFkeyInverseInput {
  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectByCode: [OrganisationInviteOrganisationInviteCodeKeyConnect!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectById: [OrganisationInviteOrganisationInvitePkeyConnect!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationInviteNodeIdConnect!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  connectByOrganisationIdAndEmail: [OrganisationInviteOrganisationInviteOrganisationIdEmailKeyConnect!]

  """
  A `OrganisationInviteInput` object that will be created and connected to this object.
  """
  create: [OrganisationInviteUserIdFkeyOrganisationInviteCreateInput!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteByCode: [OrganisationInviteOrganisationInviteCodeKeyDelete!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteById: [OrganisationInviteOrganisationInvitePkeyDelete!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteByNodeId: [OrganisationInviteNodeIdDelete!]

  """
  The primary key(s) for `organisationInvite` for the far side of the relationship.
  """
  deleteByOrganisationIdAndEmail: [OrganisationInviteOrganisationInviteOrganisationIdEmailKeyDelete!]

  """
  Flag indicating whether all other `organisationInvite` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateByCode: [OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingOrganisationInviteCodeKeyUpdate!]

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateById: [OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingOrganisationInvitePkeyUpdate!]

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateByNodeId: [UserOnOrganisationInviteForOrganisationInviteUserIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `organisationInvite` for the far side of the relationship.
  """
  updateByOrganisationIdAndEmail: [OrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingOrganisationInviteOrganisationIdEmailKeyUpdate!]
}

"""The `organisationInvite` to be created by this mutation."""
input OrganisationInviteUserIdFkeyOrganisationInviteCreateInput {
  code: String
  email: String!
  id: UUID
  name: String!
  organisation: OrganisationInviteOrganisationIdFkeyInput
  organisationId: UUID
  user: OrganisationInviteUserIdFkeyInput
  userId: UUID
}

"""A connection to a list of `OrganisationInvite` values."""
type OrganisationInvitesConnection {
  """
  A list of edges which contains the `OrganisationInvite` and cursor to aid in pagination.
  """
  edges: [OrganisationInvitesEdge!]!

  """A list of `OrganisationInvite` objects."""
  nodes: [OrganisationInvite!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `OrganisationInvite` you could get from the connection.
  """
  totalCount: Int!
}

"""A `OrganisationInvite` edge in the connection."""
type OrganisationInvitesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `OrganisationInvite` at the end of the edge."""
  node: OrganisationInvite!
}

"""Methods to use when ordering `OrganisationInvite`."""
enum OrganisationInvitesOrderBy {
  CODE_ASC
  CODE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  EMAIL_ASC
  EMAIL_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""The `asset` to be created by this mutation."""
input OrganisationLogoIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
Input for the nested mutation of `asset` in the `OrganisationInput` mutation.
"""
input OrganisationLogoIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: OrganisationLogoIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnOrganisationForOrganisationLogoIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: OrganisationOnOrganisationForOrganisationLogoIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisation` in the `AssetInput` mutation.
"""
input OrganisationLogoIdFkeyInverseInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: [OrganisationOrganisationPkeyConnect!]

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationNodeIdConnect!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: [OrganisationOnOrganisationForOrganisationLogoIdFkeyUsingOrganisationPkeyUpdate!]

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnOrganisationForOrganisationLogoIdFkeyNodeIdUpdate!]
}

"""The globally unique `ID` look up for the row to connect."""
input OrganisationNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnClientForClientOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `client` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: ClientPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnClientForClientOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnClientForClientOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnCostItemForCostItemOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costItem` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costItem` being updated.
  """
  patch: CostItemPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnCostItemForCostItemOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnCostItemForCostItemOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnCostTaxForCostTaxOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costTax` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: CostTaxPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnCostTaxForCostTaxOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnCostTaxForCostTaxOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnMetaForMetadataOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meta` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: MetaPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnMetaForMetadataOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnMetaForMetadataOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnOrganisationForOrganisationCostTaxIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `costTax` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `costTax` being updated.
  """
  patch: CostTaxPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnOrganisationForOrganisationCostTaxIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnOrganisationForOrganisationCostTaxIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnOrganisationForOrganisationCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnOrganisationForOrganisationCountryIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnOrganisationForOrganisationCountryIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnOrganisationForOrganisationCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currency` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: CurrencyPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnOrganisationForOrganisationCurrencyIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnOrganisationForOrganisationCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnOrganisationForOrganisationLogoIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnOrganisationForOrganisationLogoIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnOrganisationForOrganisationLogoIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisationInvite` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: OrganisationInvitePatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnOrganisationUserForOrganisationUserOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisationUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisationUser` being updated.
  """
  patch: OrganisationUserPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnOrganisationUserForOrganisationUserOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnOrganisationUserForOrganisationUserOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnSupplierForSupplierOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnSupplierForSupplierOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnSupplierForSupplierOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnTagForTagOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tag` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: TagPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnTagForTagOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnTagForTagOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationOnTripForTripOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `organisation` to look up the row to update."""
input OrganisationOnTripForTripOrganisationIdFkeyUsingOrganisationPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: updateOrganisationOnTripForTripOrganisationIdFkeyPatch!
}

"""The fields on `organisation` to look up the row to connect."""
input OrganisationOrganisationPkeyConnect {
  id: UUID!
}

"""
Represents an update to a `Organisation`. Fields that are set will be updated.
"""
input OrganisationPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

input OrganisationRegisterAndAcceptInput {
  agreeTerms: Boolean!
  clientMutationId: String
  code: String!
  email: String!
  name: String!
  password: String!
}

type OrganisationTier implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """When this item was created"""
  createdAt: Datetime
  fee: Float
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  itineraryCap: Int
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """When this item was restored"""
  restoredAt: Datetime
  stripeProductId: String
  templateCap: Int
  timesUsed: Int

  """When this item was updated"""
  updatedAt: Datetime
}

"""
A condition to be used against `OrganisationTier` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OrganisationTierCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `fee` field."""
  fee: Float

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the object’s `itineraryCap` field."""
  itineraryCap: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `stripeProductId` field."""
  stripeProductId: String

  """Checks for equality with the object’s `templateCap` field."""
  templateCap: Int

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `OrganisationTier` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationTierFilter {
  """Checks for all expressions in this list."""
  and: [OrganisationTierFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `fee` field."""
  fee: FloatFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `isPublic` field."""
  isPublic: BooleanFilter

  """Filter by the object’s `itineraryCap` field."""
  itineraryCap: IntFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: OrganisationTierFilter

  """Checks for any expressions in this list."""
  or: [OrganisationTierFilter!]

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `stripeProductId` field."""
  stripeProductId: StringFilter

  """Filter by the object’s `templateCap` field."""
  templateCap: IntFilter

  """Filter by the object’s `timesUsed` field."""
  timesUsed: IntFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""An input for mutations affecting `OrganisationTier`"""
input OrganisationTierInput {
  fee: Float
  id: UUID
  isPublic: Boolean
  itineraryCap: Int
  name: String!
  stripeProductId: String
  templateCap: Int
}

"""
Represents an update to a `OrganisationTier`. Fields that are set will be updated.
"""
input OrganisationTierPatch {
  fee: Float
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  itineraryCap: Int
  name: String
  stripeProductId: String
  templateCap: Int
}

"""A connection to a list of `OrganisationTier` values."""
type OrganisationTiersConnection {
  """
  A list of edges which contains the `OrganisationTier` and cursor to aid in pagination.
  """
  edges: [OrganisationTiersEdge!]!

  """A list of `OrganisationTier` objects."""
  nodes: [OrganisationTier!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `OrganisationTier` you could get from the connection.
  """
  totalCount: Int!
}

"""A `OrganisationTier` edge in the connection."""
type OrganisationTiersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `OrganisationTier` at the end of the edge."""
  node: OrganisationTier!
}

"""Methods to use when ordering `OrganisationTier`."""
enum OrganisationTiersOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  FEE_ASC
  FEE_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  ITINERARY_CAP_ASC
  ITINERARY_CAP_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  STRIPE_PRODUCT_ID_ASC
  STRIPE_PRODUCT_ID_DESC
  TEMPLATE_CAP_ASC
  TEMPLATE_CAP_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""
A filter to be used against many `Client` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyClientFilter {
  """
  Every related `Client` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ClientFilter

  """
  No related `Client` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ClientFilter

  """
  Some related `Client` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ClientFilter
}

"""
A filter to be used against many `CostItem` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyCostItemFilter {
  """
  Every related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CostItemFilter

  """
  No related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CostItemFilter

  """
  Some related `CostItem` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CostItemFilter
}

"""
A filter to be used against many `CostTax` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyCostTaxFilter {
  """
  Every related `CostTax` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CostTaxFilter

  """
  No related `CostTax` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CostTaxFilter

  """
  Some related `CostTax` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CostTaxFilter
}

"""
A filter to be used against many `Meta` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyMetaFilter {
  """
  Every related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MetaFilter

  """
  No related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MetaFilter

  """
  Some related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MetaFilter
}

"""
A filter to be used against many `OrganisationInvite` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyOrganisationInviteFilter {
  """
  Every related `OrganisationInvite` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationInviteFilter

  """
  No related `OrganisationInvite` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationInviteFilter

  """
  Some related `OrganisationInvite` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationInviteFilter
}

"""
A filter to be used against many `OrganisationUser` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyOrganisationUserFilter {
  """
  Every related `OrganisationUser` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationUserFilter

  """
  No related `OrganisationUser` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationUserFilter

  """
  Some related `OrganisationUser` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationUserFilter
}

"""
A filter to be used against many `Supplier` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManySupplierFilter {
  """
  Every related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SupplierFilter

  """
  No related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SupplierFilter

  """
  Some related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SupplierFilter
}

"""
A filter to be used against many `Tag` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyTagFilter {
  """
  Every related `Tag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TagFilter

  """
  No related `Tag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TagFilter

  """
  Some related `Tag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TagFilter
}

"""
A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationToManyTripFilter {
  """
  Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripFilter

  """
  No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripFilter

  """
  Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripFilter
}

type OrganisationUser implements Node {
  """When this item was created"""
  createdAt: Datetime
  email: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Organisation` that is related to this `OrganisationUser`.
  """
  organisation: Organisation
  organisationId: UUID!
  role: OrganisationUserRole

  """When this item was updated"""
  updatedAt: Datetime

  """Reads a single `User` that is related to this `OrganisationUser`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `OrganisationUser` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OrganisationUserCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `role` field."""
  role: OrganisationUserRole

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `OrganisationUser` object types. All fields are combined with a logical ‘and.’
"""
input OrganisationUserFilter {
  """Checks for all expressions in this list."""
  and: [OrganisationUserFilter!]

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `email` field."""
  email: StringFilter

  """Negates the expression."""
  not: OrganisationUserFilter

  """Checks for any expressions in this list."""
  or: [OrganisationUserFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `role` field."""
  role: OrganisationUserRoleFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `OrganisationUser`"""
input OrganisationUserInput {
  organisation: OrganisationUserOrganisationIdFkeyInput
  organisationId: UUID
  role: OrganisationUserRole
  user: OrganisationUserUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input OrganisationUserNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `organisationUser` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input OrganisationUserNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `organisationUser` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationUserOnOrganisationUserForOrganisationUserOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `organisationUser` to look up the row to update."""
input OrganisationUserOnOrganisationUserForOrganisationUserOrganisationIdFkeyUsingOrganisationUserPkeyUpdate {
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `organisationUser` being updated.
  """
  patch: updateOrganisationUserOnOrganisationUserForOrganisationUserOrganisationIdFkeyPatch!
  userId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input OrganisationUserOnOrganisationUserForOrganisationUserUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `organisationUser` to look up the row to update."""
input OrganisationUserOnOrganisationUserForOrganisationUserUserIdFkeyUsingOrganisationUserPkeyUpdate {
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `organisationUser` being updated.
  """
  patch: updateOrganisationUserOnOrganisationUserForOrganisationUserUserIdFkeyPatch!
  userId: UUID!
}

"""
Input for the nested mutation of `organisation` in the `OrganisationUserInput` mutation.
"""
input OrganisationUserOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnOrganisationUserForOrganisationUserOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: OrganisationUserOnOrganisationUserForOrganisationUserOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisationUser` in the `OrganisationInput` mutation.
"""
input OrganisationUserOrganisationIdFkeyInverseInput {
  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationUserNodeIdConnect!]

  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  connectByOrganisationIdAndUserId: [OrganisationUserOrganisationUserPkeyConnect!]

  """
  A `OrganisationUserInput` object that will be created and connected to this object.
  """
  create: [OrganisationUserOrganisationIdFkeyOrganisationUserCreateInput!]

  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  deleteByNodeId: [OrganisationUserNodeIdDelete!]

  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  deleteByOrganisationIdAndUserId: [OrganisationUserOrganisationUserPkeyDelete!]

  """
  Flag indicating whether all other `organisationUser` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `organisationUser` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnOrganisationUserForOrganisationUserOrganisationIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `organisationUser` for the far side of the relationship.
  """
  updateByOrganisationIdAndUserId: [OrganisationUserOnOrganisationUserForOrganisationUserOrganisationIdFkeyUsingOrganisationUserPkeyUpdate!]
}

"""The `organisationUser` to be created by this mutation."""
input OrganisationUserOrganisationIdFkeyOrganisationUserCreateInput {
  organisation: OrganisationUserOrganisationIdFkeyInput
  organisationId: UUID
  role: OrganisationUserRole
  user: OrganisationUserUserIdFkeyInput
  userId: UUID
}

"""The fields on `organisationUser` to look up the row to connect."""
input OrganisationUserOrganisationUserPkeyConnect {
  organisationId: UUID!
  userId: UUID!
}

"""The fields on `organisationUser` to look up the row to delete."""
input OrganisationUserOrganisationUserPkeyDelete {
  organisationId: UUID!
  userId: UUID!
}

"""
Represents an update to a `OrganisationUser`. Fields that are set will be updated.
"""
input OrganisationUserPatch {
  organisation: OrganisationUserOrganisationIdFkeyInput
  organisationId: UUID
  role: OrganisationUserRole
  user: OrganisationUserUserIdFkeyInput
  userId: UUID
}

enum OrganisationUserRole {
  CONSUMER
  MEMBER
  OWNER
}

"""
A filter to be used against OrganisationUserRole fields. All fields are combined with a logical ‘and.’
"""
input OrganisationUserRoleFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: OrganisationUserRole

  """Equal to the specified value."""
  equalTo: OrganisationUserRole

  """Greater than the specified value."""
  greaterThan: OrganisationUserRole

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: OrganisationUserRole

  """Included in the specified list."""
  in: [OrganisationUserRole!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: OrganisationUserRole

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: OrganisationUserRole

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: OrganisationUserRole

  """Not equal to the specified value."""
  notEqualTo: OrganisationUserRole

  """Not included in the specified list."""
  notIn: [OrganisationUserRole!]
}

"""
Input for the nested mutation of `user` in the `OrganisationUserInput` mutation.
"""
input OrganisationUserUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnOrganisationUserForOrganisationUserUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: OrganisationUserOnOrganisationUserForOrganisationUserUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `organisationUser` in the `UserInput` mutation.
"""
input OrganisationUserUserIdFkeyInverseInput {
  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  connectByNodeId: [OrganisationUserNodeIdConnect!]

  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  connectByOrganisationIdAndUserId: [OrganisationUserOrganisationUserPkeyConnect!]

  """
  A `OrganisationUserInput` object that will be created and connected to this object.
  """
  create: [OrganisationUserUserIdFkeyOrganisationUserCreateInput!]

  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  deleteByNodeId: [OrganisationUserNodeIdDelete!]

  """
  The primary key(s) for `organisationUser` for the far side of the relationship.
  """
  deleteByOrganisationIdAndUserId: [OrganisationUserOrganisationUserPkeyDelete!]

  """
  Flag indicating whether all other `organisationUser` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `organisationUser` for the far side of the relationship.
  """
  updateByNodeId: [UserOnOrganisationUserForOrganisationUserUserIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `organisationUser` for the far side of the relationship.
  """
  updateByOrganisationIdAndUserId: [OrganisationUserOnOrganisationUserForOrganisationUserUserIdFkeyUsingOrganisationUserPkeyUpdate!]
}

"""The `organisationUser` to be created by this mutation."""
input OrganisationUserUserIdFkeyOrganisationUserCreateInput {
  organisation: OrganisationUserOrganisationIdFkeyInput
  organisationId: UUID
  role: OrganisationUserRole
  user: OrganisationUserUserIdFkeyInput
  userId: UUID
}

"""A connection to a list of `OrganisationUser` values."""
type OrganisationUsersConnection {
  """
  A list of edges which contains the `OrganisationUser` and cursor to aid in pagination.
  """
  edges: [OrganisationUsersEdge!]!

  """A list of `OrganisationUser` objects."""
  nodes: [OrganisationUser!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `OrganisationUser` you could get from the connection.
  """
  totalCount: Int!
}

"""A `OrganisationUser` edge in the connection."""
type OrganisationUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `OrganisationUser` at the end of the edge."""
  node: OrganisationUser!
}

"""Methods to use when ordering `OrganisationUser`."""
enum OrganisationUsersOrderBy {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ROLE_ASC
  ROLE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""A connection to a list of `Organisation` values."""
type OrganisationsConnection {
  """
  A list of edges which contains the `Organisation` and cursor to aid in pagination.
  """
  edges: [OrganisationsEdge!]!

  """A list of `Organisation` objects."""
  nodes: [Organisation!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Organisation` you could get from the connection."""
  totalCount: Int!
}

"""A `Organisation` edge in the connection."""
type OrganisationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Organisation` at the end of the edge."""
  node: Organisation!
}

"""Methods to use when ordering `Organisation`."""
enum OrganisationsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  COST_TAX_ID_ASC
  COST_TAX_ID_DESC
  COST_TYPE_ASC
  COST_TYPE_DESC
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CURRENCY_ID_ASC
  CURRENCY_ID_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  ITINERARY_CAP_ADDITIONAL_ASC
  ITINERARY_CAP_ADDITIONAL_DESC
  LOGO_ID_ASC
  LOGO_ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PHONE_ASC
  PHONE_DESC
  PRIMARY_COLOUR_ASC
  PRIMARY_COLOUR_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROPOSAL_DEFAULT_MESSAGE_ASC
  PROPOSAL_DEFAULT_MESSAGE_DESC
  REQUIRE_TERMS_ACCEPTANCE_ASC
  REQUIRE_TERMS_ACCEPTANCE_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SECONDARY_COLOUR_ASC
  SECONDARY_COLOUR_DESC
  SUPPLIER_DEFAULT_MESSAGE_ASC
  SUPPLIER_DEFAULT_MESSAGE_DESC
  TEMPLATE_CAP_ADDITIONAL_ASC
  TEMPLATE_CAP_ADDITIONAL_DESC
  TERMS_ASC
  TERMS_DESC
  TIER_ID_ASC
  TIER_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type Outlet implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads and enables pagination through a set of `OutletCountry`."""
  countries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutletCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutletCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletCountriesConnection!

  """Reads and enables pagination through a set of `OutletCountry`."""
  countriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutletCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutletCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!]
  ): [OutletCountry!]!

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  notes: String

  """When this item was restored"""
  restoredAt: Datetime

  """When this item was updated"""
  updatedAt: Datetime
}

"""
A condition to be used against `Outlet` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input OutletCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `OutletCountry` values."""
type OutletCountriesConnection {
  """
  A list of edges which contains the `OutletCountry` and cursor to aid in pagination.
  """
  edges: [OutletCountriesEdge!]!

  """A list of `OutletCountry` objects."""
  nodes: [OutletCountry!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `OutletCountry` you could get from the connection."""
  totalCount: Int!
}

"""A `OutletCountry` edge in the connection."""
type OutletCountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `OutletCountry` at the end of the edge."""
  node: OutletCountry!
}

"""Methods to use when ordering `OutletCountry`."""
enum OutletCountriesOrderBy {
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  NATURAL
  OUTLET_ID_ASC
  OUTLET_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORTING_ASC
  SORTING_DESC
}

type OutletCountry implements Node {
  """Reads a single `Country` that is related to this `OutletCountry`."""
  country: Country
  countryId: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Outlet` that is related to this `OutletCountry`."""
  outlet: Outlet
  outletId: UUID!
  sorting: Int
}

"""
A condition to be used against `OutletCountry` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input OutletCountryCondition {
  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `outletId` field."""
  outletId: UUID

  """Checks for equality with the object’s `sorting` field."""
  sorting: Int
}

"""The `country` to be created by this mutation."""
input OutletCountryCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `OutletCountryInput` mutation.
"""
input OutletCountryCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: OutletCountryCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnOutletCountryForOutletCountryCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnOutletCountryForOutletCountryCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: OutletCountryOnOutletCountryForOutletCountryCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnOutletCountryForOutletCountryCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `outletCountry` in the `CountryInput` mutation.
"""
input OutletCountryCountryIdFkeyInverseInput {
  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  connectByNodeId: [OutletCountryNodeIdConnect!]

  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  connectByOutletIdAndCountryId: [OutletCountryOutletCountryPkeyConnect!]

  """
  A `OutletCountryInput` object that will be created and connected to this object.
  """
  create: [OutletCountryCountryIdFkeyOutletCountryCreateInput!]

  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  deleteByNodeId: [OutletCountryNodeIdDelete!]

  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  deleteByOutletIdAndCountryId: [OutletCountryOutletCountryPkeyDelete!]

  """
  Flag indicating whether all other `outletCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `outletCountry` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnOutletCountryForOutletCountryCountryIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `outletCountry` for the far side of the relationship.
  """
  updateByOutletIdAndCountryId: [OutletCountryOnOutletCountryForOutletCountryCountryIdFkeyUsingOutletCountryPkeyUpdate!]
}

"""The `outletCountry` to be created by this mutation."""
input OutletCountryCountryIdFkeyOutletCountryCreateInput {
  country: OutletCountryCountryIdFkeyInput
  countryId: UUID
  outlet: OutletCountryOutletIdFkeyInput
  outletId: UUID
  sorting: Int
}

"""
A filter to be used against `OutletCountry` object types. All fields are combined with a logical ‘and.’
"""
input OutletCountryFilter {
  """Checks for all expressions in this list."""
  and: [OutletCountryFilter!]

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Negates the expression."""
  not: OutletCountryFilter

  """Checks for any expressions in this list."""
  or: [OutletCountryFilter!]

  """Filter by the object’s `outlet` relation."""
  outlet: OutletFilter

  """Filter by the object’s `outletId` field."""
  outletId: UUIDFilter

  """Filter by the object’s `sorting` field."""
  sorting: IntFilter
}

"""An input for mutations affecting `OutletCountry`"""
input OutletCountryInput {
  country: OutletCountryCountryIdFkeyInput
  countryId: UUID
  outlet: OutletCountryOutletIdFkeyInput
  outletId: UUID
  sorting: Int
}

"""The globally unique `ID` look up for the row to connect."""
input OutletCountryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `outletCountry` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input OutletCountryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `outletCountry` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input OutletCountryOnOutletCountryForOutletCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `outletCountry` to look up the row to update."""
input OutletCountryOnOutletCountryForOutletCountryCountryIdFkeyUsingOutletCountryPkeyUpdate {
  countryId: UUID!
  outletId: UUID!

  """
  An object where the defined keys will be set on the `outletCountry` being updated.
  """
  patch: updateOutletCountryOnOutletCountryForOutletCountryCountryIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input OutletCountryOnOutletCountryForOutletCountryOutletIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `outlet` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `outlet` being updated.
  """
  patch: OutletPatch!
}

"""The fields on `outletCountry` to look up the row to update."""
input OutletCountryOnOutletCountryForOutletCountryOutletIdFkeyUsingOutletCountryPkeyUpdate {
  countryId: UUID!
  outletId: UUID!

  """
  An object where the defined keys will be set on the `outletCountry` being updated.
  """
  patch: updateOutletCountryOnOutletCountryForOutletCountryOutletIdFkeyPatch!
}

"""The fields on `outletCountry` to look up the row to connect."""
input OutletCountryOutletCountryPkeyConnect {
  countryId: UUID!
  outletId: UUID!
}

"""The fields on `outletCountry` to look up the row to delete."""
input OutletCountryOutletCountryPkeyDelete {
  countryId: UUID!
  outletId: UUID!
}

"""
Input for the nested mutation of `outlet` in the `OutletCountryInput` mutation.
"""
input OutletCountryOutletIdFkeyInput {
  """The primary key(s) for `outlet` for the far side of the relationship."""
  connectById: OutletOutletPkeyConnect

  """The primary key(s) for `outlet` for the far side of the relationship."""
  connectByName: OutletOutletNameKeyConnect

  """The primary key(s) for `outlet` for the far side of the relationship."""
  connectByNodeId: OutletNodeIdConnect

  """
  A `OutletInput` object that will be created and connected to this object.
  """
  create: OutletCountryOutletIdFkeyOutletCreateInput

  """The primary key(s) for `outlet` for the far side of the relationship."""
  deleteById: OutletOutletPkeyDelete

  """The primary key(s) for `outlet` for the far side of the relationship."""
  deleteByName: OutletOutletNameKeyDelete

  """The primary key(s) for `outlet` for the far side of the relationship."""
  deleteByNodeId: OutletNodeIdDelete

  """
  The primary key(s) and patch data for `outlet` for the far side of the relationship.
  """
  updateById: OutletOnOutletCountryForOutletCountryOutletIdFkeyUsingOutletPkeyUpdate

  """
  The primary key(s) and patch data for `outlet` for the far side of the relationship.
  """
  updateByName: OutletOnOutletCountryForOutletCountryOutletIdFkeyUsingOutletNameKeyUpdate

  """
  The primary key(s) and patch data for `outlet` for the far side of the relationship.
  """
  updateByNodeId: OutletCountryOnOutletCountryForOutletCountryOutletIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `outletCountry` in the `OutletInput` mutation.
"""
input OutletCountryOutletIdFkeyInverseInput {
  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  connectByNodeId: [OutletCountryNodeIdConnect!]

  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  connectByOutletIdAndCountryId: [OutletCountryOutletCountryPkeyConnect!]

  """
  A `OutletCountryInput` object that will be created and connected to this object.
  """
  create: [OutletCountryOutletIdFkeyOutletCountryCreateInput!]

  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  deleteByNodeId: [OutletCountryNodeIdDelete!]

  """
  The primary key(s) for `outletCountry` for the far side of the relationship.
  """
  deleteByOutletIdAndCountryId: [OutletCountryOutletCountryPkeyDelete!]

  """
  Flag indicating whether all other `outletCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `outletCountry` for the far side of the relationship.
  """
  updateByNodeId: [OutletOnOutletCountryForOutletCountryOutletIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `outletCountry` for the far side of the relationship.
  """
  updateByOutletIdAndCountryId: [OutletCountryOnOutletCountryForOutletCountryOutletIdFkeyUsingOutletCountryPkeyUpdate!]
}

"""The `outletCountry` to be created by this mutation."""
input OutletCountryOutletIdFkeyOutletCountryCreateInput {
  country: OutletCountryCountryIdFkeyInput
  countryId: UUID
  outlet: OutletCountryOutletIdFkeyInput
  outletId: UUID
  sorting: Int
}

"""The `outlet` to be created by this mutation."""
input OutletCountryOutletIdFkeyOutletCreateInput {
  countries: OutletCountryOutletIdFkeyInverseInput
  id: UUID
  name: String
  notes: String
}

"""
Represents an update to a `OutletCountry`. Fields that are set will be updated.
"""
input OutletCountryPatch {
  country: OutletCountryCountryIdFkeyInput
  countryId: UUID
  outlet: OutletCountryOutletIdFkeyInput
  outletId: UUID
  sorting: Int
}

"""
A filter to be used against `Outlet` object types. All fields are combined with a logical ‘and.’
"""
input OutletFilter {
  """Checks for all expressions in this list."""
  and: [OutletFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `countries` relation."""
  countries: OutletToManyOutletCountryFilter

  """Some related `countries` exist."""
  countriesExist: Boolean

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: OutletFilter

  """Filter by the object’s `notes` field."""
  notes: StringFilter

  """Checks for any expressions in this list."""
  or: [OutletFilter!]

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""An input for mutations affecting `Outlet`"""
input OutletInput {
  countries: OutletCountryOutletIdFkeyInverseInput
  id: UUID
  name: String
  notes: String
}

"""The globally unique `ID` look up for the row to connect."""
input OutletNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `outlet` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input OutletNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `outlet` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input OutletOnOutletCountryForOutletCountryOutletIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `outletCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `outletCountry` being updated.
  """
  patch: OutletCountryPatch!
}

"""The fields on `outlet` to look up the row to update."""
input OutletOnOutletCountryForOutletCountryOutletIdFkeyUsingOutletNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `outlet` being updated.
  """
  patch: updateOutletOnOutletCountryForOutletCountryOutletIdFkeyPatch!
}

"""The fields on `outlet` to look up the row to update."""
input OutletOnOutletCountryForOutletCountryOutletIdFkeyUsingOutletPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `outlet` being updated.
  """
  patch: updateOutletOnOutletCountryForOutletCountryOutletIdFkeyPatch!
}

"""The fields on `outlet` to look up the row to connect."""
input OutletOutletNameKeyConnect {
  name: String!
}

"""The fields on `outlet` to look up the row to delete."""
input OutletOutletNameKeyDelete {
  name: String!
}

"""The fields on `outlet` to look up the row to connect."""
input OutletOutletPkeyConnect {
  id: UUID!
}

"""The fields on `outlet` to look up the row to delete."""
input OutletOutletPkeyDelete {
  id: UUID!
}

"""
Represents an update to a `Outlet`. Fields that are set will be updated.
"""
input OutletPatch {
  countries: OutletCountryOutletIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  notes: String
}

"""
A filter to be used against many `OutletCountry` object types. All fields are combined with a logical ‘and.’
"""
input OutletToManyOutletCountryFilter {
  """
  Every related `OutletCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OutletCountryFilter

  """
  No related `OutletCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OutletCountryFilter

  """
  Some related `OutletCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OutletCountryFilter
}

"""A connection to a list of `Outlet` values."""
type OutletsConnection {
  """
  A list of edges which contains the `Outlet` and cursor to aid in pagination.
  """
  edges: [OutletsEdge!]!

  """A list of `Outlet` objects."""
  nodes: [Outlet!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Outlet` you could get from the connection."""
  totalCount: Int!
}

"""A `Outlet` edge in the connection."""
type OutletsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Outlet` at the end of the edge."""
  node: Outlet!
}

"""Methods to use when ordering `Outlet`."""
enum OutletsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor

  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor
}

type PartnerPage implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads a single `Asset` that is related to this `PartnerPage`."""
  background: Asset
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String

  """When this item was created"""
  createdAt: Datetime

  """Reads a single `Grati` that is related to this `PartnerPage`."""
  gratis: Grati
  gratisId: UUID @deprecated(reason: "Use Promo Code")
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Reads a single `Asset` that is related to this `PartnerPage`."""
  logo: Asset
  logoId: UUID
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `PromoCode` that is related to this `PartnerPage`."""
  promoCode: PromoCode
  promoCodeId: UUID

  """When this item was restored"""
  restoredAt: Datetime
  slug: String!

  """When this item was updated"""
  updatedAt: Datetime
}

"""The `asset` to be created by this mutation."""
input PartnerPageBackgroundIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
Input for the nested mutation of `asset` in the `PartnerPageInput` mutation.
"""
input PartnerPageBackgroundIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: PartnerPageBackgroundIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnPartnerPageForPartnerPageBackgroundIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: PartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `partnerPage` in the `AssetInput` mutation.
"""
input PartnerPageBackgroundIdFkeyInverseInput {
  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectById: [PartnerPagePartnerPagePkeyConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectByNodeId: [PartnerPageNodeIdConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectBySlug: [PartnerPagePartnerPageSlugKeyConnect!]

  """
  A `PartnerPageInput` object that will be created and connected to this object.
  """
  create: [PartnerPageBackgroundIdFkeyPartnerPageCreateInput!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteById: [PartnerPagePartnerPagePkeyDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteByNodeId: [PartnerPageNodeIdDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteBySlug: [PartnerPagePartnerPageSlugKeyDelete!]

  """
  Flag indicating whether all other `partnerPage` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateById: [PartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyUsingPartnerPagePkeyUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnPartnerPageForPartnerPageBackgroundIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateBySlug: [PartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyUsingPartnerPageSlugKeyUpdate!]
}

"""The `partnerPage` to be created by this mutation."""
input PartnerPageBackgroundIdFkeyPartnerPageCreateInput {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID
  logoId: UUID
  name: String!
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String!
}

"""
A condition to be used against `PartnerPage` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PartnerPageCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `backgroundId` field."""
  backgroundId: UUID

  """Checks for equality with the object’s `bannerBackgroundColour` field."""
  bannerBackgroundColour: String

  """Checks for equality with the object’s `bannerText` field."""
  bannerText: String

  """Checks for equality with the object’s `bannerTextColour` field."""
  bannerTextColour: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `gratisId` field."""
  gratisId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `logoId` field."""
  logoId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `promoCodeId` field."""
  promoCodeId: UUID

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `PartnerPage` object types. All fields are combined with a logical ‘and.’
"""
input PartnerPageFilter {
  """Checks for all expressions in this list."""
  and: [PartnerPageFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `background` relation."""
  background: AssetFilter

  """A related `background` exists."""
  backgroundExists: Boolean

  """Filter by the object’s `backgroundId` field."""
  backgroundId: UUIDFilter

  """Filter by the object’s `bannerBackgroundColour` field."""
  bannerBackgroundColour: StringFilter

  """Filter by the object’s `bannerText` field."""
  bannerText: StringFilter

  """Filter by the object’s `bannerTextColour` field."""
  bannerTextColour: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `gratis` relation."""
  gratis: GratiFilter

  """A related `gratis` exists."""
  gratisExists: Boolean

  """Filter by the object’s `gratisId` field."""
  gratisId: UUIDFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `logo` relation."""
  logo: AssetFilter

  """A related `logo` exists."""
  logoExists: Boolean

  """Filter by the object’s `logoId` field."""
  logoId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: PartnerPageFilter

  """Checks for any expressions in this list."""
  or: [PartnerPageFilter!]

  """Filter by the object’s `promoCode` relation."""
  promoCode: PromoCodeFilter

  """A related `promoCode` exists."""
  promoCodeExists: Boolean

  """Filter by the object’s `promoCodeId` field."""
  promoCodeId: UUIDFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `slug` field."""
  slug: StringFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""The `grati` to be created by this mutation."""
input PartnerPageGratisIdFkeyGratisCreateInput {
  """The code users must enter to use the gratis"""
  code: String!

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime
  gratisUseds: GratisUsedGratisIdFkeyInverseInput
  id: UUID
  name: String!
  partnerPages: PartnerPageGratisIdFkeyInverseInput

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""
Input for the nested mutation of `grati` in the `PartnerPageInput` mutation.
"""
input PartnerPageGratisIdFkeyInput {
  """The primary key(s) for `grati` for the far side of the relationship."""
  connectById: GratiGratisPkeyConnect

  """The primary key(s) for `grati` for the far side of the relationship."""
  connectByNodeId: GratiNodeIdConnect

  """
  A `GratiInput` object that will be created and connected to this object.
  """
  create: PartnerPageGratisIdFkeyGratisCreateInput

  """The primary key(s) for `grati` for the far side of the relationship."""
  deleteById: GratiGratisPkeyDelete

  """The primary key(s) for `grati` for the far side of the relationship."""
  deleteByNodeId: GratiNodeIdDelete

  """
  The primary key(s) and patch data for `grati` for the far side of the relationship.
  """
  updateById: GratiOnPartnerPageForPartnerPageGratisIdFkeyUsingGratisPkeyUpdate

  """
  The primary key(s) and patch data for `grati` for the far side of the relationship.
  """
  updateByNodeId: PartnerPageOnPartnerPageForPartnerPageGratisIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `partnerPage` in the `GratiInput` mutation.
"""
input PartnerPageGratisIdFkeyInverseInput {
  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectById: [PartnerPagePartnerPagePkeyConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectByNodeId: [PartnerPageNodeIdConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectBySlug: [PartnerPagePartnerPageSlugKeyConnect!]

  """
  A `PartnerPageInput` object that will be created and connected to this object.
  """
  create: [PartnerPageGratisIdFkeyPartnerPageCreateInput!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteById: [PartnerPagePartnerPagePkeyDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteByNodeId: [PartnerPageNodeIdDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteBySlug: [PartnerPagePartnerPageSlugKeyDelete!]

  """
  Flag indicating whether all other `partnerPage` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateById: [PartnerPageOnPartnerPageForPartnerPageGratisIdFkeyUsingPartnerPagePkeyUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateByNodeId: [GratiOnPartnerPageForPartnerPageGratisIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateBySlug: [PartnerPageOnPartnerPageForPartnerPageGratisIdFkeyUsingPartnerPageSlugKeyUpdate!]
}

"""The `partnerPage` to be created by this mutation."""
input PartnerPageGratisIdFkeyPartnerPageCreateInput {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID
  logoId: UUID
  name: String!
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String!
}

"""An input for mutations affecting `PartnerPage`"""
input PartnerPageInput {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID
  logoId: UUID
  name: String!
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String!
}

"""
Input for the nested mutation of `partnerPage` in the `AssetInput` mutation.
"""
input PartnerPageLogoIdFkeyInverseInput {
  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectById: [PartnerPagePartnerPagePkeyConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectByNodeId: [PartnerPageNodeIdConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectBySlug: [PartnerPagePartnerPageSlugKeyConnect!]

  """
  A `PartnerPageInput` object that will be created and connected to this object.
  """
  create: [PartnerPageLogoIdFkeyPartnerPageCreateInput!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteById: [PartnerPagePartnerPagePkeyDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteByNodeId: [PartnerPageNodeIdDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteBySlug: [PartnerPagePartnerPageSlugKeyDelete!]

  """
  Flag indicating whether all other `partnerPage` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateById: [PartnerPageOnPartnerPageForPartnerPageLogoIdFkeyUsingPartnerPagePkeyUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnPartnerPageForPartnerPageLogoIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateBySlug: [PartnerPageOnPartnerPageForPartnerPageLogoIdFkeyUsingPartnerPageSlugKeyUpdate!]
}

"""The `partnerPage` to be created by this mutation."""
input PartnerPageLogoIdFkeyPartnerPageCreateInput {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID
  logoId: UUID
  name: String!
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String!
}

"""The globally unique `ID` look up for the row to connect."""
input PartnerPageNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `partnerPage` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input PartnerPageNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `partnerPage` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input PartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyUsingPartnerPagePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyPatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyUsingPartnerPageSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input PartnerPageOnPartnerPageForPartnerPageGratisIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `grati` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `grati` being updated.
  """
  patch: GratiPatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPageGratisIdFkeyUsingPartnerPagePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPageGratisIdFkeyPatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPageGratisIdFkeyUsingPartnerPageSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPageGratisIdFkeyPatch!
  slug: String!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPageLogoIdFkeyUsingPartnerPagePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPageLogoIdFkeyPatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPageLogoIdFkeyUsingPartnerPageSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPageLogoIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input PartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCode` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: PromoCodePatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPartnerPagePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyPatch!
}

"""The fields on `partnerPage` to look up the row to update."""
input PartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPartnerPageSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: updatePartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyPatch!
  slug: String!
}

"""The fields on `partnerPage` to look up the row to connect."""
input PartnerPagePartnerPagePkeyConnect {
  id: UUID!
}

"""The fields on `partnerPage` to look up the row to delete."""
input PartnerPagePartnerPagePkeyDelete {
  id: UUID!
}

"""The fields on `partnerPage` to look up the row to connect."""
input PartnerPagePartnerPageSlugKeyConnect {
  slug: String!
}

"""The fields on `partnerPage` to look up the row to delete."""
input PartnerPagePartnerPageSlugKeyDelete {
  slug: String!
}

"""
Represents an update to a `PartnerPage`. Fields that are set will be updated.
"""
input PartnerPagePatch {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  name: String
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String
}

"""
Input for the nested mutation of `promoCode` in the `PartnerPageInput` mutation.
"""
input PartnerPagePromoCodeIdFkeyInput {
  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectByCode: PromoCodePromoCodeCodeKeyConnect

  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectById: PromoCodePromoCodePkeyConnect

  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectByNodeId: PromoCodeNodeIdConnect

  """
  A `PromoCodeInput` object that will be created and connected to this object.
  """
  create: PartnerPagePromoCodeIdFkeyPromoCodeCreateInput

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateByCode: PromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPromoCodeCodeKeyUpdate

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateById: PromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPromoCodePkeyUpdate

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateByNodeId: PartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `partnerPage` in the `PromoCodeInput` mutation.
"""
input PartnerPagePromoCodeIdFkeyInverseInput {
  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectById: [PartnerPagePartnerPagePkeyConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectByNodeId: [PartnerPageNodeIdConnect!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  connectBySlug: [PartnerPagePartnerPageSlugKeyConnect!]

  """
  A `PartnerPageInput` object that will be created and connected to this object.
  """
  create: [PartnerPagePromoCodeIdFkeyPartnerPageCreateInput!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteById: [PartnerPagePartnerPagePkeyDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteByNodeId: [PartnerPageNodeIdDelete!]

  """
  The primary key(s) for `partnerPage` for the far side of the relationship.
  """
  deleteBySlug: [PartnerPagePartnerPageSlugKeyDelete!]

  """
  Flag indicating whether all other `partnerPage` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateById: [PartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPartnerPagePkeyUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateByNodeId: [PromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `partnerPage` for the far side of the relationship.
  """
  updateBySlug: [PartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPartnerPageSlugKeyUpdate!]
}

"""The `partnerPage` to be created by this mutation."""
input PartnerPagePromoCodeIdFkeyPartnerPageCreateInput {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID
  logoId: UUID
  name: String!
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String!
}

"""The `promoCode` to be created by this mutation."""
input PartnerPagePromoCodeIdFkeyPromoCodeCreateInput {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String!

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID
  name: String!
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType!

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""A connection to a list of `PartnerPage` values."""
type PartnerPagesConnection {
  """
  A list of edges which contains the `PartnerPage` and cursor to aid in pagination.
  """
  edges: [PartnerPagesEdge!]!

  """A list of `PartnerPage` objects."""
  nodes: [PartnerPage!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PartnerPage` you could get from the connection."""
  totalCount: Int!
}

"""A `PartnerPage` edge in the connection."""
type PartnerPagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PartnerPage` at the end of the edge."""
  node: PartnerPage!
}

"""Methods to use when ordering `PartnerPage`."""
enum PartnerPagesOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  BACKGROUND_ID_ASC
  BACKGROUND_ID_DESC
  BANNER_BACKGROUND_COLOUR_ASC
  BANNER_BACKGROUND_COLOUR_DESC
  BANNER_TEXT_ASC
  BANNER_TEXT_COLOUR_ASC
  BANNER_TEXT_COLOUR_DESC
  BANNER_TEXT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  GRATIS_ID_ASC
  GRATIS_ID_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  LOGO_ID_ASC
  LOGO_ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROMO_CODE_ID_ASC
  PROMO_CODE_ID_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SLUG_ASC
  SLUG_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

enum Permission {
  EDIT
  EDIT_ALL_ATTACHMENTS
  READ
  READ_ALL_ATTACHMENTS
  READ_BUDGET
  READ_NOTES
  READ_TASKS
}

"""
A filter to be used against Permission List fields. All fields are combined with a logical ‘and.’
"""
input PermissionListFilter {
  """Any array item is equal to the specified value."""
  anyEqualTo: Permission

  """Any array item is greater than the specified value."""
  anyGreaterThan: Permission

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: Permission

  """Any array item is less than the specified value."""
  anyLessThan: Permission

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: Permission

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: Permission

  """Contained by the specified list of values."""
  containedBy: [Permission]

  """Contains the specified list of values."""
  contains: [Permission]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [Permission]

  """Equal to the specified value."""
  equalTo: [Permission]

  """Greater than the specified value."""
  greaterThan: [Permission]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [Permission]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: [Permission]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [Permission]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [Permission]

  """Not equal to the specified value."""
  notEqualTo: [Permission]

  """Overlaps the specified list of values."""
  overlaps: [Permission]
}

type Place implements Node {
  """When this item was created"""
  createdAt: Datetime
  id: String!
  location: Location
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  phoneNumber: String
  price: Int
  rating: Float
  totalReviews: Int
  type: String

  """When this item was updated"""
  updatedAt: Datetime
  url: String
}

"""
A condition to be used against `Place` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PlaceCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: String

  """Checks for equality with the object’s `location` field."""
  location: LocationInput

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `phoneNumber` field."""
  phoneNumber: String

  """Checks for equality with the object’s `price` field."""
  price: Int

  """Checks for equality with the object’s `rating` field."""
  rating: Float

  """Checks for equality with the object’s `totalReviews` field."""
  totalReviews: Int

  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `url` field."""
  url: String
}

"""
A filter to be used against `Place` object types. All fields are combined with a logical ‘and.’
"""
input PlaceFilter {
  """Checks for all expressions in this list."""
  and: [PlaceFilter!]

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: StringFilter

  """Filter by the object’s `location` field."""
  location: LocationFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: PlaceFilter

  """Checks for any expressions in this list."""
  or: [PlaceFilter!]

  """Filter by the object’s `phoneNumber` field."""
  phoneNumber: StringFilter

  """Filter by the object’s `price` field."""
  price: IntFilter

  """Filter by the object’s `rating` field."""
  rating: FloatFilter

  """Filter by the object’s `totalReviews` field."""
  totalReviews: IntFilter

  """Filter by the object’s `type` field."""
  type: StringFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `url` field."""
  url: StringFilter
}

"""An input for mutations affecting `Place`"""
input PlaceInput {
  id: String!
  location: LocationInput
  name: String
  phoneNumber: String
  price: Int
  rating: Float
  totalReviews: Int
  type: String
  url: String
}

"""
Represents an update to a `Place`. Fields that are set will be updated.
"""
input PlacePatch {
  id: String
  location: LocationInput
  name: String
  phoneNumber: String
  price: Int
  rating: Float
  totalReviews: Int
  type: String
  url: String
}

"""A connection to a list of `Place` values."""
type PlacesConnection {
  """
  A list of edges which contains the `Place` and cursor to aid in pagination.
  """
  edges: [PlacesEdge!]!

  """A list of `Place` objects."""
  nodes: [Place!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Place` you could get from the connection."""
  totalCount: Int!
}

"""A `Place` edge in the connection."""
type PlacesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Place` at the end of the edge."""
  node: Place!
}

"""Methods to use when ordering `Place`."""
enum PlacesOrderBy {
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  LOCATION_ASC
  LOCATION_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PHONE_NUMBER_ASC
  PHONE_NUMBER_DESC
  PRICE_ASC
  PRICE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RATING_ASC
  RATING_DESC
  TOTAL_REVIEWS_ASC
  TOTAL_REVIEWS_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  URL_ASC
  URL_DESC
}

type Price {
  amount: Float!
  currency: String!
  id: String!
  interval: String!
}

type Product {
  id: String!
  name: String!
  prices: [Price!]
}

type PromoCode implements Node {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int

  """When this item was archived"""
  archivedAt: Datetime
  code: String!

  """When this item was created"""
  createdAt: Datetime

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: Interval
  expiresAt: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  partnerPageSlug: String

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPages(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesConnection!

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPagesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!]
  ): [PartnerPage!]!

  """Reads and enables pagination through a set of `PromoCodeAffiliate`."""
  promoCodeAffiliates(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeAffiliateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeAffiliateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeAffiliatesConnection!

  """Reads and enables pagination through a set of `PromoCodeAffiliate`."""
  promoCodeAffiliatesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeAffiliateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeAffiliateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!]
  ): [PromoCodeAffiliate!]!

  """Reads and enables pagination through a set of `PromoCodeUsed`."""
  promoCodeUseds(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCodeUsed`."""
    orderBy: [PromoCodeUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeUsedsConnection!

  """Reads and enables pagination through a set of `PromoCodeUsed`."""
  promoCodeUsedsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCodeUsed`."""
    orderBy: [PromoCodeUsedsOrderBy!]
  ): [PromoCodeUsed!]!

  """When this item was restored"""
  restoredAt: Datetime
  type: PromoCodeType!

  """When this item was updated"""
  updatedAt: Datetime
  usedCount: BigInt

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

type PromoCodeAffiliate implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `PromoCode` that is related to this `PromoCodeAffiliate`.
  """
  promoCode: PromoCode
  promoCodeId: UUID!

  """Reads a single `User` that is related to this `PromoCodeAffiliate`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `PromoCodeAffiliate` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PromoCodeAffiliateCondition {
  """Checks for equality with the object’s `promoCodeId` field."""
  promoCodeId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `PromoCodeAffiliate` object types. All fields are combined with a logical ‘and.’
"""
input PromoCodeAffiliateFilter {
  """Checks for all expressions in this list."""
  and: [PromoCodeAffiliateFilter!]

  """Negates the expression."""
  not: PromoCodeAffiliateFilter

  """Checks for any expressions in this list."""
  or: [PromoCodeAffiliateFilter!]

  """Filter by the object’s `promoCode` relation."""
  promoCode: PromoCodeFilter

  """Filter by the object’s `promoCodeId` field."""
  promoCodeId: UUIDFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""
Input for the nested mutation of `promoCode` in the `PromoCodeAffiliateInput` mutation.
"""
input PromoCodeAffiliateIdFkeyInput {
  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectByCode: PromoCodePromoCodeCodeKeyConnect

  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectById: PromoCodePromoCodePkeyConnect

  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectByNodeId: PromoCodeNodeIdConnect

  """
  A `PromoCodeInput` object that will be created and connected to this object.
  """
  create: PromoCodeAffiliateIdFkeyPromoCodeCreateInput

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateByCode: PromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyUsingPromoCodeCodeKeyUpdate

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateById: PromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyUsingPromoCodePkeyUpdate

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateByNodeId: PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `promoCodeAffiliate` in the `PromoCodeInput` mutation.
"""
input PromoCodeAffiliateIdFkeyInverseInput {
  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  connectByNodeId: [PromoCodeAffiliateNodeIdConnect!]

  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  connectByPromoCodeIdAndUserId: [PromoCodeAffiliatePromoCodeAffiliatePkeyConnect!]

  """
  A `PromoCodeAffiliateInput` object that will be created and connected to this object.
  """
  create: [PromoCodeAffiliateIdFkeyPromoCodeAffiliateCreateInput!]

  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  deleteByNodeId: [PromoCodeAffiliateNodeIdDelete!]

  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  deleteByPromoCodeIdAndUserId: [PromoCodeAffiliatePromoCodeAffiliatePkeyDelete!]

  """
  Flag indicating whether all other `promoCodeAffiliate` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `promoCodeAffiliate` for the far side of the relationship.
  """
  updateByNodeId: [PromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `promoCodeAffiliate` for the far side of the relationship.
  """
  updateByPromoCodeIdAndUserId: [PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyUsingPromoCodeAffiliatePkeyUpdate!]
}

"""The `promoCodeAffiliate` to be created by this mutation."""
input PromoCodeAffiliateIdFkeyPromoCodeAffiliateCreateInput {
  promoCode: PromoCodeAffiliateIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeAffiliateUserIdFkeyInput
  userId: UUID
}

"""The `promoCode` to be created by this mutation."""
input PromoCodeAffiliateIdFkeyPromoCodeCreateInput {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String!

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID
  name: String!
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType!

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""An input for mutations affecting `PromoCodeAffiliate`"""
input PromoCodeAffiliateInput {
  promoCode: PromoCodeAffiliateIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeAffiliateUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input PromoCodeAffiliateNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `promoCodeAffiliate` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input PromoCodeAffiliateNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `promoCodeAffiliate` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCode` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: PromoCodePatch!
}

"""The fields on `promoCodeAffiliate` to look up the row to update."""
input PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyUsingPromoCodeAffiliatePkeyUpdate {
  """
  An object where the defined keys will be set on the `promoCodeAffiliate` being updated.
  """
  patch: updatePromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyPatch!
  promoCodeId: UUID!
  userId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `promoCodeAffiliate` to look up the row to update."""
input PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyUsingPromoCodeAffiliatePkeyUpdate {
  """
  An object where the defined keys will be set on the `promoCodeAffiliate` being updated.
  """
  patch: updatePromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyPatch!
  promoCodeId: UUID!
  userId: UUID!
}

"""
Represents an update to a `PromoCodeAffiliate`. Fields that are set will be updated.
"""
input PromoCodeAffiliatePatch {
  promoCode: PromoCodeAffiliateIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeAffiliateUserIdFkeyInput
  userId: UUID
}

"""The fields on `promoCodeAffiliate` to look up the row to connect."""
input PromoCodeAffiliatePromoCodeAffiliatePkeyConnect {
  promoCodeId: UUID!
  userId: UUID!
}

"""The fields on `promoCodeAffiliate` to look up the row to delete."""
input PromoCodeAffiliatePromoCodeAffiliatePkeyDelete {
  promoCodeId: UUID!
  userId: UUID!
}

"""
Input for the nested mutation of `user` in the `PromoCodeAffiliateInput` mutation.
"""
input PromoCodeAffiliateUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `promoCodeAffiliate` in the `UserInput` mutation.
"""
input PromoCodeAffiliateUserIdFkeyInverseInput {
  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  connectByNodeId: [PromoCodeAffiliateNodeIdConnect!]

  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  connectByPromoCodeIdAndUserId: [PromoCodeAffiliatePromoCodeAffiliatePkeyConnect!]

  """
  A `PromoCodeAffiliateInput` object that will be created and connected to this object.
  """
  create: [PromoCodeAffiliateUserIdFkeyPromoCodeAffiliateCreateInput!]

  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  deleteByNodeId: [PromoCodeAffiliateNodeIdDelete!]

  """
  The primary key(s) for `promoCodeAffiliate` for the far side of the relationship.
  """
  deleteByPromoCodeIdAndUserId: [PromoCodeAffiliatePromoCodeAffiliatePkeyDelete!]

  """
  Flag indicating whether all other `promoCodeAffiliate` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `promoCodeAffiliate` for the far side of the relationship.
  """
  updateByNodeId: [UserOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `promoCodeAffiliate` for the far side of the relationship.
  """
  updateByPromoCodeIdAndUserId: [PromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyUsingPromoCodeAffiliatePkeyUpdate!]
}

"""The `promoCodeAffiliate` to be created by this mutation."""
input PromoCodeAffiliateUserIdFkeyPromoCodeAffiliateCreateInput {
  promoCode: PromoCodeAffiliateIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeAffiliateUserIdFkeyInput
  userId: UUID
}

"""A connection to a list of `PromoCodeAffiliate` values."""
type PromoCodeAffiliatesConnection {
  """
  A list of edges which contains the `PromoCodeAffiliate` and cursor to aid in pagination.
  """
  edges: [PromoCodeAffiliatesEdge!]!

  """A list of `PromoCodeAffiliate` objects."""
  nodes: [PromoCodeAffiliate!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `PromoCodeAffiliate` you could get from the connection.
  """
  totalCount: Int!
}

"""A `PromoCodeAffiliate` edge in the connection."""
type PromoCodeAffiliatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PromoCodeAffiliate` at the end of the edge."""
  node: PromoCodeAffiliate!
}

"""Methods to use when ordering `PromoCodeAffiliate`."""
enum PromoCodeAffiliatesOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROMO_CODE_ID_ASC
  PROMO_CODE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""All input for the `promoCodeApply` mutation."""
input PromoCodeApplyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!
  origin: PromoCodeUsedOrigin!
  userId: UUID!
}

"""The output of our `promoCodeApply` mutation."""
type PromoCodeApplyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A condition to be used against `PromoCode` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input PromoCodeCondition {
  """Checks for equality with the object’s `affiliatePercent` field."""
  affiliatePercent: Int

  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `code` field."""
  code: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `discountPercent` field."""
  discountPercent: Int

  """Checks for equality with the object’s `duration` field."""
  duration: IntervalInput

  """Checks for equality with the object’s `expiresAt` field."""
  expiresAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `type` field."""
  type: PromoCodeType

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `uses` field."""
  uses: Int

  """Checks for equality with the object’s `validFrom` field."""
  validFrom: Datetime
}

"""
A filter to be used against `PromoCode` object types. All fields are combined with a logical ‘and.’
"""
input PromoCodeFilter {
  """Filter by the object’s `affiliatePercent` field."""
  affiliatePercent: IntFilter

  """Checks for all expressions in this list."""
  and: [PromoCodeFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `code` field."""
  code: StringFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `discountPercent` field."""
  discountPercent: IntFilter

  """Filter by the object’s `duration` field."""
  duration: IntervalFilter

  """Filter by the object’s `expiresAt` field."""
  expiresAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: PromoCodeFilter

  """Checks for any expressions in this list."""
  or: [PromoCodeFilter!]

  """Filter by the object’s `partnerPageSlug` field."""
  partnerPageSlug: StringFilter

  """Filter by the object’s `partnerPages` relation."""
  partnerPages: PromoCodeToManyPartnerPageFilter

  """Some related `partnerPages` exist."""
  partnerPagesExist: Boolean

  """Filter by the object’s `promoCodeAffiliates` relation."""
  promoCodeAffiliates: PromoCodeToManyPromoCodeAffiliateFilter

  """Some related `promoCodeAffiliates` exist."""
  promoCodeAffiliatesExist: Boolean

  """Filter by the object’s `promoCodeUseds` relation."""
  promoCodeUseds: PromoCodeToManyPromoCodeUsedFilter

  """Some related `promoCodeUseds` exist."""
  promoCodeUsedsExist: Boolean

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `type` field."""
  type: PromoCodeTypeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `usedCount` field."""
  usedCount: BigIntFilter

  """Filter by the object’s `uses` field."""
  uses: IntFilter

  """Filter by the object’s `validFrom` field."""
  validFrom: DatetimeFilter
}

"""An input for mutations affecting `PromoCode`"""
input PromoCodeInput {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String!

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID
  name: String!
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType!

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""The globally unique `ID` look up for the row to connect."""
input PromoCodeNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `promoCode` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `partnerPage` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `partnerPage` being updated.
  """
  patch: PartnerPagePatch!
}

"""The fields on `promoCode` to look up the row to update."""
input PromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPromoCodeCodeKeyUpdate {
  code: String!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: updatePromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyPatch!
}

"""The fields on `promoCode` to look up the row to update."""
input PromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyUsingPromoCodePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: updatePromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCodeAffiliate` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCodeAffiliate` being updated.
  """
  patch: PromoCodeAffiliatePatch!
}

"""The fields on `promoCode` to look up the row to update."""
input PromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyUsingPromoCodeCodeKeyUpdate {
  code: String!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: updatePromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyPatch!
}

"""The fields on `promoCode` to look up the row to update."""
input PromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyUsingPromoCodePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: updatePromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCodeUsed` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCodeUsed` being updated.
  """
  patch: PromoCodeUsedPatch!
}

"""The fields on `promoCode` to look up the row to update."""
input PromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyUsingPromoCodeCodeKeyUpdate {
  code: String!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: updatePromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyPatch!
}

"""The fields on `promoCode` to look up the row to update."""
input PromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyUsingPromoCodePkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: updatePromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyPatch!
}

"""
Represents an update to a `PromoCode`. Fields that are set will be updated.
"""
input PromoCodePatch {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""The fields on `promoCode` to look up the row to connect."""
input PromoCodePromoCodeCodeKeyConnect {
  code: String!
}

"""The fields on `promoCode` to look up the row to connect."""
input PromoCodePromoCodePkeyConnect {
  id: UUID!
}

"""
A filter to be used against many `PartnerPage` object types. All fields are combined with a logical ‘and.’
"""
input PromoCodeToManyPartnerPageFilter {
  """
  Every related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PartnerPageFilter

  """
  No related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PartnerPageFilter

  """
  Some related `PartnerPage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PartnerPageFilter
}

"""
A filter to be used against many `PromoCodeAffiliate` object types. All fields are combined with a logical ‘and.’
"""
input PromoCodeToManyPromoCodeAffiliateFilter {
  """
  Every related `PromoCodeAffiliate` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PromoCodeAffiliateFilter

  """
  No related `PromoCodeAffiliate` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PromoCodeAffiliateFilter

  """
  Some related `PromoCodeAffiliate` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PromoCodeAffiliateFilter
}

"""
A filter to be used against many `PromoCodeUsed` object types. All fields are combined with a logical ‘and.’
"""
input PromoCodeToManyPromoCodeUsedFilter {
  """
  Every related `PromoCodeUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PromoCodeUsedFilter

  """
  No related `PromoCodeUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PromoCodeUsedFilter

  """
  Some related `PromoCodeUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PromoCodeUsedFilter
}

enum PromoCodeType {
  AFFILIATE
  DISCOUNT
  GRATIS
}

"""
A filter to be used against PromoCodeType fields. All fields are combined with a logical ‘and.’
"""
input PromoCodeTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: PromoCodeType

  """Equal to the specified value."""
  equalTo: PromoCodeType

  """Greater than the specified value."""
  greaterThan: PromoCodeType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: PromoCodeType

  """Included in the specified list."""
  in: [PromoCodeType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: PromoCodeType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: PromoCodeType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: PromoCodeType

  """Not equal to the specified value."""
  notEqualTo: PromoCodeType

  """Not included in the specified list."""
  notIn: [PromoCodeType!]
}

type PromoCodeUsed implements Node {
  createdAt: Datetime

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  origin: PromoCodeUsedOrigin

  """Reads a single `PromoCode` that is related to this `PromoCodeUsed`."""
  promoCode: PromoCode
  promoCodeId: UUID!

  """Reads a single `User` that is related to this `PromoCodeUsed`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `PromoCodeUsed` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PromoCodeUsedCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `origin` field."""
  origin: PromoCodeUsedOrigin

  """Checks for equality with the object’s `promoCodeId` field."""
  promoCodeId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `PromoCodeUsed` object types. All fields are combined with a logical ‘and.’
"""
input PromoCodeUsedFilter {
  """Checks for all expressions in this list."""
  and: [PromoCodeUsedFilter!]

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Negates the expression."""
  not: PromoCodeUsedFilter

  """Checks for any expressions in this list."""
  or: [PromoCodeUsedFilter!]

  """Filter by the object’s `origin` field."""
  origin: PromoCodeUsedOriginFilter

  """Filter by the object’s `promoCode` relation."""
  promoCode: PromoCodeFilter

  """Filter by the object’s `promoCodeId` field."""
  promoCodeId: UUIDFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""
Input for the nested mutation of `promoCode` in the `PromoCodeUsedInput` mutation.
"""
input PromoCodeUsedIdFkeyInput {
  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectByCode: PromoCodePromoCodeCodeKeyConnect

  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectById: PromoCodePromoCodePkeyConnect

  """
  The primary key(s) for `promoCode` for the far side of the relationship.
  """
  connectByNodeId: PromoCodeNodeIdConnect

  """
  A `PromoCodeInput` object that will be created and connected to this object.
  """
  create: PromoCodeUsedIdFkeyPromoCodeCreateInput

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateByCode: PromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyUsingPromoCodeCodeKeyUpdate

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateById: PromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyUsingPromoCodePkeyUpdate

  """
  The primary key(s) and patch data for `promoCode` for the far side of the relationship.
  """
  updateByNodeId: PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `promoCodeUsed` in the `PromoCodeInput` mutation.
"""
input PromoCodeUsedIdFkeyInverseInput {
  """
  The primary key(s) for `promoCodeUsed` for the far side of the relationship.
  """
  connectByNodeId: [PromoCodeUsedNodeIdConnect!]

  """
  The primary key(s) for `promoCodeUsed` for the far side of the relationship.
  """
  connectByPromoCodeIdAndUserId: [PromoCodeUsedPromoCodeUsedPkeyConnect!]

  """
  The primary key(s) and patch data for `promoCodeUsed` for the far side of the relationship.
  """
  updateByNodeId: [PromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `promoCodeUsed` for the far side of the relationship.
  """
  updateByPromoCodeIdAndUserId: [PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedIdFkeyUsingPromoCodeUsedPkeyUpdate!]
}

"""The `promoCode` to be created by this mutation."""
input PromoCodeUsedIdFkeyPromoCodeCreateInput {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String!

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID
  name: String!
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType!

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""The globally unique `ID` look up for the row to connect."""
input PromoCodeUsedNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `promoCodeUsed` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCode` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCode` being updated.
  """
  patch: PromoCodePatch!
}

"""The fields on `promoCodeUsed` to look up the row to update."""
input PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedIdFkeyUsingPromoCodeUsedPkeyUpdate {
  """
  An object where the defined keys will be set on the `promoCodeUsed` being updated.
  """
  patch: updatePromoCodeUsedOnPromoCodeUsedForPromoCodeUsedIdFkeyPatch!
  promoCodeId: UUID!
  userId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `promoCodeUsed` to look up the row to update."""
input PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedUserIdFkeyUsingPromoCodeUsedPkeyUpdate {
  """
  An object where the defined keys will be set on the `promoCodeUsed` being updated.
  """
  patch: updatePromoCodeUsedOnPromoCodeUsedForPromoCodeUsedUserIdFkeyPatch!
  promoCodeId: UUID!
  userId: UUID!
}

enum PromoCodeUsedOrigin {
  CHECKOUT
  REGISTRATION
}

"""
A filter to be used against PromoCodeUsedOrigin fields. All fields are combined with a logical ‘and.’
"""
input PromoCodeUsedOriginFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: PromoCodeUsedOrigin

  """Equal to the specified value."""
  equalTo: PromoCodeUsedOrigin

  """Greater than the specified value."""
  greaterThan: PromoCodeUsedOrigin

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: PromoCodeUsedOrigin

  """Included in the specified list."""
  in: [PromoCodeUsedOrigin!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: PromoCodeUsedOrigin

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: PromoCodeUsedOrigin

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: PromoCodeUsedOrigin

  """Not equal to the specified value."""
  notEqualTo: PromoCodeUsedOrigin

  """Not included in the specified list."""
  notIn: [PromoCodeUsedOrigin!]
}

"""
Represents an update to a `PromoCodeUsed`. Fields that are set will be updated.
"""
input PromoCodeUsedPatch {
  createdAt: Datetime
  origin: PromoCodeUsedOrigin
  promoCode: PromoCodeUsedIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeUsedUserIdFkeyInput
  userId: UUID
}

"""The fields on `promoCodeUsed` to look up the row to connect."""
input PromoCodeUsedPromoCodeUsedPkeyConnect {
  promoCodeId: UUID!
  userId: UUID!
}

"""
Input for the nested mutation of `user` in the `PromoCodeUsedInput` mutation.
"""
input PromoCodeUsedUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnPromoCodeUsedForPromoCodeUsedUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `promoCodeUsed` in the `UserInput` mutation.
"""
input PromoCodeUsedUserIdFkeyInverseInput {
  """
  The primary key(s) for `promoCodeUsed` for the far side of the relationship.
  """
  connectByNodeId: [PromoCodeUsedNodeIdConnect!]

  """
  The primary key(s) for `promoCodeUsed` for the far side of the relationship.
  """
  connectByPromoCodeIdAndUserId: [PromoCodeUsedPromoCodeUsedPkeyConnect!]

  """
  The primary key(s) and patch data for `promoCodeUsed` for the far side of the relationship.
  """
  updateByNodeId: [UserOnPromoCodeUsedForPromoCodeUsedUserIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `promoCodeUsed` for the far side of the relationship.
  """
  updateByPromoCodeIdAndUserId: [PromoCodeUsedOnPromoCodeUsedForPromoCodeUsedUserIdFkeyUsingPromoCodeUsedPkeyUpdate!]
}

"""A connection to a list of `PromoCodeUsed` values."""
type PromoCodeUsedsConnection {
  """
  A list of edges which contains the `PromoCodeUsed` and cursor to aid in pagination.
  """
  edges: [PromoCodeUsedsEdge!]!

  """A list of `PromoCodeUsed` objects."""
  nodes: [PromoCodeUsed!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PromoCodeUsed` you could get from the connection."""
  totalCount: Int!
}

"""A `PromoCodeUsed` edge in the connection."""
type PromoCodeUsedsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PromoCodeUsed` at the end of the edge."""
  node: PromoCodeUsed!
}

"""Methods to use when ordering `PromoCodeUsed`."""
enum PromoCodeUsedsOrderBy {
  CREATED_AT_ASC
  CREATED_AT_DESC
  NATURAL
  ORIGIN_ASC
  ORIGIN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  PROMO_CODE_ID_ASC
  PROMO_CODE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""A connection to a list of `PromoCode` values."""
type PromoCodesConnection {
  """
  A list of edges which contains the `PromoCode` and cursor to aid in pagination.
  """
  edges: [PromoCodesEdge!]!

  """A list of `PromoCode` objects."""
  nodes: [PromoCode!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PromoCode` you could get from the connection."""
  totalCount: Int!
}

"""A `PromoCode` edge in the connection."""
type PromoCodesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PromoCode` at the end of the edge."""
  node: PromoCode!
}

"""Methods to use when ordering `PromoCode`."""
enum PromoCodesOrderBy {
  AFFILIATE_PERCENT_ASC
  AFFILIATE_PERCENT_DESC
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CODE_ASC
  CODE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  DISCOUNT_PERCENT_ASC
  DISCOUNT_PERCENT_DESC
  DURATION_ASC
  DURATION_DESC
  EXPIRES_AT_ASC
  EXPIRES_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USES_ASC
  USES_DESC
  VALID_FROM_ASC
  VALID_FROM_DESC
}

type ProposalPreview {
  agent: User
  agentEmail: String
  clientPerson: ClientPerson
  id: String
  latestResponse: ProposalResponseLog
  organisation: Organisation
  trip: Trip
}

"""All input for the `proposalRespond` mutation."""
input ProposalRespondInput {
  agentId: UUID!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  personId: UUID!
  response: ProposalResponse!
  tripId: UUID!
}

"""The output of our `proposalRespond` mutation."""
type ProposalRespondPayload {
  """Reads a single `User` that is related to this `ProposalResponseLog`."""
  agent: User

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Organisation` that is related to this `ProposalResponseLog`.
  """
  organisation: Organisation

  """
  Reads a single `ClientPerson` that is related to this `ProposalResponseLog`.
  """
  person: ClientPerson
  proposalResponseLog: ProposalResponseLog

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `ProposalResponseLog`."""
  trip: Trip
}

enum ProposalResponse {
  ACCEPT
  REJECT
}

type ProposalResponseLog implements Node {
  """Reads a single `User` that is related to this `ProposalResponseLog`."""
  agent: User
  agentId: UUID!

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads a single `Organisation` that is related to this `ProposalResponseLog`.
  """
  organisation: Organisation
  organisationId: UUID!

  """
  Reads a single `ClientPerson` that is related to this `ProposalResponseLog`.
  """
  person: ClientPerson
  personId: UUID!
  response: ProposalResponse!

  """Reads a single `Trip` that is related to this `ProposalResponseLog`."""
  trip: Trip
  tripId: UUID!

  """When this item was updated"""
  updatedAt: Datetime
}

"""The root query type which gives access points into the data universe."""
type Query implements Node {
  account(userId: UUID!): Account
  activeOrganisation: Organisation
  activeSubscriptions: Int
  airline(iata: String!): Airline
  airport(iata: String!): Airport

  """Reads and enables pagination through a set of `Job`."""
  allJobs(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: JobFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
  ): JobsConnection

  """Reads and enables pagination through a set of `Job`."""
  allJobsList(
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: JobFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
  ): [Job!]
  asset(id: UUID!): Asset

  """Reads and enables pagination through a set of `Asset`."""
  assets(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssetFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Asset`."""
    orderBy: [AssetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssetsConnection

  """Reads a set of `Asset`."""
  assetsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssetFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Asset`."""
    orderBy: [AssetsOrderBy!]
  ): [Asset!]
  attachment(id: UUID!): Attachment

  """Get the cards responsible for this trip/day/type's budget"""
  budgetCards(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor
    day: Int

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    tripId: UUID!
    type: String
  ): CardsConnection

  """Get the cards responsible for this trip/day/type's budget"""
  budgetCardsList(
    day: Int

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
    tripId: UUID!
    type: String
  ): [Card!]
  canAccess(role: CollaborationRole, tripId: UUID!): Boolean
  card(id: UUID!): Card
  cardCost(id: UUID!): CardCost

  """Reads and enables pagination through a set of `Card`."""
  cards(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsConnection

  """Reads a set of `Card`."""
  cardsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!]
  ): [Card!]

  """Reads and enables pagination through a set of `CardsOverTime`."""
  cardsOverTimes(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardsOverTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardsOverTimeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CardsOverTime`."""
    orderBy: [CardsOverTimesOrderBy!] = [NATURAL]
  ): CardsOverTimesConnection

  """Reads a set of `CardsOverTime`."""
  cardsOverTimesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardsOverTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardsOverTimeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CardsOverTime`."""
    orderBy: [CardsOverTimesOrderBy!]
  ): [CardsOverTime!]
  client(id: UUID!): Client
  clientOrganisation(id: UUID!): ClientOrganisation
  clientOrganisationContact(organisationId: UUID!, personId: UUID!): ClientOrganisationContact
  clientPerson(id: UUID!): ClientPerson

  """Reads and enables pagination through a set of `Client`."""
  clients(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientsConnection

  """Reads a set of `Client`."""
  clientsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!]
  ): [Client!]
  collaborator(tripId: UUID!, userId: UUID!): Collaborator
  continent(id: UUID!): Continent

  """Reads and enables pagination through a set of `Continent`."""
  continents(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContinentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ContinentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Continent`."""
    orderBy: [ContinentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContinentsConnection

  """Reads a set of `Continent`."""
  continentsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContinentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ContinentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Continent`."""
    orderBy: [ContinentsOrderBy!]
  ): [Continent!]
  convertCurrency(amount: Float, originId: UUID!, targetId: UUID!): Float
  costItem(id: UUID!): CostItem
  costTax(id: UUID!): CostTax

  """Reads and enables pagination through a set of `CostTax`."""
  costTaxes(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostTaxCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostTaxFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostTaxesConnection

  """Reads a set of `CostTax`."""
  costTaxesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CostTaxCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CostTaxFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!]
  ): [CostTax!]

  """Reads and enables pagination through a set of `Country`."""
  countries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesConnection

  """Reads a set of `Country`."""
  countriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!]
  ): [Country!]
  country(id: UUID!): Country

  """Reads and enables pagination through a set of `CountryTripCount`."""
  countryTripCounts(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryTripCountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryTripCountFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `CountryTripCount`."""
    orderBy: [CountryTripCountsOrderBy!] = [NATURAL]
  ): CountryTripCountsConnection

  """Reads a set of `CountryTripCount`."""
  countryTripCountsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryTripCountCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CountryTripCountFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `CountryTripCount`."""
    orderBy: [CountryTripCountsOrderBy!]
  ): [CountryTripCount!]

  """Reads and enables pagination through a set of `Currency`."""
  currencies(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CurrencyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesConnection

  """Reads a set of `Currency`."""
  currenciesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CurrencyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CurrencyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!]
  ): [Currency!]
  currency(id: UUID!): Currency
  currencyCountry(countryId: UUID!, currencyId: UUID!): CurrencyCountry
  editLock(key: String!): EditLock

  """Reads and enables pagination through a set of `EditLock`."""
  editLocks(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EditLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EditLockFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `EditLock`."""
    orderBy: [EditLocksOrderBy!] = [PRIMARY_KEY_ASC]
  ): EditLocksConnection

  """Reads a set of `EditLock`."""
  editLocksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EditLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EditLockFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `EditLock`."""
    orderBy: [EditLocksOrderBy!]
  ): [EditLock!]
  getGlobalStats: GlobalStat
  getLatestProposalResponse(tripId: UUID!): ProposalResponseLog
  getMiscTripStats: [MiscTripStat]
  getOrganisationInvite(code: String!): JSON
  getSetting(key: String!): JSON
  getTripBudgetValueCount: TripBudgetValueCount
  getTripsBudgetTypeCount: TripsBudgetTypeCount
  getTripsGroupLength: TripGroupLength
  getUpgradedStats: UpgradedStat
  grati(id: UUID!): Grati

  """Reads and enables pagination through a set of `Grati`."""
  gratis(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratiFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Grati`."""
    orderBy: [GratisOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisConnection @deprecated(reason: "Use Promo Codes")

  """Reads a set of `Grati`."""
  gratisList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratiCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratiFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Grati`."""
    orderBy: [GratisOrderBy!]
  ): [Grati!] @deprecated(reason: "Use Promo Codes")
  gratisUsed(gratisId: UUID!, userId: UUID!): GratisUsed

  """Reads and enables pagination through a set of `GratisUsed`."""
  gratisUseds(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratisUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratisUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisUsedsConnection

  """Reads a set of `GratisUsed`."""
  gratisUsedsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratisUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratisUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!]
  ): [GratisUsed!]
  hasTier(tiers: [String]!, tripId: UUID!): Boolean
  hasValidSession: Boolean!
  humanToTrip(uri: String!): Trip
  inviteV2(id: UUID!): InviteV2
  isCurrentUserCollaborator(tripId: UUID!): Boolean
  isOwnerPlus(ownerId: UUID!): Boolean
  language(id: UUID!): Language
  languageCountry(countryId: UUID!, languageId: UUID!): LanguageCountry

  """Reads and enables pagination through a set of `Language`."""
  languages(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LanguageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Language`."""
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesConnection

  """Reads a set of `Language`."""
  languagesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: LanguageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Language`."""
    orderBy: [LanguagesOrderBy!]
  ): [Language!]
  logFile(name: String): [String]
  logFiles: [String]

  """Returns markers for all the users trips"""
  markers: [Marker]
  meta(id: UUID!): Meta

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!
  organisation(id: UUID!): Organisation
  organisationInvite(id: UUID!): OrganisationInvite

  """Reads and enables pagination through a set of `OrganisationInvite`."""
  organisationInvites(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationInviteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationInviteFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationInvitesConnection

  """Reads a set of `OrganisationInvite`."""
  organisationInvitesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationInviteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationInviteFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!]
  ): [OrganisationInvite!]
  organisationTier(id: UUID!): OrganisationTier

  """Reads and enables pagination through a set of `OrganisationTier`."""
  organisationTiers(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationTierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationTierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OrganisationTier`."""
    orderBy: [OrganisationTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationTiersConnection

  """Reads a set of `OrganisationTier`."""
  organisationTiersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationTierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationTierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OrganisationTier`."""
    orderBy: [OrganisationTiersOrderBy!]
  ): [OrganisationTier!]
  organisationUser(organisationId: UUID!, userId: UUID!): OrganisationUser

  """Reads and enables pagination through a set of `Organisation`."""
  organisations(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsConnection

  """Reads a set of `Organisation`."""
  organisationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!]
  ): [Organisation!]
  outlet(id: UUID!): Outlet
  outletCountry(countryId: UUID!, outletId: UUID!): OutletCountry

  """Reads and enables pagination through a set of `Outlet`."""
  outlets(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutletCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutletFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Outlet`."""
    orderBy: [OutletsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletsConnection

  """Reads a set of `Outlet`."""
  outletsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OutletCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OutletFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Outlet`."""
    orderBy: [OutletsOrderBy!]
  ): [Outlet!]
  partnerPage(id: UUID!): PartnerPage
  partnerPageSlugs: [String!]

  """Reads and enables pagination through a set of `PartnerPage`."""
  partnerPages(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesConnection

  """Reads a set of `PartnerPage`."""
  partnerPagesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PartnerPageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PartnerPageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!]
  ): [PartnerPage!]
  ping: String!
  place(id: String!): Place

  """Reads and enables pagination through a set of `Place`."""
  places(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Place`."""
    orderBy: [PlacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlacesConnection

  """Reads a set of `Place`."""
  placesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlaceCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PlaceFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Place`."""
    orderBy: [PlacesOrderBy!]
  ): [Place!]
  prices: [Price!]
  products: [Product!] @deprecated(reason: "User `Query.prices`")
  promoCode(id: UUID!): PromoCode
  promoCodeAffiliate(promoCodeId: UUID!, userId: UUID!): PromoCodeAffiliate

  """Reads and enables pagination through a set of `PromoCodeAffiliate`."""
  promoCodeAffiliates(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeAffiliateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeAffiliateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeAffiliatesConnection

  """Reads a set of `PromoCodeAffiliate`."""
  promoCodeAffiliatesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeAffiliateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeAffiliateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!]
  ): [PromoCodeAffiliate!]
  promoCodeUsed(promoCodeId: UUID!, userId: UUID!): PromoCodeUsed

  """Reads and enables pagination through a set of `PromoCodeUsed`."""
  promoCodeUseds(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCodeUsed`."""
    orderBy: [PromoCodeUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeUsedsConnection

  """Reads a set of `PromoCodeUsed`."""
  promoCodeUsedsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCodeUsed`."""
    orderBy: [PromoCodeUsedsOrderBy!]
  ): [PromoCodeUsed!]
  promoCodeVerify(code: String!, userId: UUID): Boolean

  """Reads and enables pagination through a set of `PromoCode`."""
  promoCodes(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCode`."""
    orderBy: [PromoCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodesConnection

  """Reads a set of `PromoCode`."""
  promoCodesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCode`."""
    orderBy: [PromoCodesOrderBy!]
  ): [PromoCode!]
  proposalView(agentId: UUID!, clientPersonId: UUID!, tripId: UUID!): ProposalPreview
  purchaseHistory: [Charge!]

  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!
  rebuildShareUi(id: UUID!): String
  region(id: UUID!): Region

  """Reads and enables pagination through a set of `Region`."""
  regions(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsConnection

  """Reads a set of `Region`."""
  regionsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: RegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!]
  ): [Region!]

  """Reads and enables pagination through a set of `Catalogue`."""
  search(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CatalogueFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    query: String!
  ): CataloguesConnection

  """Reads and enables pagination through a set of `Discover`."""
  searchDiscover(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiscoverFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int
    query: String!
  ): DiscoversConnection

  """Reads and enables pagination through a set of `Discover`."""
  searchDiscoverList(
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: DiscoverFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
    query: String!
  ): [Discover!]

  """Reads and enables pagination through a set of `Catalogue`."""
  searchList(
    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CatalogueFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int
    query: String!
  ): [Catalogue!]
  setting(userId: UUID!): Setting

  """Reads and enables pagination through a set of `Setting`."""
  settings(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SettingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SettingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsConnection @deprecated(reason: "Use Trip.appearance")

  """Reads a set of `Setting`."""
  settingsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SettingCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SettingFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!]
  ): [Setting!] @deprecated(reason: "Use Trip.appearance")
  slugToPartnerPage(slug: String!): PartnerPage
  slugToPartnerPageBackground(slug: String!): Asset
  slugToPartnerPageGratis(slug: String!): PromoCode @deprecated(reason: "Use `slugToPartnerPagePromo`")
  slugToPartnerPageLogo(slug: String!): Asset
  slugToPartnerPagePromo(slug: String!): PromoCode
  stripeKey: String!
  subscriptionLog(id: UUID!): SubscriptionLog

  """Reads and enables pagination through a set of `SubscriptionLog`."""
  subscriptionLogs(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SubscriptionLogFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionLogsConnection

  """Reads a set of `SubscriptionLog`."""
  subscriptionLogsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SubscriptionLogFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!]
  ): [SubscriptionLog!]
  supplier(id: UUID!): Supplier

  """Reads and enables pagination through a set of `SupplierCategory`."""
  supplierCategories(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierCategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SupplierCategory`."""
    orderBy: [SupplierCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierCategoriesConnection

  """Reads a set of `SupplierCategory`."""
  supplierCategoriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCategoryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierCategoryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SupplierCategory`."""
    orderBy: [SupplierCategoriesOrderBy!]
  ): [SupplierCategory!]
  supplierCategory(id: UUID!): SupplierCategory
  supplierTag(supplierId: UUID!, tagId: UUID!): SupplierTag

  """Reads and enables pagination through a set of `Supplier`."""
  suppliers(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersConnection

  """Reads a set of `Supplier`."""
  suppliersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!]
  ): [Supplier!]
  tag(id: UUID!): Tag
  tagTrip(tagId: UUID!, tripId: UUID!): TagTrip

  """Reads and enables pagination through a set of `Tag`."""
  tags(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsConnection

  """Reads a set of `Tag`."""
  tagsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!]
  ): [Tag!]
  task(id: UUID!): Task

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksConnection

  """Reads a set of `Task`."""
  tasksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!]
  ): [Task!]
  template(id: UUID!): Trip

  """Reads and enables pagination through a set of `Template`."""
  templates(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TemplateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TemplateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Template`."""
    orderBy: [TemplatesOrderBy!] = [NATURAL]
  ): TemplatesConnection

  """Reads a set of `Template`."""
  templatesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TemplateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TemplateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Template`."""
    orderBy: [TemplatesOrderBy!]
  ): [Template!]
  trip(id: UUID!): Trip
  tripAssetImage(assetId: UUID!, tripId: UUID!): TripAssetImage
  tripCountry(countryId: UUID!, tripId: UUID!): TripCountry

  """Reads and enables pagination through a set of `TripDateFrequency`."""
  tripDateFrequencies(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripDateFrequencyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripDateFrequencyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripDateFrequency`."""
    orderBy: [TripDateFrequenciesOrderBy!] = [NATURAL]
  ): TripDateFrequenciesConnection

  """Reads a set of `TripDateFrequency`."""
  tripDateFrequenciesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripDateFrequencyCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripDateFrequencyFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripDateFrequency`."""
    orderBy: [TripDateFrequenciesOrderBy!]
  ): [TripDateFrequency!]
  tripRegion(regionId: UUID!, tripId: UUID!): TripRegion

  """
  Reads and enables pagination through a set of `TripTimeBetweenCreateAndStart`.
  """
  tripTimeBetweenCreateAndStarts(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripTimeBetweenCreateAndStartCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripTimeBetweenCreateAndStartFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripTimeBetweenCreateAndStart`."""
    orderBy: [TripTimeBetweenCreateAndStartsOrderBy!] = [NATURAL]
  ): TripTimeBetweenCreateAndStartsConnection

  """Reads a set of `TripTimeBetweenCreateAndStart`."""
  tripTimeBetweenCreateAndStartsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripTimeBetweenCreateAndStartCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripTimeBetweenCreateAndStartFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripTimeBetweenCreateAndStart`."""
    orderBy: [TripTimeBetweenCreateAndStartsOrderBy!]
  ): [TripTimeBetweenCreateAndStart!]

  """Reads and enables pagination through a set of `Trip`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection

  """Reads a set of `Trip`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]

  """Reads and enables pagination through a set of `TripsOverTime`."""
  tripsOverTimes(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripsOverTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripsOverTimeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripsOverTime`."""
    orderBy: [TripsOverTimesOrderBy!] = [NATURAL]
  ): TripsOverTimesConnection

  """Reads a set of `TripsOverTime`."""
  tripsOverTimesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripsOverTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripsOverTimeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripsOverTime`."""
    orderBy: [TripsOverTimesOrderBy!]
  ): [TripsOverTime!]
  tripsWithDates(noDates: Boolean): BigInt
  user(id: UUID!): User

  """Reads and enables pagination through a set of `UserCountPerCountry`."""
  userCountPerCountries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCountPerCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserCountPerCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `UserCountPerCountry`."""
    orderBy: [UserCountPerCountriesOrderBy!] = [NATURAL]
  ): UserCountPerCountriesConnection

  """Reads a set of `UserCountPerCountry`."""
  userCountPerCountriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCountPerCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserCountPerCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `UserCountPerCountry`."""
    orderBy: [UserCountPerCountriesOrderBy!]
  ): [UserCountPerCountry!]
  userPreference(userId: UUID!): UserPreference

  """Reads and enables pagination through a set of `User`."""
  users(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersConnection

  """Reads a set of `User`."""
  usersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!]
  ): [User!]

  """Reads and enables pagination through a set of `UsersOverTime`."""
  usersOverTimes(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsersOverTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UsersOverTimeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `UsersOverTime`."""
    orderBy: [UsersOverTimesOrderBy!] = [NATURAL]
  ): UsersOverTimesConnection

  """Reads a set of `UsersOverTime`."""
  usersOverTimesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UsersOverTimeCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: UsersOverTimeFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `UsersOverTime`."""
    orderBy: [UsersOverTimesOrderBy!]
  ): [UsersOverTime!]
  validateGratis(code: String!): Boolean
  viewer: User
  viewerCollaborationRole(tripId: UUID!): CollaborationRole

  """Reads and enables pagination through a set of `ViewerOrganisation`."""
  viewerOrganisations(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ViewerOrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ViewerOrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ViewerOrganisation`."""
    orderBy: [ViewerOrganisationsOrderBy!] = [NATURAL]
  ): ViewerOrganisationsConnection

  """Reads a set of `ViewerOrganisation`."""
  viewerOrganisationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ViewerOrganisationCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ViewerOrganisationFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ViewerOrganisation`."""
    orderBy: [ViewerOrganisationsOrderBy!]
  ): [ViewerOrganisation!]
  viewerReferrer: Referrer
  viewerStats: ViewerStatistic

  """Quick access to the viewers tier"""
  viewerTier: Tier
}

"""All input for the `queueJob` mutation."""
input QueueJobInput {
  args: JSON!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
}

"""The output of our `queueJob` mutation."""
type QueueJobPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Referrer {
  """Reads a single `Asset` that is related to this `Referrer`."""
  background: Asset
  backgroundId: UUID
  discount: Int

  """Reads a single `Asset` that is related to this `Referrer`."""
  logo: Asset
  logoId: UUID
  name: String
}

"""
A filter to be used against `Referrer` object types. All fields are combined with a logical ‘and.’
"""
input ReferrerFilter {
  """Checks for all expressions in this list."""
  and: [ReferrerFilter!]

  """Filter by the object’s `background` relation."""
  background: AssetFilter

  """A related `background` exists."""
  backgroundExists: Boolean

  """Filter by the object’s `backgroundId` field."""
  backgroundId: UUIDFilter

  """Filter by the object’s `discount` field."""
  discount: IntFilter

  """Filter by the object’s `logo` relation."""
  logo: AssetFilter

  """A related `logo` exists."""
  logoExists: Boolean

  """Filter by the object’s `logoId` field."""
  logoId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: ReferrerFilter

  """Checks for any expressions in this list."""
  or: [ReferrerFilter!]
}

type Region implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads a single `Country` that is related to this `Region`."""
  country: Country
  countryId: UUID

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """Reads a single `Asset` that is related to this `Region`."""
  image: Asset
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: Location
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """When this item was restored"""
  restoredAt: Datetime
  slug: String
  timezone(timestamp: Datetime, tripId: UUID): Timezone

  """Reads and enables pagination through a set of `TripRegion`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripRegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripRegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripRegionsConnection!

  """Reads and enables pagination through a set of `TripRegion`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripRegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripRegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!]
  ): [TripRegion!]!

  """When this item was updated"""
  updatedAt: Datetime
}

"""
A condition to be used against `Region` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RegionCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `location` field."""
  location: LocationInput

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""The `country` to be created by this mutation."""
input RegionCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `RegionInput` mutation.
"""
input RegionCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: RegionCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnRegionForRegionCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnRegionForRegionCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: RegionOnRegionForRegionCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnRegionForRegionCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `region` in the `CountryInput` mutation.
"""
input RegionCountryIdFkeyInverseInput {
  """The primary key(s) for `region` for the far side of the relationship."""
  connectById: [RegionRegionPkeyConnect!]

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByName: [RegionRegionNameKeyConnect!]

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByNodeId: [RegionNodeIdConnect!]

  """The primary key(s) for `region` for the far side of the relationship."""
  connectBySlug: [RegionRegionSlugKeyConnect!]

  """
  A `RegionInput` object that will be created and connected to this object.
  """
  create: [RegionCountryIdFkeyRegionCreateInput!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteById: [RegionRegionPkeyDelete!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByName: [RegionRegionNameKeyDelete!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByNodeId: [RegionNodeIdDelete!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteBySlug: [RegionRegionSlugKeyDelete!]

  """
  Flag indicating whether all other `region` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateById: [RegionOnRegionForRegionCountryIdFkeyUsingRegionPkeyUpdate!]

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByName: [RegionOnRegionForRegionCountryIdFkeyUsingRegionNameKeyUpdate!]

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnRegionForRegionCountryIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateBySlug: [RegionOnRegionForRegionCountryIdFkeyUsingRegionSlugKeyUpdate!]
}

"""The `region` to be created by this mutation."""
input RegionCountryIdFkeyRegionCreateInput {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""
A filter to be used against `Region` object types. All fields are combined with a logical ‘and.’
"""
input RegionFilter {
  """Checks for all expressions in this list."""
  and: [RegionFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """A related `country` exists."""
  countryExists: Boolean

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `image` relation."""
  image: AssetFilter

  """A related `image` exists."""
  imageExists: Boolean

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `location` field."""
  location: LocationFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: RegionFilter

  """Checks for any expressions in this list."""
  or: [RegionFilter!]

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `slug` field."""
  slug: StringFilter

  """Filter by the object’s `trips` relation."""
  trips: RegionToManyTripRegionFilter

  """Some related `trips` exist."""
  tripsExist: Boolean

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""The `asset` to be created by this mutation."""
input RegionImageIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
Input for the nested mutation of `asset` in the `RegionInput` mutation.
"""
input RegionImageIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: RegionImageIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnRegionForRegionImageIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: RegionOnRegionForRegionImageIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `region` in the `AssetInput` mutation.
"""
input RegionImageIdFkeyInverseInput {
  """The primary key(s) for `region` for the far side of the relationship."""
  connectById: [RegionRegionPkeyConnect!]

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByName: [RegionRegionNameKeyConnect!]

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByNodeId: [RegionNodeIdConnect!]

  """The primary key(s) for `region` for the far side of the relationship."""
  connectBySlug: [RegionRegionSlugKeyConnect!]

  """
  A `RegionInput` object that will be created and connected to this object.
  """
  create: [RegionImageIdFkeyRegionCreateInput!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteById: [RegionRegionPkeyDelete!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByName: [RegionRegionNameKeyDelete!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByNodeId: [RegionNodeIdDelete!]

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteBySlug: [RegionRegionSlugKeyDelete!]

  """
  Flag indicating whether all other `region` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateById: [RegionOnRegionForRegionImageIdFkeyUsingRegionPkeyUpdate!]

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByName: [RegionOnRegionForRegionImageIdFkeyUsingRegionNameKeyUpdate!]

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnRegionForRegionImageIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateBySlug: [RegionOnRegionForRegionImageIdFkeyUsingRegionSlugKeyUpdate!]
}

"""The `region` to be created by this mutation."""
input RegionImageIdFkeyRegionCreateInput {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""An input for mutations affecting `Region`"""
input RegionInput {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""The globally unique `ID` look up for the row to connect."""
input RegionNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `region` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input RegionNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `region` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input RegionOnRegionForRegionCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnRegionForRegionCountryIdFkeyUsingRegionNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnRegionForRegionCountryIdFkeyPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnRegionForRegionCountryIdFkeyUsingRegionPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnRegionForRegionCountryIdFkeyPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnRegionForRegionCountryIdFkeyUsingRegionSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnRegionForRegionCountryIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input RegionOnRegionForRegionImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnRegionForRegionImageIdFkeyUsingRegionNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnRegionForRegionImageIdFkeyPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnRegionForRegionImageIdFkeyUsingRegionPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnRegionForRegionImageIdFkeyPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnRegionForRegionImageIdFkeyUsingRegionSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnRegionForRegionImageIdFkeyPatch!
  slug: String!
}

"""The globally unique `ID` look up for the row to update."""
input RegionOnTripRegionForTripRegionRegionIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tripRegion` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tripRegion` being updated.
  """
  patch: TripRegionPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnTripRegionForTripRegionRegionIdFkeyUsingRegionNameKeyUpdate {
  name: String!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnTripRegionForTripRegionRegionIdFkeyPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnTripRegionForTripRegionRegionIdFkeyUsingRegionPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnTripRegionForTripRegionRegionIdFkeyPatch!
}

"""The fields on `region` to look up the row to update."""
input RegionOnTripRegionForTripRegionRegionIdFkeyUsingRegionSlugKeyUpdate {
  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: updateRegionOnTripRegionForTripRegionRegionIdFkeyPatch!
  slug: String!
}

"""
Represents an update to a `Region`. Fields that are set will be updated.
"""
input RegionPatch {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""The fields on `region` to look up the row to connect."""
input RegionRegionNameKeyConnect {
  name: String!
}

"""The fields on `region` to look up the row to delete."""
input RegionRegionNameKeyDelete {
  name: String!
}

"""The fields on `region` to look up the row to connect."""
input RegionRegionPkeyConnect {
  id: UUID!
}

"""The fields on `region` to look up the row to delete."""
input RegionRegionPkeyDelete {
  id: UUID!
}

"""The fields on `region` to look up the row to connect."""
input RegionRegionSlugKeyConnect {
  slug: String!
}

"""The fields on `region` to look up the row to delete."""
input RegionRegionSlugKeyDelete {
  slug: String!
}

"""
A filter to be used against many `TripRegion` object types. All fields are combined with a logical ‘and.’
"""
input RegionToManyTripRegionFilter {
  """
  Every related `TripRegion` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripRegionFilter

  """
  No related `TripRegion` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripRegionFilter

  """
  Some related `TripRegion` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripRegionFilter
}

"""A connection to a list of `Region` values."""
type RegionsConnection {
  """
  A list of edges which contains the `Region` and cursor to aid in pagination.
  """
  edges: [RegionsEdge!]!

  """A list of `Region` objects."""
  nodes: [Region!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Region` you could get from the connection."""
  totalCount: Int!
}

"""A `Region` edge in the connection."""
type RegionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Region` at the end of the edge."""
  node: Region!
}

"""Methods to use when ordering `Region`."""
enum RegionsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  LOCATION_ASC
  LOCATION_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SLUG_ASC
  SLUG_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

input RegisterInput {
  agreeTerms: Boolean
  clientMutationId: String

  """The ID of their home country"""
  country: UUID
  email: String!
  fullName: String
  gratis: String
  password: String!
  session: Boolean
}

"""All input for the `releaseLock` mutation."""
input ReleaseLockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  key: String!
}

"""The output of our `releaseLock` mutation."""
type ReleaseLockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `removeExpoPushToken` mutation."""
input RemoveExpoPushTokenInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  token: String!
}

"""The output of our `removeExpoPushToken` mutation."""
type RemoveExpoPushTokenPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `requestPasswordReset` mutation."""
input RequestPasswordResetInput {
  browserName: String!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!
  operatingSystem: String!
}

"""The output of our `requestPasswordReset` mutation."""
type RequestPasswordResetPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `resendOrgInviteEmail` mutation."""
input ResendOrgInviteEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `resendOrgInviteEmail` mutation."""
type ResendOrgInviteEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `resendVerification` mutation."""
input ResendVerificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""The output of our `resendVerification` mutation."""
type ResendVerificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `resetPassword` mutation."""
input ResetPasswordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!
  newPassword: String!
}

"""The output of our `resetPassword` mutation."""
type ResetPasswordPayload {
  boolean: Boolean

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

enum Role {
  ADMIN
  AGENT
  MEMBER
}

"""
A filter to be used against Role fields. All fields are combined with a logical ‘and.’
"""
input RoleFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Role

  """Equal to the specified value."""
  equalTo: Role

  """Greater than the specified value."""
  greaterThan: Role

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Role

  """Included in the specified list."""
  in: [Role!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Role

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Role

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Role

  """Not equal to the specified value."""
  notEqualTo: Role

  """Not included in the specified list."""
  notIn: [Role!]
}

"""All input for the `saveAttachmentVisibilitySettings` mutation."""
input SaveAttachmentVisibilitySettingsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  patch: AttachmentVisibilitySettingsPatchRecordInput!
}

"""The output of our `saveAttachmentVisibilitySettings` mutation."""
type SaveAttachmentVisibilitySettingsPayload {
  attachmentVisibilitySetting: AttachmentVisibilitySetting

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `saveTripAppearance` mutation."""
input SaveTripAppearanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  settings: TripAppearanceInput!
  tripId: UUID!
}

"""The output of our `saveTripAppearance` mutation."""
type SaveTripAppearancePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `sendProposal` mutation."""
input SendProposalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  message: String!
  recipientIds: [UUID]!
  subject: String!
  tripId: UUID!
}

"""The output of our `sendProposal` mutation."""
type SendProposalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type SessionToken {
  success: Boolean
  token: String
}

"""All input for the `setCollaboratorRole` mutation."""
input SetCollaboratorRoleInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  role: CollaborationRole!
  tripId: UUID!
  userId: UUID!
}

"""The output of our `setCollaboratorRole` mutation."""
type SetCollaboratorRolePayload {
  """Reads a single `Asset` that is related to this `User`."""
  avatar: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `User`."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `setPassword` mutation."""
input SetPasswordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  newPassword: String!
  oldPassword: String!
}

"""The output of our `setPassword` mutation."""
type SetPasswordPayload {
  boolean: Boolean

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Setting implements Node {
  boldColours: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  showImageOnCard: Boolean

  """Reads a single `User` that is related to this `Setting`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `Setting` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input SettingCondition {
  """Checks for equality with the object’s `boldColours` field."""
  boldColours: Boolean

  """Checks for equality with the object’s `showImageOnCard` field."""
  showImageOnCard: Boolean

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `Setting` object types. All fields are combined with a logical ‘and.’
"""
input SettingFilter {
  """Checks for all expressions in this list."""
  and: [SettingFilter!]

  """Filter by the object’s `boldColours` field."""
  boldColours: BooleanFilter

  """Negates the expression."""
  not: SettingFilter

  """Checks for any expressions in this list."""
  or: [SettingFilter!]

  """Filter by the object’s `showImageOnCard` field."""
  showImageOnCard: BooleanFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `Setting`"""
input SettingInput {
  boldColours: Boolean
  showImageOnCard: Boolean
  user: SettingsUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input SettingNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `setting` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input SettingNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `setting` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input SettingOnSettingForSettingsUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `setting` to look up the row to update."""
input SettingOnSettingForSettingsUserIdFkeyUsingSettingsPkeyUpdate {
  """
  An object where the defined keys will be set on the `setting` being updated.
  """
  patch: updateSettingOnSettingForSettingsUserIdFkeyPatch!
  userId: UUID!
}

"""
Represents an update to a `Setting`. Fields that are set will be updated.
"""
input SettingPatch {
  boldColours: Boolean
  showImageOnCard: Boolean
  user: SettingsUserIdFkeyInput
  userId: UUID
}

"""The fields on `setting` to look up the row to connect."""
input SettingSettingsPkeyConnect {
  userId: UUID!
}

"""The fields on `setting` to look up the row to delete."""
input SettingSettingsPkeyDelete {
  userId: UUID!
}

"""A connection to a list of `Setting` values."""
type SettingsConnection {
  """
  A list of edges which contains the `Setting` and cursor to aid in pagination.
  """
  edges: [SettingsEdge!]!

  """A list of `Setting` objects."""
  nodes: [Setting!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Setting` you could get from the connection."""
  totalCount: Int!
}

"""A `Setting` edge in the connection."""
type SettingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Setting` at the end of the edge."""
  node: Setting!
}

"""Methods to use when ordering `Setting`."""
enum SettingsOrderBy {
  BOLD_COLOURS_ASC
  BOLD_COLOURS_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SHOW_IMAGE_ON_CARD_ASC
  SHOW_IMAGE_ON_CARD_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""
Input for the nested mutation of `user` in the `SettingInput` mutation.
"""
input SettingsUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnSettingForSettingsUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: SettingOnSettingForSettingsUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `setting` in the `UserInput` mutation.
"""
input SettingsUserIdFkeyInverseInput {
  """The primary key(s) for `setting` for the far side of the relationship."""
  connectByNodeId: SettingNodeIdConnect

  """The primary key(s) for `setting` for the far side of the relationship."""
  connectByUserId: SettingSettingsPkeyConnect

  """
  A `SettingInput` object that will be created and connected to this object.
  """
  create: [SettingsUserIdFkeySettingsCreateInput!]

  """The primary key(s) for `setting` for the far side of the relationship."""
  deleteByNodeId: SettingNodeIdDelete

  """The primary key(s) for `setting` for the far side of the relationship."""
  deleteByUserId: SettingSettingsPkeyDelete

  """
  Flag indicating whether all other `setting` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `setting` for the far side of the relationship.
  """
  updateByNodeId: UserOnSettingForSettingsUserIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `setting` for the far side of the relationship.
  """
  updateByUserId: SettingOnSettingForSettingsUserIdFkeyUsingSettingsPkeyUpdate
}

"""The `setting` to be created by this mutation."""
input SettingsUserIdFkeySettingsCreateInput {
  boldColours: Boolean
  showImageOnCard: Boolean
  user: SettingsUserIdFkeyInput
  userId: UUID
}

"""All input for the `sortByTime` mutation."""
input SortByTimeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  day: Int!
  tripId: UUID!
}

"""The output of our `sortByTime` mutation."""
type SortByTimePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Spend {
  byDay: [SpendByDay]
  total: SpendTotal
}

type SpendBreakdown {
  paid: Float
  unpaid: Float
}

type SpendByDay {
  accommodation: SpendBreakdown
  activity: SpendBreakdown
  food: SpendBreakdown
  other: SpendBreakdown
  total: SpendBreakdown
  travel: SpendBreakdown
}

type SpendTotal {
  accommodation: Float
  activity: Float
  food: Float
  other: Float
  total: Float
  travel: Float
}

type Srcset {
  height: Int
  id: String
  placeholder: String
  src: String
  srcset: String
  srcsetWebp: String
  width: Int
}

"""
A filter to be used against String fields. All fields are combined with a logical ‘and.’
"""
input StringFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: String

  """
  Not equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  distinctFromInsensitive: String

  """Ends with the specified string (case-sensitive)."""
  endsWith: String

  """Ends with the specified string (case-insensitive)."""
  endsWithInsensitive: String

  """Equal to the specified value."""
  equalTo: String

  """Equal to the specified value (case-insensitive)."""
  equalToInsensitive: String

  """Greater than the specified value."""
  greaterThan: String

  """Greater than the specified value (case-insensitive)."""
  greaterThanInsensitive: String

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: String

  """Greater than or equal to the specified value (case-insensitive)."""
  greaterThanOrEqualToInsensitive: String

  """Included in the specified list."""
  in: [String!]

  """Included in the specified list (case-insensitive)."""
  inInsensitive: [String!]

  """Contains the specified string (case-sensitive)."""
  includes: String

  """Contains the specified string (case-insensitive)."""
  includesInsensitive: String

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: String

  """Less than the specified value (case-insensitive)."""
  lessThanInsensitive: String

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: String

  """Less than or equal to the specified value (case-insensitive)."""
  lessThanOrEqualToInsensitive: String

  """
  Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  like: String

  """
  Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  likeInsensitive: String

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: String

  """
  Equal to the specified value, treating null like an ordinary value (case-insensitive).
  """
  notDistinctFromInsensitive: String

  """Does not end with the specified string (case-sensitive)."""
  notEndsWith: String

  """Does not end with the specified string (case-insensitive)."""
  notEndsWithInsensitive: String

  """Not equal to the specified value."""
  notEqualTo: String

  """Not equal to the specified value (case-insensitive)."""
  notEqualToInsensitive: String

  """Not included in the specified list."""
  notIn: [String!]

  """Not included in the specified list (case-insensitive)."""
  notInInsensitive: [String!]

  """Does not contain the specified string (case-sensitive)."""
  notIncludes: String

  """Does not contain the specified string (case-insensitive)."""
  notIncludesInsensitive: String

  """
  Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLike: String

  """
  Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters.
  """
  notLikeInsensitive: String

  """Does not start with the specified string (case-sensitive)."""
  notStartsWith: String

  """Does not start with the specified string (case-insensitive)."""
  notStartsWithInsensitive: String

  """Starts with the specified string (case-sensitive)."""
  startsWith: String

  """Starts with the specified string (case-insensitive)."""
  startsWithInsensitive: String
}

"""
A filter to be used against String List fields. All fields are combined with a logical ‘and.’
"""
input StringListFilter {
  """Any array item is equal to the specified value."""
  anyEqualTo: String

  """Any array item is greater than the specified value."""
  anyGreaterThan: String

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: String

  """Any array item is less than the specified value."""
  anyLessThan: String

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: String

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: String

  """Contained by the specified list of values."""
  containedBy: [String]

  """Contains the specified list of values."""
  contains: [String]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [String]

  """Equal to the specified value."""
  equalTo: [String]

  """Greater than the specified value."""
  greaterThan: [String]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [String]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: [String]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [String]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [String]

  """Not equal to the specified value."""
  notEqualTo: [String]

  """Overlaps the specified list of values."""
  overlaps: [String]
}

"""
The root subscription type: contains realtime events you can subscribe to with the `subscription` operation.
"""
type Subscription {
  listen(topic: String!): ListenPayload!
}

type SubscriptionLog implements Node {
  event: String
  id: UUID!
  identifier: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  origin: SubscriptionOrigin
  timestamp: Datetime

  """Reads a single `User` that is related to this `SubscriptionLog`."""
  user: User
  userId: UUID!
}

"""
A condition to be used against `SubscriptionLog` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SubscriptionLogCondition {
  """Checks for equality with the object’s `event` field."""
  event: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `identifier` field."""
  identifier: String

  """Checks for equality with the object’s `origin` field."""
  origin: SubscriptionOrigin

  """Checks for equality with the object’s `timestamp` field."""
  timestamp: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `SubscriptionLog` object types. All fields are combined with a logical ‘and.’
"""
input SubscriptionLogFilter {
  """Checks for all expressions in this list."""
  and: [SubscriptionLogFilter!]

  """Filter by the object’s `event` field."""
  event: StringFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `identifier` field."""
  identifier: StringFilter

  """Negates the expression."""
  not: SubscriptionLogFilter

  """Checks for any expressions in this list."""
  or: [SubscriptionLogFilter!]

  """Filter by the object’s `origin` field."""
  origin: SubscriptionOriginFilter

  """Filter by the object’s `timestamp` field."""
  timestamp: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `SubscriptionLog`"""
input SubscriptionLogInput {
  event: String
  id: UUID
  identifier: String
  origin: SubscriptionOrigin
  timestamp: Datetime
  user: SubscriptionLogUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input SubscriptionLogNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `subscriptionLog` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input SubscriptionLogNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `subscriptionLog` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input SubscriptionLogOnSubscriptionLogForSubscriptionLogUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `subscriptionLog` to look up the row to update."""
input SubscriptionLogOnSubscriptionLogForSubscriptionLogUserIdFkeyUsingSubscriptionLogPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `subscriptionLog` being updated.
  """
  patch: updateSubscriptionLogOnSubscriptionLogForSubscriptionLogUserIdFkeyPatch!
}

"""
Represents an update to a `SubscriptionLog`. Fields that are set will be updated.
"""
input SubscriptionLogPatch {
  event: String
  id: UUID
  identifier: String
  origin: SubscriptionOrigin
  timestamp: Datetime
  user: SubscriptionLogUserIdFkeyInput
  userId: UUID
}

"""The fields on `subscriptionLog` to look up the row to connect."""
input SubscriptionLogSubscriptionLogPkeyConnect {
  id: UUID!
}

"""The fields on `subscriptionLog` to look up the row to delete."""
input SubscriptionLogSubscriptionLogPkeyDelete {
  id: UUID!
}

"""
Input for the nested mutation of `user` in the `SubscriptionLogInput` mutation.
"""
input SubscriptionLogUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnSubscriptionLogForSubscriptionLogUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: SubscriptionLogOnSubscriptionLogForSubscriptionLogUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `subscriptionLog` in the `UserInput` mutation.
"""
input SubscriptionLogUserIdFkeyInverseInput {
  """
  The primary key(s) for `subscriptionLog` for the far side of the relationship.
  """
  connectById: [SubscriptionLogSubscriptionLogPkeyConnect!]

  """
  The primary key(s) for `subscriptionLog` for the far side of the relationship.
  """
  connectByNodeId: [SubscriptionLogNodeIdConnect!]

  """
  A `SubscriptionLogInput` object that will be created and connected to this object.
  """
  create: [SubscriptionLogUserIdFkeySubscriptionLogCreateInput!]

  """
  The primary key(s) for `subscriptionLog` for the far side of the relationship.
  """
  deleteById: [SubscriptionLogSubscriptionLogPkeyDelete!]

  """
  The primary key(s) for `subscriptionLog` for the far side of the relationship.
  """
  deleteByNodeId: [SubscriptionLogNodeIdDelete!]

  """
  Flag indicating whether all other `subscriptionLog` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `subscriptionLog` for the far side of the relationship.
  """
  updateById: [SubscriptionLogOnSubscriptionLogForSubscriptionLogUserIdFkeyUsingSubscriptionLogPkeyUpdate!]

  """
  The primary key(s) and patch data for `subscriptionLog` for the far side of the relationship.
  """
  updateByNodeId: [UserOnSubscriptionLogForSubscriptionLogUserIdFkeyNodeIdUpdate!]
}

"""The `subscriptionLog` to be created by this mutation."""
input SubscriptionLogUserIdFkeySubscriptionLogCreateInput {
  event: String
  id: UUID
  identifier: String
  origin: SubscriptionOrigin
  timestamp: Datetime
  user: SubscriptionLogUserIdFkeyInput
  userId: UUID
}

"""A connection to a list of `SubscriptionLog` values."""
type SubscriptionLogsConnection {
  """
  A list of edges which contains the `SubscriptionLog` and cursor to aid in pagination.
  """
  edges: [SubscriptionLogsEdge!]!

  """A list of `SubscriptionLog` objects."""
  nodes: [SubscriptionLog!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `SubscriptionLog` you could get from the connection.
  """
  totalCount: Int!
}

"""A `SubscriptionLog` edge in the connection."""
type SubscriptionLogsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SubscriptionLog` at the end of the edge."""
  node: SubscriptionLog!
}

"""Methods to use when ordering `SubscriptionLog`."""
enum SubscriptionLogsOrderBy {
  EVENT_ASC
  EVENT_DESC
  IDENTIFIER_ASC
  IDENTIFIER_DESC
  ID_ASC
  ID_DESC
  NATURAL
  ORIGIN_ASC
  ORIGIN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  USER_ID_ASC
  USER_ID_DESC
}

enum SubscriptionOrigin {
  ANDROID
  IOS
  STRIPE
}

"""
A filter to be used against SubscriptionOrigin fields. All fields are combined with a logical ‘and.’
"""
input SubscriptionOriginFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: SubscriptionOrigin

  """Equal to the specified value."""
  equalTo: SubscriptionOrigin

  """Greater than the specified value."""
  greaterThan: SubscriptionOrigin

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: SubscriptionOrigin

  """Included in the specified list."""
  in: [SubscriptionOrigin!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: SubscriptionOrigin

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: SubscriptionOrigin

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: SubscriptionOrigin

  """Not equal to the specified value."""
  notEqualTo: SubscriptionOrigin

  """Not included in the specified list."""
  notIn: [SubscriptionOrigin!]
}

type Supplier implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads a single `User` that is related to this `Supplier`."""
  author: User
  authorId: UUID

  """Reads a single `SupplierCategory` that is related to this `Supplier`."""
  category: SupplierCategory
  categoryId: UUID

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Reads a single `Asset` that is related to this `Supplier`."""
  logo: Asset
  logoId: UUID

  """Reads and enables pagination through a set of `Meta`."""
  metadata(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasConnection!

  """Reads and enables pagination through a set of `Meta`."""
  metadataList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]
  ): [Meta!]!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Organisation` that is related to this `Supplier`."""
  organisation: Organisation
  organisationId: UUID!
  rating: Int!

  """When this item was restored"""
  restoredAt: Datetime

  """Reads and enables pagination through a set of `SupplierTag`."""
  tags(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierTagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierTagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SupplierTag`."""
    orderBy: [SupplierTagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierTagsConnection!

  """Reads and enables pagination through a set of `SupplierTag`."""
  tagsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierTagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierTagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SupplierTag`."""
    orderBy: [SupplierTagsOrderBy!]
  ): [SupplierTag!]!
  type: CardType

  """When this item was updated"""
  updatedAt: Datetime
}

"""
Input for the nested mutation of `user` in the `SupplierInput` mutation.
"""
input SupplierAuthorIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnSupplierForSupplierAuthorIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: SupplierOnSupplierForSupplierAuthorIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `supplier` in the `UserInput` mutation.
"""
input SupplierAuthorIdFkeyInverseInput {
  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectById: [SupplierSupplierPkeyConnect!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectByNodeId: [SupplierNodeIdConnect!]

  """
  A `SupplierInput` object that will be created and connected to this object.
  """
  create: [SupplierAuthorIdFkeySupplierCreateInput!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteById: [SupplierSupplierPkeyDelete!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteByNodeId: [SupplierNodeIdDelete!]

  """
  Flag indicating whether all other `supplier` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateById: [SupplierOnSupplierForSupplierAuthorIdFkeyUsingSupplierPkeyUpdate!]

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateByNodeId: [UserOnSupplierForSupplierAuthorIdFkeyNodeIdUpdate!]
}

"""The `supplier` to be created by this mutation."""
input SupplierAuthorIdFkeySupplierCreateInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""A connection to a list of `SupplierCategory` values."""
type SupplierCategoriesConnection {
  """
  A list of edges which contains the `SupplierCategory` and cursor to aid in pagination.
  """
  edges: [SupplierCategoriesEdge!]!

  """A list of `SupplierCategory` objects."""
  nodes: [SupplierCategory!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `SupplierCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""A `SupplierCategory` edge in the connection."""
type SupplierCategoriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SupplierCategory` at the end of the edge."""
  node: SupplierCategory!
}

"""Methods to use when ordering `SupplierCategory`."""
enum SupplierCategoriesOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type SupplierCategory implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """When this item was created"""
  createdAt: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """When this item was restored"""
  restoredAt: Datetime

  """Reads and enables pagination through a set of `Supplier`."""
  suppliersByCategoryId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersConnection!

  """Reads and enables pagination through a set of `Supplier`."""
  suppliersByCategoryIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!]
  ): [Supplier!]!
  type: CardType!

  """When this item was updated"""
  updatedAt: Datetime
}

"""
A condition to be used against `SupplierCategory` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SupplierCategoryCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `type` field."""
  type: CardType

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `SupplierCategory` object types. All fields are combined with a logical ‘and.’
"""
input SupplierCategoryFilter {
  """Checks for all expressions in this list."""
  and: [SupplierCategoryFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: SupplierCategoryFilter

  """Checks for any expressions in this list."""
  or: [SupplierCategoryFilter!]

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `suppliersByCategoryId` relation."""
  suppliersByCategoryId: SupplierCategoryToManySupplierFilter

  """Some related `suppliersByCategoryId` exist."""
  suppliersByCategoryIdExist: Boolean

  """Filter by the object’s `type` field."""
  type: CardTypeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""
Input for the nested mutation of `supplierCategory` in the `SupplierInput` mutation.
"""
input SupplierCategoryIdFkeyInput {
  """
  The primary key(s) for `supplierCategory` for the far side of the relationship.
  """
  connectById: SupplierCategorySupplierCategoryPkeyConnect

  """
  The primary key(s) for `supplierCategory` for the far side of the relationship.
  """
  connectByNodeId: SupplierCategoryNodeIdConnect

  """
  A `SupplierCategoryInput` object that will be created and connected to this object.
  """
  create: SupplierCategoryIdFkeySupplierCategoryCreateInput

  """
  The primary key(s) for `supplierCategory` for the far side of the relationship.
  """
  deleteById: SupplierCategorySupplierCategoryPkeyDelete

  """
  The primary key(s) for `supplierCategory` for the far side of the relationship.
  """
  deleteByNodeId: SupplierCategoryNodeIdDelete

  """
  The primary key(s) and patch data for `supplierCategory` for the far side of the relationship.
  """
  updateById: SupplierCategoryOnSupplierForSupplierCategoryIdFkeyUsingSupplierCategoryPkeyUpdate

  """
  The primary key(s) and patch data for `supplierCategory` for the far side of the relationship.
  """
  updateByNodeId: SupplierOnSupplierForSupplierCategoryIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `supplier` in the `SupplierCategoryInput` mutation.
"""
input SupplierCategoryIdFkeyInverseInput {
  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectById: [SupplierSupplierPkeyConnect!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectByNodeId: [SupplierNodeIdConnect!]

  """
  A `SupplierInput` object that will be created and connected to this object.
  """
  create: [SupplierCategoryIdFkeySupplierCreateInput!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteById: [SupplierSupplierPkeyDelete!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteByNodeId: [SupplierNodeIdDelete!]

  """
  Flag indicating whether all other `supplier` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateById: [SupplierOnSupplierForSupplierCategoryIdFkeyUsingSupplierPkeyUpdate!]

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateByNodeId: [SupplierCategoryOnSupplierForSupplierCategoryIdFkeyNodeIdUpdate!]
}

"""The `supplierCategory` to be created by this mutation."""
input SupplierCategoryIdFkeySupplierCategoryCreateInput {
  id: UUID
  name: String!
  suppliers: SupplierCategoryIdFkeyInverseInput
  type: CardType!
}

"""The `supplier` to be created by this mutation."""
input SupplierCategoryIdFkeySupplierCreateInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""An input for mutations affecting `SupplierCategory`"""
input SupplierCategoryInput {
  id: UUID
  name: String!
  suppliers: SupplierCategoryIdFkeyInverseInput
  type: CardType!
}

"""The globally unique `ID` look up for the row to connect."""
input SupplierCategoryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `supplierCategory` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input SupplierCategoryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `supplierCategory` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierCategoryOnSupplierForSupplierCategoryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The fields on `supplierCategory` to look up the row to update."""
input SupplierCategoryOnSupplierForSupplierCategoryIdFkeyUsingSupplierCategoryPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplierCategory` being updated.
  """
  patch: updateSupplierCategoryOnSupplierForSupplierCategoryIdFkeyPatch!
}

"""
Represents an update to a `SupplierCategory`. Fields that are set will be updated.
"""
input SupplierCategoryPatch {
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  suppliers: SupplierCategoryIdFkeyInverseInput
  type: CardType
}

"""The fields on `supplierCategory` to look up the row to connect."""
input SupplierCategorySupplierCategoryPkeyConnect {
  id: UUID!
}

"""The fields on `supplierCategory` to look up the row to delete."""
input SupplierCategorySupplierCategoryPkeyDelete {
  id: UUID!
}

"""
A filter to be used against many `Supplier` object types. All fields are combined with a logical ‘and.’
"""
input SupplierCategoryToManySupplierFilter {
  """
  Every related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SupplierFilter

  """
  No related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SupplierFilter

  """
  Some related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SupplierFilter
}

"""
A condition to be used against `Supplier` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SupplierCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `authorId` field."""
  authorId: UUID

  """Checks for equality with the object’s `categoryId` field."""
  categoryId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `logoId` field."""
  logoId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `rating` field."""
  rating: Int

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `type` field."""
  type: CardType

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `Supplier` object types. All fields are combined with a logical ‘and.’
"""
input SupplierFilter {
  """Checks for all expressions in this list."""
  and: [SupplierFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `author` relation."""
  author: UserFilter

  """A related `author` exists."""
  authorExists: Boolean

  """Filter by the object’s `authorId` field."""
  authorId: UUIDFilter

  """Filter by the object’s `category` relation."""
  category: SupplierCategoryFilter

  """A related `category` exists."""
  categoryExists: Boolean

  """Filter by the object’s `categoryId` field."""
  categoryId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `logo` relation."""
  logo: AssetFilter

  """A related `logo` exists."""
  logoExists: Boolean

  """Filter by the object’s `logoId` field."""
  logoId: UUIDFilter

  """Filter by the object’s `metadata` relation."""
  metadata: SupplierToManyMetaFilter

  """Some related `metadata` exist."""
  metadataExist: Boolean

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: SupplierFilter

  """Checks for any expressions in this list."""
  or: [SupplierFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `rating` field."""
  rating: IntFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `tags` relation."""
  tags: SupplierToManySupplierTagFilter

  """Some related `tags` exist."""
  tagsExist: Boolean

  """Filter by the object’s `type` field."""
  type: CardTypeFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""An input for mutations affecting `Supplier`"""
input SupplierInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""The `asset` to be created by this mutation."""
input SupplierLogoIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
Input for the nested mutation of `asset` in the `SupplierInput` mutation.
"""
input SupplierLogoIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: SupplierLogoIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnSupplierForSupplierLogoIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: SupplierOnSupplierForSupplierLogoIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `supplier` in the `AssetInput` mutation.
"""
input SupplierLogoIdFkeyInverseInput {
  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectById: [SupplierSupplierPkeyConnect!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectByNodeId: [SupplierNodeIdConnect!]

  """
  A `SupplierInput` object that will be created and connected to this object.
  """
  create: [SupplierLogoIdFkeySupplierCreateInput!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteById: [SupplierSupplierPkeyDelete!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteByNodeId: [SupplierNodeIdDelete!]

  """
  Flag indicating whether all other `supplier` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateById: [SupplierOnSupplierForSupplierLogoIdFkeyUsingSupplierPkeyUpdate!]

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnSupplierForSupplierLogoIdFkeyNodeIdUpdate!]
}

"""The `supplier` to be created by this mutation."""
input SupplierLogoIdFkeySupplierCreateInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""The globally unique `ID` look up for the row to connect."""
input SupplierNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input SupplierNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `supplier` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierOnMetaForMetadataSupplierIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meta` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: MetaPatch!
}

"""The fields on `supplier` to look up the row to update."""
input SupplierOnMetaForMetadataSupplierIdFkeyUsingSupplierPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: updateSupplierOnMetaForMetadataSupplierIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierOnSupplierForSupplierAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `supplier` to look up the row to update."""
input SupplierOnSupplierForSupplierAuthorIdFkeyUsingSupplierPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: updateSupplierOnSupplierForSupplierAuthorIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierOnSupplierForSupplierCategoryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplierCategory` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplierCategory` being updated.
  """
  patch: SupplierCategoryPatch!
}

"""The fields on `supplier` to look up the row to update."""
input SupplierOnSupplierForSupplierCategoryIdFkeyUsingSupplierPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: updateSupplierOnSupplierForSupplierCategoryIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierOnSupplierForSupplierLogoIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `supplier` to look up the row to update."""
input SupplierOnSupplierForSupplierLogoIdFkeyUsingSupplierPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: updateSupplierOnSupplierForSupplierLogoIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierOnSupplierForSupplierOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `supplier` to look up the row to update."""
input SupplierOnSupplierForSupplierOrganisationIdFkeyUsingSupplierPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: updateSupplierOnSupplierForSupplierOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierOnSupplierTagForSupplierTagSupplierIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplierTag` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplierTag` being updated.
  """
  patch: SupplierTagPatch!
}

"""The fields on `supplier` to look up the row to update."""
input SupplierOnSupplierTagForSupplierTagSupplierIdFkeyUsingSupplierPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: updateSupplierOnSupplierTagForSupplierTagSupplierIdFkeyPatch!
}

"""
Input for the nested mutation of `organisation` in the `SupplierInput` mutation.
"""
input SupplierOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnSupplierForSupplierOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: SupplierOnSupplierForSupplierOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `supplier` in the `OrganisationInput` mutation.
"""
input SupplierOrganisationIdFkeyInverseInput {
  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectById: [SupplierSupplierPkeyConnect!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectByNodeId: [SupplierNodeIdConnect!]

  """
  A `SupplierInput` object that will be created and connected to this object.
  """
  create: [SupplierOrganisationIdFkeySupplierCreateInput!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteById: [SupplierSupplierPkeyDelete!]

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteByNodeId: [SupplierNodeIdDelete!]

  """
  Flag indicating whether all other `supplier` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateById: [SupplierOnSupplierForSupplierOrganisationIdFkeyUsingSupplierPkeyUpdate!]

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnSupplierForSupplierOrganisationIdFkeyNodeIdUpdate!]
}

"""The `supplier` to be created by this mutation."""
input SupplierOrganisationIdFkeySupplierCreateInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
Represents an update to a `Supplier`. Fields that are set will be updated.
"""
input SupplierPatch {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""The fields on `supplier` to look up the row to connect."""
input SupplierSupplierPkeyConnect {
  id: UUID!
}

"""The fields on `supplier` to look up the row to delete."""
input SupplierSupplierPkeyDelete {
  id: UUID!
}

type SupplierTag implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Supplier` that is related to this `SupplierTag`."""
  supplier: Supplier
  supplierId: UUID!

  """Reads a single `Tag` that is related to this `SupplierTag`."""
  tag: Tag
  tagId: UUID!
}

"""
A condition to be used against `SupplierTag` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SupplierTagCondition {
  """Checks for equality with the object’s `supplierId` field."""
  supplierId: UUID

  """Checks for equality with the object’s `tagId` field."""
  tagId: UUID
}

"""
A filter to be used against `SupplierTag` object types. All fields are combined with a logical ‘and.’
"""
input SupplierTagFilter {
  """Checks for all expressions in this list."""
  and: [SupplierTagFilter!]

  """Negates the expression."""
  not: SupplierTagFilter

  """Checks for any expressions in this list."""
  or: [SupplierTagFilter!]

  """Filter by the object’s `supplier` relation."""
  supplier: SupplierFilter

  """Filter by the object’s `supplierId` field."""
  supplierId: UUIDFilter

  """Filter by the object’s `tag` relation."""
  tag: TagFilter

  """Filter by the object’s `tagId` field."""
  tagId: UUIDFilter
}

"""An input for mutations affecting `SupplierTag`"""
input SupplierTagInput {
  supplier: SupplierTagSupplierIdFkeyInput
  supplierId: UUID
  tag: SupplierTagTagIdFkeyInput
  tagId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input SupplierTagNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `supplierTag` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input SupplierTagNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `supplierTag` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierTagOnSupplierTagForSupplierTagSupplierIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The fields on `supplierTag` to look up the row to update."""
input SupplierTagOnSupplierTagForSupplierTagSupplierIdFkeyUsingSupplierTagPkeyUpdate {
  """
  An object where the defined keys will be set on the `supplierTag` being updated.
  """
  patch: updateSupplierTagOnSupplierTagForSupplierTagSupplierIdFkeyPatch!
  supplierId: UUID!
  tagId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input SupplierTagOnSupplierTagForSupplierTagTagIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tag` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: TagPatch!
}

"""The fields on `supplierTag` to look up the row to update."""
input SupplierTagOnSupplierTagForSupplierTagTagIdFkeyUsingSupplierTagPkeyUpdate {
  """
  An object where the defined keys will be set on the `supplierTag` being updated.
  """
  patch: updateSupplierTagOnSupplierTagForSupplierTagTagIdFkeyPatch!
  supplierId: UUID!
  tagId: UUID!
}

"""
Represents an update to a `SupplierTag`. Fields that are set will be updated.
"""
input SupplierTagPatch {
  supplier: SupplierTagSupplierIdFkeyInput
  supplierId: UUID
  tag: SupplierTagTagIdFkeyInput
  tagId: UUID
}

"""
Input for the nested mutation of `supplier` in the `SupplierTagInput` mutation.
"""
input SupplierTagSupplierIdFkeyInput {
  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectById: SupplierSupplierPkeyConnect

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  connectByNodeId: SupplierNodeIdConnect

  """
  A `SupplierInput` object that will be created and connected to this object.
  """
  create: SupplierTagSupplierIdFkeySupplierCreateInput

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteById: SupplierSupplierPkeyDelete

  """
  The primary key(s) for `supplier` for the far side of the relationship.
  """
  deleteByNodeId: SupplierNodeIdDelete

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateById: SupplierOnSupplierTagForSupplierTagSupplierIdFkeyUsingSupplierPkeyUpdate

  """
  The primary key(s) and patch data for `supplier` for the far side of the relationship.
  """
  updateByNodeId: SupplierTagOnSupplierTagForSupplierTagSupplierIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `supplierTag` in the `SupplierInput` mutation.
"""
input SupplierTagSupplierIdFkeyInverseInput {
  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  connectByNodeId: [SupplierTagNodeIdConnect!]

  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  connectBySupplierIdAndTagId: [SupplierTagSupplierTagPkeyConnect!]

  """
  A `SupplierTagInput` object that will be created and connected to this object.
  """
  create: [SupplierTagSupplierIdFkeySupplierTagCreateInput!]

  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  deleteByNodeId: [SupplierTagNodeIdDelete!]

  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  deleteBySupplierIdAndTagId: [SupplierTagSupplierTagPkeyDelete!]

  """
  Flag indicating whether all other `supplierTag` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `supplierTag` for the far side of the relationship.
  """
  updateByNodeId: [SupplierOnSupplierTagForSupplierTagSupplierIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `supplierTag` for the far side of the relationship.
  """
  updateBySupplierIdAndTagId: [SupplierTagOnSupplierTagForSupplierTagSupplierIdFkeyUsingSupplierTagPkeyUpdate!]
}

"""The `supplier` to be created by this mutation."""
input SupplierTagSupplierIdFkeySupplierCreateInput {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String!
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""The `supplierTag` to be created by this mutation."""
input SupplierTagSupplierIdFkeySupplierTagCreateInput {
  supplier: SupplierTagSupplierIdFkeyInput
  supplierId: UUID
  tag: SupplierTagTagIdFkeyInput
  tagId: UUID
}

"""The fields on `supplierTag` to look up the row to connect."""
input SupplierTagSupplierTagPkeyConnect {
  supplierId: UUID!
  tagId: UUID!
}

"""The fields on `supplierTag` to look up the row to delete."""
input SupplierTagSupplierTagPkeyDelete {
  supplierId: UUID!
  tagId: UUID!
}

"""
Input for the nested mutation of `tag` in the `SupplierTagInput` mutation.
"""
input SupplierTagTagIdFkeyInput {
  """The primary key(s) for `tag` for the far side of the relationship."""
  connectById: TagTagPkeyConnect

  """The primary key(s) for `tag` for the far side of the relationship."""
  connectByNameAndTypeAndOrganisationId: TagTagUniqueKeyConnect

  """The primary key(s) for `tag` for the far side of the relationship."""
  connectByNodeId: TagNodeIdConnect

  """A `TagInput` object that will be created and connected to this object."""
  create: SupplierTagTagIdFkeyTagCreateInput

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteById: TagTagPkeyDelete

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteByNameAndTypeAndOrganisationId: TagTagUniqueKeyDelete

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteByNodeId: TagNodeIdDelete

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateById: TagOnSupplierTagForSupplierTagTagIdFkeyUsingTagPkeyUpdate

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateByNameAndTypeAndOrganisationId: TagOnSupplierTagForSupplierTagTagIdFkeyUsingTagUniqueKeyUpdate

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateByNodeId: SupplierTagOnSupplierTagForSupplierTagTagIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `supplierTag` in the `TagInput` mutation.
"""
input SupplierTagTagIdFkeyInverseInput {
  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  connectByNodeId: [SupplierTagNodeIdConnect!]

  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  connectBySupplierIdAndTagId: [SupplierTagSupplierTagPkeyConnect!]

  """
  A `SupplierTagInput` object that will be created and connected to this object.
  """
  create: [SupplierTagTagIdFkeySupplierTagCreateInput!]

  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  deleteByNodeId: [SupplierTagNodeIdDelete!]

  """
  The primary key(s) for `supplierTag` for the far side of the relationship.
  """
  deleteBySupplierIdAndTagId: [SupplierTagSupplierTagPkeyDelete!]

  """
  Flag indicating whether all other `supplierTag` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `supplierTag` for the far side of the relationship.
  """
  updateByNodeId: [TagOnSupplierTagForSupplierTagTagIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `supplierTag` for the far side of the relationship.
  """
  updateBySupplierIdAndTagId: [SupplierTagOnSupplierTagForSupplierTagTagIdFkeyUsingSupplierTagPkeyUpdate!]
}

"""The `supplierTag` to be created by this mutation."""
input SupplierTagTagIdFkeySupplierTagCreateInput {
  supplier: SupplierTagSupplierIdFkeyInput
  supplierId: UUID
  tag: SupplierTagTagIdFkeyInput
  tagId: UUID
}

"""The `tag` to be created by this mutation."""
input SupplierTagTagIdFkeyTagCreateInput {
  icon: String
  id: UUID
  name: String!
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""A connection to a list of `SupplierTag` values."""
type SupplierTagsConnection {
  """
  A list of edges which contains the `SupplierTag` and cursor to aid in pagination.
  """
  edges: [SupplierTagsEdge!]!

  """A list of `SupplierTag` objects."""
  nodes: [SupplierTag!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SupplierTag` you could get from the connection."""
  totalCount: Int!
}

"""A `SupplierTag` edge in the connection."""
type SupplierTagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SupplierTag` at the end of the edge."""
  node: SupplierTag!
}

"""Methods to use when ordering `SupplierTag`."""
enum SupplierTagsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SUPPLIER_ID_ASC
  SUPPLIER_ID_DESC
  TAG_ID_ASC
  TAG_ID_DESC
}

"""
A filter to be used against many `Meta` object types. All fields are combined with a logical ‘and.’
"""
input SupplierToManyMetaFilter {
  """
  Every related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MetaFilter

  """
  No related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MetaFilter

  """
  Some related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MetaFilter
}

"""
A filter to be used against many `SupplierTag` object types. All fields are combined with a logical ‘and.’
"""
input SupplierToManySupplierTagFilter {
  """
  Every related `SupplierTag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SupplierTagFilter

  """
  No related `SupplierTag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SupplierTagFilter

  """
  Some related `SupplierTag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SupplierTagFilter
}

"""A connection to a list of `Supplier` values."""
type SuppliersConnection {
  """
  A list of edges which contains the `Supplier` and cursor to aid in pagination.
  """
  edges: [SuppliersEdge!]!

  """A list of `Supplier` objects."""
  nodes: [Supplier!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Supplier` you could get from the connection."""
  totalCount: Int!
}

"""A `Supplier` edge in the connection."""
type SuppliersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Supplier` at the end of the edge."""
  node: Supplier!
}

"""Methods to use when ordering `Supplier`."""
enum SuppliersOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  AUTHOR_ID_ASC
  AUTHOR_ID_DESC
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  LOGO_ID_ASC
  LOGO_ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RATING_ASC
  RATING_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type Tag implements Node {
  icon: String
  id: UUID!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Organisation` that is related to this `Tag`."""
  organisation: Organisation
  organisationId: UUID

  """Reads and enables pagination through a set of `SupplierTag`."""
  suppliers(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierTagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierTagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SupplierTag`."""
    orderBy: [SupplierTagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierTagsConnection!

  """Reads and enables pagination through a set of `SupplierTag`."""
  suppliersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierTagCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierTagFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SupplierTag`."""
    orderBy: [SupplierTagsOrderBy!]
  ): [SupplierTag!]!
  synonyms: String

  """Reads and enables pagination through a set of `TagTrip`."""
  trips(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagTripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagTripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagTripsConnection!

  """Reads and enables pagination through a set of `TagTrip`."""
  tripsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagTripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagTripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!]
  ): [TagTrip!]!
  type: TagType!
}

"""
A condition to be used against `Tag` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TagCondition {
  """Checks for equality with the object’s `icon` field."""
  icon: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `synonyms` field."""
  synonyms: String

  """Checks for equality with the object’s `type` field."""
  type: TagType
}

"""
A filter to be used against `Tag` object types. All fields are combined with a logical ‘and.’
"""
input TagFilter {
  """Checks for all expressions in this list."""
  and: [TagFilter!]

  """Filter by the object’s `icon` field."""
  icon: StringFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: TagFilter

  """Checks for any expressions in this list."""
  or: [TagFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """A related `organisation` exists."""
  organisationExists: Boolean

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `suppliers` relation."""
  suppliers: TagToManySupplierTagFilter

  """Some related `suppliers` exist."""
  suppliersExist: Boolean

  """Filter by the object’s `synonyms` field."""
  synonyms: StringFilter

  """Filter by the object’s `trips` relation."""
  trips: TagToManyTagTripFilter

  """Some related `trips` exist."""
  tripsExist: Boolean

  """Filter by the object’s `type` field."""
  type: TagTypeFilter
}

"""An input for mutations affecting `Tag`"""
input TagInput {
  icon: String
  id: UUID
  name: String!
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""The globally unique `ID` look up for the row to connect."""
input TagNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `tag` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TagNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `tag` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TagOnSupplierTagForSupplierTagTagIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplierTag` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplierTag` being updated.
  """
  patch: SupplierTagPatch!
}

"""The fields on `tag` to look up the row to update."""
input TagOnSupplierTagForSupplierTagTagIdFkeyUsingTagPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: updateTagOnSupplierTagForSupplierTagTagIdFkeyPatch!
}

"""The fields on `tag` to look up the row to update."""
input TagOnSupplierTagForSupplierTagTagIdFkeyUsingTagUniqueKeyUpdate {
  name: String!
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: updateTagOnSupplierTagForSupplierTagTagIdFkeyPatch!
  type: TagType!
}

"""The globally unique `ID` look up for the row to update."""
input TagOnTagForTagOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `tag` to look up the row to update."""
input TagOnTagForTagOrganisationIdFkeyUsingTagPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: updateTagOnTagForTagOrganisationIdFkeyPatch!
}

"""The fields on `tag` to look up the row to update."""
input TagOnTagForTagOrganisationIdFkeyUsingTagUniqueKeyUpdate {
  name: String!
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: updateTagOnTagForTagOrganisationIdFkeyPatch!
  type: TagType!
}

"""The globally unique `ID` look up for the row to update."""
input TagOnTagTripForTagTripTagIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tagTrip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tagTrip` being updated.
  """
  patch: TagTripPatch!
}

"""The fields on `tag` to look up the row to update."""
input TagOnTagTripForTagTripTagIdFkeyUsingTagPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: updateTagOnTagTripForTagTripTagIdFkeyPatch!
}

"""The fields on `tag` to look up the row to update."""
input TagOnTagTripForTagTripTagIdFkeyUsingTagUniqueKeyUpdate {
  name: String!
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: updateTagOnTagTripForTagTripTagIdFkeyPatch!
  type: TagType!
}

"""
Input for the nested mutation of `organisation` in the `TagInput` mutation.
"""
input TagOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnTagForTagOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: TagOnTagForTagOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `tag` in the `OrganisationInput` mutation.
"""
input TagOrganisationIdFkeyInverseInput {
  """The primary key(s) for `tag` for the far side of the relationship."""
  connectById: [TagTagPkeyConnect!]

  """The primary key(s) for `tag` for the far side of the relationship."""
  connectByNameAndTypeAndOrganisationId: [TagTagUniqueKeyConnect!]

  """The primary key(s) for `tag` for the far side of the relationship."""
  connectByNodeId: [TagNodeIdConnect!]

  """A `TagInput` object that will be created and connected to this object."""
  create: [TagOrganisationIdFkeyTagCreateInput!]

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteById: [TagTagPkeyDelete!]

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteByNameAndTypeAndOrganisationId: [TagTagUniqueKeyDelete!]

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteByNodeId: [TagNodeIdDelete!]

  """
  Flag indicating whether all other `tag` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateById: [TagOnTagForTagOrganisationIdFkeyUsingTagPkeyUpdate!]

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateByNameAndTypeAndOrganisationId: [TagOnTagForTagOrganisationIdFkeyUsingTagUniqueKeyUpdate!]

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnTagForTagOrganisationIdFkeyNodeIdUpdate!]
}

"""The `tag` to be created by this mutation."""
input TagOrganisationIdFkeyTagCreateInput {
  icon: String
  id: UUID
  name: String!
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""Represents an update to a `Tag`. Fields that are set will be updated."""
input TagPatch {
  icon: String
  id: UUID
  name: String
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""The fields on `tag` to look up the row to connect."""
input TagTagPkeyConnect {
  id: UUID!
}

"""The fields on `tag` to look up the row to delete."""
input TagTagPkeyDelete {
  id: UUID!
}

"""The fields on `tag` to look up the row to connect."""
input TagTagUniqueKeyConnect {
  name: String!
  organisationId: UUID!
  type: TagType!
}

"""The fields on `tag` to look up the row to delete."""
input TagTagUniqueKeyDelete {
  name: String!
  organisationId: UUID!
  type: TagType!
}

"""
A filter to be used against many `SupplierTag` object types. All fields are combined with a logical ‘and.’
"""
input TagToManySupplierTagFilter {
  """
  Every related `SupplierTag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SupplierTagFilter

  """
  No related `SupplierTag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SupplierTagFilter

  """
  Some related `SupplierTag` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SupplierTagFilter
}

"""
A filter to be used against many `TagTrip` object types. All fields are combined with a logical ‘and.’
"""
input TagToManyTagTripFilter {
  """
  Every related `TagTrip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TagTripFilter

  """
  No related `TagTrip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TagTripFilter

  """
  Some related `TagTrip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TagTripFilter
}

type TagTrip implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Tag` that is related to this `TagTrip`."""
  tag: Tag
  tagId: UUID!

  """Reads a single `Trip` that is related to this `TagTrip`."""
  trip: Trip
  tripId: UUID!
}

"""
A condition to be used against `TagTrip` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TagTripCondition {
  """Checks for equality with the object’s `tagId` field."""
  tagId: UUID

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID
}

"""
A filter to be used against `TagTrip` object types. All fields are combined with a logical ‘and.’
"""
input TagTripFilter {
  """Checks for all expressions in this list."""
  and: [TagTripFilter!]

  """Negates the expression."""
  not: TagTripFilter

  """Checks for any expressions in this list."""
  or: [TagTripFilter!]

  """Filter by the object’s `tag` relation."""
  tag: TagFilter

  """Filter by the object’s `tagId` field."""
  tagId: UUIDFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter
}

"""An input for mutations affecting `TagTrip`"""
input TagTripInput {
  tag: TagTripTagIdFkeyInput
  tagId: UUID
  trip: TagTripTripIdFkeyInput
  tripId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input TagTripNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `tagTrip` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TagTripNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `tagTrip` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TagTripOnTagTripForTagTripTagIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tag` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tag` being updated.
  """
  patch: TagPatch!
}

"""The fields on `tagTrip` to look up the row to update."""
input TagTripOnTagTripForTagTripTagIdFkeyUsingTagTripPkeyUpdate {
  """
  An object where the defined keys will be set on the `tagTrip` being updated.
  """
  patch: updateTagTripOnTagTripForTagTripTagIdFkeyPatch!
  tagId: UUID!
  tripId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input TagTripOnTagTripForTagTripTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `tagTrip` to look up the row to update."""
input TagTripOnTagTripForTagTripTripIdFkeyUsingTagTripPkeyUpdate {
  """
  An object where the defined keys will be set on the `tagTrip` being updated.
  """
  patch: updateTagTripOnTagTripForTagTripTripIdFkeyPatch!
  tagId: UUID!
  tripId: UUID!
}

"""
Represents an update to a `TagTrip`. Fields that are set will be updated.
"""
input TagTripPatch {
  tag: TagTripTagIdFkeyInput
  tagId: UUID
  trip: TagTripTripIdFkeyInput
  tripId: UUID
}

"""Input for the nested mutation of `tag` in the `TagTripInput` mutation."""
input TagTripTagIdFkeyInput {
  """The primary key(s) for `tag` for the far side of the relationship."""
  connectById: TagTagPkeyConnect

  """The primary key(s) for `tag` for the far side of the relationship."""
  connectByNameAndTypeAndOrganisationId: TagTagUniqueKeyConnect

  """The primary key(s) for `tag` for the far side of the relationship."""
  connectByNodeId: TagNodeIdConnect

  """A `TagInput` object that will be created and connected to this object."""
  create: TagTripTagIdFkeyTagCreateInput

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteById: TagTagPkeyDelete

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteByNameAndTypeAndOrganisationId: TagTagUniqueKeyDelete

  """The primary key(s) for `tag` for the far side of the relationship."""
  deleteByNodeId: TagNodeIdDelete

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateById: TagOnTagTripForTagTripTagIdFkeyUsingTagPkeyUpdate

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateByNameAndTypeAndOrganisationId: TagOnTagTripForTagTripTagIdFkeyUsingTagUniqueKeyUpdate

  """
  The primary key(s) and patch data for `tag` for the far side of the relationship.
  """
  updateByNodeId: TagTripOnTagTripForTagTripTagIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `tagTrip` in the `TagInput` mutation."""
input TagTripTagIdFkeyInverseInput {
  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  connectByNodeId: [TagTripNodeIdConnect!]

  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  connectByTagIdAndTripId: [TagTripTagTripPkeyConnect!]

  """
  A `TagTripInput` object that will be created and connected to this object.
  """
  create: [TagTripTagIdFkeyTagTripCreateInput!]

  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  deleteByNodeId: [TagTripNodeIdDelete!]

  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  deleteByTagIdAndTripId: [TagTripTagTripPkeyDelete!]

  """
  Flag indicating whether all other `tagTrip` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tagTrip` for the far side of the relationship.
  """
  updateByNodeId: [TagOnTagTripForTagTripTagIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tagTrip` for the far side of the relationship.
  """
  updateByTagIdAndTripId: [TagTripOnTagTripForTagTripTagIdFkeyUsingTagTripPkeyUpdate!]
}

"""The `tag` to be created by this mutation."""
input TagTripTagIdFkeyTagCreateInput {
  icon: String
  id: UUID
  name: String!
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""The `tagTrip` to be created by this mutation."""
input TagTripTagIdFkeyTagTripCreateInput {
  tag: TagTripTagIdFkeyInput
  tagId: UUID
  trip: TagTripTripIdFkeyInput
  tripId: UUID
}

"""The fields on `tagTrip` to look up the row to connect."""
input TagTripTagTripPkeyConnect {
  tagId: UUID!
  tripId: UUID!
}

"""The fields on `tagTrip` to look up the row to delete."""
input TagTripTagTripPkeyDelete {
  tagId: UUID!
  tripId: UUID!
}

"""
Input for the nested mutation of `trip` in the `TagTripInput` mutation.
"""
input TagTripTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: TagTripTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnTagTripForTagTripTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: TagTripOnTagTripForTagTripTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `tagTrip` in the `TripInput` mutation.
"""
input TagTripTripIdFkeyInverseInput {
  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  connectByNodeId: [TagTripNodeIdConnect!]

  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  connectByTagIdAndTripId: [TagTripTagTripPkeyConnect!]

  """
  A `TagTripInput` object that will be created and connected to this object.
  """
  create: [TagTripTripIdFkeyTagTripCreateInput!]

  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  deleteByNodeId: [TagTripNodeIdDelete!]

  """The primary key(s) for `tagTrip` for the far side of the relationship."""
  deleteByTagIdAndTripId: [TagTripTagTripPkeyDelete!]

  """
  Flag indicating whether all other `tagTrip` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tagTrip` for the far side of the relationship.
  """
  updateByNodeId: [TripOnTagTripForTagTripTripIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tagTrip` for the far side of the relationship.
  """
  updateByTagIdAndTripId: [TagTripOnTagTripForTagTripTripIdFkeyUsingTagTripPkeyUpdate!]
}

"""The `tagTrip` to be created by this mutation."""
input TagTripTripIdFkeyTagTripCreateInput {
  tag: TagTripTagIdFkeyInput
  tagId: UUID
  trip: TagTripTripIdFkeyInput
  tripId: UUID
}

"""The `trip` to be created by this mutation."""
input TagTripTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""A connection to a list of `TagTrip` values."""
type TagTripsConnection {
  """
  A list of edges which contains the `TagTrip` and cursor to aid in pagination.
  """
  edges: [TagTripsEdge!]!

  """A list of `TagTrip` objects."""
  nodes: [TagTrip!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TagTrip` you could get from the connection."""
  totalCount: Int!
}

"""A `TagTrip` edge in the connection."""
type TagTripsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TagTrip` at the end of the edge."""
  node: TagTrip!
}

"""Methods to use when ordering `TagTrip`."""
enum TagTripsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TAG_ID_ASC
  TAG_ID_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
}

enum TagType {
  DISCOVER
  SUPPLIER
  TRIP
}

"""
A filter to be used against TagType fields. All fields are combined with a logical ‘and.’
"""
input TagTypeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: TagType

  """Equal to the specified value."""
  equalTo: TagType

  """Greater than the specified value."""
  greaterThan: TagType

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: TagType

  """Included in the specified list."""
  in: [TagType!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: TagType

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: TagType

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: TagType

  """Not equal to the specified value."""
  notEqualTo: TagType

  """Not included in the specified list."""
  notIn: [TagType!]
}

"""A connection to a list of `Tag` values."""
type TagsConnection {
  """
  A list of edges which contains the `Tag` and cursor to aid in pagination.
  """
  edges: [TagsEdge!]!

  """A list of `Tag` objects."""
  nodes: [Tag!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Tag` you could get from the connection."""
  totalCount: Int!
}

"""A `Tag` edge in the connection."""
type TagsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Tag` at the end of the edge."""
  node: Tag!
}

"""Methods to use when ordering `Tag`."""
enum TagsOrderBy {
  ICON_ASC
  ICON_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SYNONYMS_ASC
  SYNONYMS_DESC
  TYPE_ASC
  TYPE_DESC
}

type Task implements Node {
  """When this item was archived"""
  archivedAt: Datetime

  """Reads a single `Card` that is related to this `Task`."""
  card: Card
  cardId: UUID
  complete: Boolean

  """When this item was created"""
  createdAt: Datetime
  date: Datetime
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  notes: String

  """When this item was restored"""
  restoredAt: Datetime

  """Reads a single `Trip` that is related to this `Task`."""
  trip: Trip
  tripId: UUID!

  """When this item was updated"""
  updatedAt: Datetime

  """Reads a single `User` that is related to this `Task`."""
  user: User
  userId: UUID
}

"""The `card` to be created by this mutation."""
input TaskCardIdFkeyCardCreateInput {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""Input for the nested mutation of `card` in the `TaskInput` mutation."""
input TaskCardIdFkeyInput {
  """The primary key(s) for `card` for the far side of the relationship."""
  connectById: CardCardPkeyConnect

  """The primary key(s) for `card` for the far side of the relationship."""
  connectByNodeId: CardNodeIdConnect

  """
  A `CardInput` object that will be created and connected to this object.
  """
  create: TaskCardIdFkeyCardCreateInput

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteById: CardCardPkeyDelete

  """The primary key(s) for `card` for the far side of the relationship."""
  deleteByNodeId: CardNodeIdDelete

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateById: CardOnTaskForTaskCardIdFkeyUsingCardPkeyUpdate

  """
  The primary key(s) and patch data for `card` for the far side of the relationship.
  """
  updateByNodeId: TaskOnTaskForTaskCardIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `task` in the `CardInput` mutation."""
input TaskCardIdFkeyInverseInput {
  """The primary key(s) for `task` for the far side of the relationship."""
  connectById: [TaskTaskPkeyConnect!]

  """The primary key(s) for `task` for the far side of the relationship."""
  connectByNodeId: [TaskNodeIdConnect!]

  """
  A `TaskInput` object that will be created and connected to this object.
  """
  create: [TaskCardIdFkeyTaskCreateInput!]

  """The primary key(s) for `task` for the far side of the relationship."""
  deleteById: [TaskTaskPkeyDelete!]

  """The primary key(s) for `task` for the far side of the relationship."""
  deleteByNodeId: [TaskNodeIdDelete!]

  """
  Flag indicating whether all other `task` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `task` for the far side of the relationship.
  """
  updateById: [TaskOnTaskForTaskCardIdFkeyUsingTaskPkeyUpdate!]

  """
  The primary key(s) and patch data for `task` for the far side of the relationship.
  """
  updateByNodeId: [CardOnTaskForTaskCardIdFkeyNodeIdUpdate!]
}

"""The `task` to be created by this mutation."""
input TaskCardIdFkeyTaskCreateInput {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID
  name: String!
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""
A condition to be used against `Task` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TaskCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `cardId` field."""
  cardId: UUID

  """Checks for equality with the object’s `complete` field."""
  complete: Boolean

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `date` field."""
  date: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: UUID
}

"""
A filter to be used against `Task` object types. All fields are combined with a logical ‘and.’
"""
input TaskFilter {
  """Checks for all expressions in this list."""
  and: [TaskFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `card` relation."""
  card: CardFilter

  """A related `card` exists."""
  cardExists: Boolean

  """Filter by the object’s `cardId` field."""
  cardId: UUIDFilter

  """Filter by the object’s `complete` field."""
  complete: BooleanFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: TaskFilter

  """Filter by the object’s `notes` field."""
  notes: StringFilter

  """Checks for any expressions in this list."""
  or: [TaskFilter!]

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """A related `user` exists."""
  userExists: Boolean

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""An input for mutations affecting `Task`"""
input TaskInput {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID
  name: String!
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input TaskNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `task` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TaskNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `task` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TaskOnTaskForTaskCardIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `task` to look up the row to update."""
input TaskOnTaskForTaskCardIdFkeyUsingTaskPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `task` being updated.
  """
  patch: updateTaskOnTaskForTaskCardIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TaskOnTaskForTaskTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `task` to look up the row to update."""
input TaskOnTaskForTaskTripIdFkeyUsingTaskPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `task` being updated.
  """
  patch: updateTaskOnTaskForTaskTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TaskOnTaskForTaskUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `task` to look up the row to update."""
input TaskOnTaskForTaskUserIdFkeyUsingTaskPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `task` being updated.
  """
  patch: updateTaskOnTaskForTaskUserIdFkeyPatch!
}

"""Represents an update to a `Task`. Fields that are set will be updated."""
input TaskPatch {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""The fields on `task` to look up the row to connect."""
input TaskTaskPkeyConnect {
  id: UUID!
}

"""The fields on `task` to look up the row to delete."""
input TaskTaskPkeyDelete {
  id: UUID!
}

"""Input for the nested mutation of `trip` in the `TaskInput` mutation."""
input TaskTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: TaskTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnTaskForTaskTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: TaskOnTaskForTaskTripIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `task` in the `TripInput` mutation."""
input TaskTripIdFkeyInverseInput {
  """The primary key(s) for `task` for the far side of the relationship."""
  connectById: [TaskTaskPkeyConnect!]

  """The primary key(s) for `task` for the far side of the relationship."""
  connectByNodeId: [TaskNodeIdConnect!]

  """
  A `TaskInput` object that will be created and connected to this object.
  """
  create: [TaskTripIdFkeyTaskCreateInput!]

  """The primary key(s) for `task` for the far side of the relationship."""
  deleteById: [TaskTaskPkeyDelete!]

  """The primary key(s) for `task` for the far side of the relationship."""
  deleteByNodeId: [TaskNodeIdDelete!]

  """
  Flag indicating whether all other `task` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `task` for the far side of the relationship.
  """
  updateById: [TaskOnTaskForTaskTripIdFkeyUsingTaskPkeyUpdate!]

  """
  The primary key(s) and patch data for `task` for the far side of the relationship.
  """
  updateByNodeId: [TripOnTaskForTaskTripIdFkeyNodeIdUpdate!]
}

"""The `task` to be created by this mutation."""
input TaskTripIdFkeyTaskCreateInput {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID
  name: String!
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""The `trip` to be created by this mutation."""
input TaskTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""Input for the nested mutation of `user` in the `TaskInput` mutation."""
input TaskUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnTaskForTaskUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: TaskOnTaskForTaskUserIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `task` in the `UserInput` mutation."""
input TaskUserIdFkeyInverseInput {
  """The primary key(s) for `task` for the far side of the relationship."""
  connectById: [TaskTaskPkeyConnect!]

  """The primary key(s) for `task` for the far side of the relationship."""
  connectByNodeId: [TaskNodeIdConnect!]

  """
  A `TaskInput` object that will be created and connected to this object.
  """
  create: [TaskUserIdFkeyTaskCreateInput!]

  """The primary key(s) for `task` for the far side of the relationship."""
  deleteById: [TaskTaskPkeyDelete!]

  """The primary key(s) for `task` for the far side of the relationship."""
  deleteByNodeId: [TaskNodeIdDelete!]

  """
  Flag indicating whether all other `task` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `task` for the far side of the relationship.
  """
  updateById: [TaskOnTaskForTaskUserIdFkeyUsingTaskPkeyUpdate!]

  """
  The primary key(s) and patch data for `task` for the far side of the relationship.
  """
  updateByNodeId: [UserOnTaskForTaskUserIdFkeyNodeIdUpdate!]
}

"""The `task` to be created by this mutation."""
input TaskUserIdFkeyTaskCreateInput {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID
  name: String!
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""A connection to a list of `Task` values."""
type TasksConnection {
  """
  A list of edges which contains the `Task` and cursor to aid in pagination.
  """
  edges: [TasksEdge!]!

  """A list of `Task` objects."""
  nodes: [Task!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Task` you could get from the connection."""
  totalCount: Int!
}

"""A `Task` edge in the connection."""
type TasksEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Task` at the end of the edge."""
  node: Task!
}

"""Methods to use when ordering `Task`."""
enum TasksOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  CARD_ID_ASC
  CARD_ID_DESC
  COMPLETE_ASC
  COMPLETE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  DATE_ASC
  DATE_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
}

type Template {
  archivedAt: Datetime
  budget: Float
  budgetType: [BudgetType]
  class: TripClass
  clientId: UUID
  collaboratorCount: Int
  createdAt: Datetime
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  imageId: UUID
  introduction: String
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisationId: UUID
  ownerId: UUID
  restoredAt: Datetime
  sourceId: UUID
  startDate: Date
  status: TripStatus
  stripePaymentId: String
  type: [TripType]
  updatedAt: Datetime
}

"""
A condition to be used against `Template` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TemplateCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `budget` field."""
  budget: Float

  """Checks for equality with the object’s `budgetType` field."""
  budgetType: [BudgetType]

  """Checks for equality with the object’s `class` field."""
  class: TripClass

  """Checks for equality with the object’s `clientId` field."""
  clientId: UUID

  """Checks for equality with the object’s `collaboratorCount` field."""
  collaboratorCount: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `currencyId` field."""
  currencyId: UUID

  """Checks for equality with the object’s `days` field."""
  days: Int

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `enableIdeas` field."""
  enableIdeas: Boolean

  """Checks for equality with the object’s `endDate` field."""
  endDate: Date

  """Checks for equality with the object’s `highlights` field."""
  highlights: JSON

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID

  """Checks for equality with the object’s `introduction` field."""
  introduction: String

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the object’s `legacyPaymentExpiry` field."""
  legacyPaymentExpiry: Datetime

  """Checks for equality with the object’s `legacyTier` field."""
  legacyTier: Tier

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `ownerId` field."""
  ownerId: UUID

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `sourceId` field."""
  sourceId: UUID

  """Checks for equality with the object’s `startDate` field."""
  startDate: Date

  """Checks for equality with the object’s `status` field."""
  status: TripStatus

  """Checks for equality with the object’s `stripePaymentId` field."""
  stripePaymentId: String

  """Checks for equality with the object’s `type` field."""
  type: [TripType]

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""
A filter to be used against `Template` object types. All fields are combined with a logical ‘and.’
"""
input TemplateFilter {
  """Checks for all expressions in this list."""
  and: [TemplateFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `budget` field."""
  budget: FloatFilter

  """Filter by the object’s `budgetType` field."""
  budgetType: BudgetTypeListFilter

  """Filter by the object’s `class` field."""
  class: TripClassFilter

  """Filter by the object’s `clientId` field."""
  clientId: UUIDFilter

  """Filter by the object’s `collaboratorCount` field."""
  collaboratorCount: IntFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `currencyId` field."""
  currencyId: UUIDFilter

  """Filter by the object’s `days` field."""
  days: IntFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `enableIdeas` field."""
  enableIdeas: BooleanFilter

  """Filter by the object’s `endDate` field."""
  endDate: DateFilter

  """Filter by the object’s `highlights` field."""
  highlights: JSONFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Filter by the object’s `introduction` field."""
  introduction: StringFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `isPublic` field."""
  isPublic: BooleanFilter

  """Filter by the object’s `legacyPaymentExpiry` field."""
  legacyPaymentExpiry: DatetimeFilter

  """Filter by the object’s `legacyTier` field."""
  legacyTier: TierFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: TemplateFilter

  """Filter by the object’s `notes` field."""
  notes: StringFilter

  """Checks for any expressions in this list."""
  or: [TemplateFilter!]

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `ownerId` field."""
  ownerId: UUIDFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `sourceId` field."""
  sourceId: UUIDFilter

  """Filter by the object’s `startDate` field."""
  startDate: DateFilter

  """Filter by the object’s `status` field."""
  status: TripStatusFilter

  """Filter by the object’s `stripePaymentId` field."""
  stripePaymentId: StringFilter

  """Filter by the object’s `type` field."""
  type: TripTypeListFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

"""An input for mutations affecting `Template`"""
input TemplateInput {
  archivedAt: Datetime
  budget: Float
  budgetType: [BudgetType]
  class: TripClass
  clientId: UUID
  collaboratorCount: Int
  createdAt: Datetime
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  imageId: UUID
  introduction: String
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisationId: UUID
  ownerId: UUID
  restoredAt: Datetime
  sourceId: UUID
  startDate: Date
  status: TripStatus
  stripePaymentId: String
  type: [TripType]
  updatedAt: Datetime
}

"""A connection to a list of `Template` values."""
type TemplatesConnection {
  """
  A list of edges which contains the `Template` and cursor to aid in pagination.
  """
  edges: [TemplatesEdge!]!

  """A list of `Template` objects."""
  nodes: [Template!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Template` you could get from the connection."""
  totalCount: Int!
}

"""A `Template` edge in the connection."""
type TemplatesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Template` at the end of the edge."""
  node: Template!
}

"""Methods to use when ordering `Template`."""
enum TemplatesOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  BUDGET_ASC
  BUDGET_DESC
  BUDGET_TYPE_ASC
  BUDGET_TYPE_DESC
  CLASS_ASC
  CLASS_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  COLLABORATOR_COUNT_ASC
  COLLABORATOR_COUNT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CURRENCY_ID_ASC
  CURRENCY_ID_DESC
  DAYS_ASC
  DAYS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ENABLE_IDEAS_ASC
  ENABLE_IDEAS_DESC
  END_DATE_ASC
  END_DATE_DESC
  HIGHLIGHTS_ASC
  HIGHLIGHTS_DESC
  ID_ASC
  ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  INTRODUCTION_ASC
  INTRODUCTION_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  LEGACY_PAYMENT_EXPIRY_ASC
  LEGACY_PAYMENT_EXPIRY_DESC
  LEGACY_TIER_ASC
  LEGACY_TIER_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SOURCE_ID_ASC
  SOURCE_ID_DESC
  START_DATE_ASC
  START_DATE_DESC
  STATUS_ASC
  STATUS_DESC
  STRIPE_PAYMENT_ID_ASC
  STRIPE_PAYMENT_ID_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

enum Tier {
  FREE
  PLUS
  PRO
}

"""
A filter to be used against Tier fields. All fields are combined with a logical ‘and.’
"""
input TierFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Tier

  """Equal to the specified value."""
  equalTo: Tier

  """Greater than the specified value."""
  greaterThan: Tier

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Tier

  """Included in the specified list."""
  in: [Tier!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Tier

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Tier

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Tier

  """Not equal to the specified value."""
  notEqualTo: Tier

  """Not included in the specified list."""
  notIn: [Tier!]
}

"""
The exact time of day, does not include the date. May or may not have a timezone offset.
"""
scalar Time

"""
A filter to be used against Time fields. All fields are combined with a logical ‘and.’
"""
input TimeFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: Time

  """Equal to the specified value."""
  equalTo: Time

  """Greater than the specified value."""
  greaterThan: Time

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: Time

  """Included in the specified list."""
  in: [Time!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: Time

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: Time

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: Time

  """Not equal to the specified value."""
  notEqualTo: Time

  """Not included in the specified list."""
  notIn: [Time!]
}

type Timezone {
  iso: String
  name: String!
  offset: BigInt
}

type TimezonesConnection {
  nodes: [Timezone]!
}

"""All input for the `toggleAttachmentVisibility` mutation."""
input ToggleAttachmentVisibilityInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  collaboratorUserId: UUID!
  tripId: UUID!
}

"""The output of our `toggleAttachmentVisibility` mutation."""
type ToggleAttachmentVisibilityPayload {
  """Reads a single `Asset` that is related to this `User`."""
  avatar: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `User`."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `transferOrganisationOwnership` mutation."""
input TransferOrganisationOwnershipInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  orgId: UUID!
  userId: UUID!
}

"""The output of our `transferOrganisationOwnership` mutation."""
type TransferOrganisationOwnershipPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type Trip implements Node {
  appearance: TripAppearance

  """When this item was archived"""
  archivedAt: Datetime

  """Reads and enables pagination through a set of `Attachment`."""
  attachments(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttachmentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AttachmentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttachmentsConnection!

  """Reads and enables pagination through a set of `Attachment`."""
  attachmentsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttachmentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AttachmentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!]
  ): [Attachment!]!
  budget: Float
  budgetBreakdown: Budget
  budgetType: [BudgetType]

  """Reads and enables pagination through a set of `Card`."""
  cards(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsConnection!

  """Reads and enables pagination through a set of `Card`."""
  cardsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!]
  ): [Card!]!
  class: TripClass

  """Reads a single `Client` that is related to this `Trip`."""
  client: Client
  clientId: UUID
  collaboratorCount: Int
  collaborators: [TripCollaborator] @deprecated(reason: "Use `collaboratorsV2`")

  """Reads and enables pagination through a set of `Collaborator`."""
  collaboratorsV2(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CollaboratorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CollaboratorFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Collaborator`."""
    orderBy: [CollaboratorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollaboratorsConnection!

  """Reads and enables pagination through a set of `Collaborator`."""
  collaboratorsV2List(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CollaboratorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CollaboratorFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Collaborator`."""
    orderBy: [CollaboratorsOrderBy!]
  ): [Collaborator!]!

  """Reads and enables pagination through a set of `TripCountry`."""
  countries(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripCountriesConnection!

  """Reads and enables pagination through a set of `TripCountry`."""
  countriesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCountryCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripCountryFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!]
  ): [TripCountry!]!

  """Fallback Order: Trip Image -> Region Image -> Country Image"""
  coverImage: Asset

  """When this item was created"""
  createdAt: Datetime

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency
  currencyId: UUID
  currentPermissions: [Permission]
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  humanUri: String
  id: UUID!

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset
  imageId: UUID

  """Reads and enables pagination through a set of `TripAssetImage`."""
  images(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripAssetImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripAssetImageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripAssetImagesConnection!

  """Reads and enables pagination through a set of `TripAssetImage`."""
  imagesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripAssetImageCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripAssetImageFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!]
  ): [TripAssetImage!]!
  introduction: String

  """Reads and enables pagination through a set of `InviteV2`."""
  inviteV2s(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InviteV2Condition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InviteV2Filter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `InviteV2`."""
    orderBy: [InviteV2sOrderBy!] = [PRIMARY_KEY_ASC]
  ): InviteV2sConnection!

  """Reads and enables pagination through a set of `InviteV2`."""
  inviteV2sList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InviteV2Condition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: InviteV2Filter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `InviteV2`."""
    orderBy: [InviteV2sOrderBy!]
  ): [InviteV2!]!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime @deprecated(reason: "Use Account.gratis_end_date")
  legacyTier: Tier! @deprecated(reason: "Use Account.tier")
  markers: [Marker]
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  notes: String

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation
  organisationId: UUID

  """Reads a single `User` that is related to this `Trip`."""
  owner: User
  ownerEmail: String
  ownerId: UUID
  paymentExpiry: Datetime @deprecated(reason: "Use Account.gratis_end_date")

  """Reads and enables pagination through a set of `TripRegion`."""
  regions(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripRegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripRegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripRegionsConnection!

  """Reads and enables pagination through a set of `TripRegion`."""
  regionsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripRegionCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripRegionFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!]
  ): [TripRegion!]!

  """Whether this trip requires payment"""
  requiresPayment: Boolean

  """When this item was restored"""
  restoredAt: Datetime

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip
  sourceId: UUID
  startDate: Date
  status: TripStatus

  """Reads and enables pagination through a set of `TagTrip`."""
  tags(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagTripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagTripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagTripsConnection!

  """Reads and enables pagination through a set of `TagTrip`."""
  tagsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TagTripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TagTripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!]
  ): [TagTrip!]!

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksConnection!

  """Reads and enables pagination through a set of `Task`."""
  tasksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!]
  ): [Task!]!
  tier: Tier
  timezone: Timezone! @deprecated(reason: "Use timezones")

  """
  The most accurate timezones for the trip based off available trip locations
  """
  timezones(timestamp: Datetime): [Timezone]!

  """Reads and enables pagination through a set of `Trip`."""
  tripsBySourceId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsBySourceIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]!
  type: [TripType]

  """When this item was updated"""
  updatedAt: Datetime
}

type TripAppearance {
  boldColours: Boolean
  showImageOnCard: Boolean
}

"""An input for mutations affecting `TripAppearance`"""
input TripAppearanceInput {
  boldColours: Boolean
  showImageOnCard: Boolean
}

type TripAssetImage implements Node {
  """Reads a single `Asset` that is related to this `TripAssetImage`."""
  asset: Asset
  assetId: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  sorting: Int

  """Reads a single `Trip` that is related to this `TripAssetImage`."""
  trip: Trip
  tripId: UUID!
}

"""The `asset` to be created by this mutation."""
input TripAssetImageAssetIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
Input for the nested mutation of `asset` in the `TripAssetImageInput` mutation.
"""
input TripAssetImageAssetIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: TripAssetImageAssetIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnTripAssetImageForTripAssetImageAssetIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: TripAssetImageOnTripAssetImageForTripAssetImageAssetIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `tripAssetImage` in the `AssetInput` mutation.
"""
input TripAssetImageAssetIdFkeyInverseInput {
  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  connectByNodeId: [TripAssetImageNodeIdConnect!]

  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  connectByTripIdAndAssetId: [TripAssetImageTripAssetImagePkeyConnect!]

  """
  A `TripAssetImageInput` object that will be created and connected to this object.
  """
  create: [TripAssetImageAssetIdFkeyTripAssetImageCreateInput!]

  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  deleteByNodeId: [TripAssetImageNodeIdDelete!]

  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  deleteByTripIdAndAssetId: [TripAssetImageTripAssetImagePkeyDelete!]

  """
  Flag indicating whether all other `tripAssetImage` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tripAssetImage` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnTripAssetImageForTripAssetImageAssetIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tripAssetImage` for the far side of the relationship.
  """
  updateByTripIdAndAssetId: [TripAssetImageOnTripAssetImageForTripAssetImageAssetIdFkeyUsingTripAssetImagePkeyUpdate!]
}

"""The `tripAssetImage` to be created by this mutation."""
input TripAssetImageAssetIdFkeyTripAssetImageCreateInput {
  asset: TripAssetImageAssetIdFkeyInput
  assetId: UUID
  sorting: Int
  trip: TripAssetImageTripIdFkeyInput
  tripId: UUID
}

"""
A condition to be used against `TripAssetImage` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TripAssetImageCondition {
  """Checks for equality with the object’s `assetId` field."""
  assetId: UUID

  """Checks for equality with the object’s `sorting` field."""
  sorting: Int

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID
}

"""
A filter to be used against `TripAssetImage` object types. All fields are combined with a logical ‘and.’
"""
input TripAssetImageFilter {
  """Checks for all expressions in this list."""
  and: [TripAssetImageFilter!]

  """Filter by the object’s `asset` relation."""
  asset: AssetFilter

  """Filter by the object’s `assetId` field."""
  assetId: UUIDFilter

  """Negates the expression."""
  not: TripAssetImageFilter

  """Checks for any expressions in this list."""
  or: [TripAssetImageFilter!]

  """Filter by the object’s `sorting` field."""
  sorting: IntFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter
}

"""An input for mutations affecting `TripAssetImage`"""
input TripAssetImageInput {
  asset: TripAssetImageAssetIdFkeyInput
  assetId: UUID
  sorting: Int
  trip: TripAssetImageTripIdFkeyInput
  tripId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input TripAssetImageNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `tripAssetImage` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TripAssetImageNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `tripAssetImage` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TripAssetImageOnTripAssetImageForTripAssetImageAssetIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `tripAssetImage` to look up the row to update."""
input TripAssetImageOnTripAssetImageForTripAssetImageAssetIdFkeyUsingTripAssetImagePkeyUpdate {
  assetId: UUID!

  """
  An object where the defined keys will be set on the `tripAssetImage` being updated.
  """
  patch: updateTripAssetImageOnTripAssetImageForTripAssetImageAssetIdFkeyPatch!
  tripId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input TripAssetImageOnTripAssetImageForTripAssetImageTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `tripAssetImage` to look up the row to update."""
input TripAssetImageOnTripAssetImageForTripAssetImageTripIdFkeyUsingTripAssetImagePkeyUpdate {
  assetId: UUID!

  """
  An object where the defined keys will be set on the `tripAssetImage` being updated.
  """
  patch: updateTripAssetImageOnTripAssetImageForTripAssetImageTripIdFkeyPatch!
  tripId: UUID!
}

"""
Represents an update to a `TripAssetImage`. Fields that are set will be updated.
"""
input TripAssetImagePatch {
  asset: TripAssetImageAssetIdFkeyInput
  assetId: UUID
  sorting: Int
  trip: TripAssetImageTripIdFkeyInput
  tripId: UUID
}

"""The fields on `tripAssetImage` to look up the row to connect."""
input TripAssetImageTripAssetImagePkeyConnect {
  assetId: UUID!
  tripId: UUID!
}

"""The fields on `tripAssetImage` to look up the row to delete."""
input TripAssetImageTripAssetImagePkeyDelete {
  assetId: UUID!
  tripId: UUID!
}

"""
Input for the nested mutation of `trip` in the `TripAssetImageInput` mutation.
"""
input TripAssetImageTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: TripAssetImageTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnTripAssetImageForTripAssetImageTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: TripAssetImageOnTripAssetImageForTripAssetImageTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `tripAssetImage` in the `TripInput` mutation.
"""
input TripAssetImageTripIdFkeyInverseInput {
  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  connectByNodeId: [TripAssetImageNodeIdConnect!]

  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  connectByTripIdAndAssetId: [TripAssetImageTripAssetImagePkeyConnect!]

  """
  A `TripAssetImageInput` object that will be created and connected to this object.
  """
  create: [TripAssetImageTripIdFkeyTripAssetImageCreateInput!]

  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  deleteByNodeId: [TripAssetImageNodeIdDelete!]

  """
  The primary key(s) for `tripAssetImage` for the far side of the relationship.
  """
  deleteByTripIdAndAssetId: [TripAssetImageTripAssetImagePkeyDelete!]

  """
  Flag indicating whether all other `tripAssetImage` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tripAssetImage` for the far side of the relationship.
  """
  updateByNodeId: [TripOnTripAssetImageForTripAssetImageTripIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tripAssetImage` for the far side of the relationship.
  """
  updateByTripIdAndAssetId: [TripAssetImageOnTripAssetImageForTripAssetImageTripIdFkeyUsingTripAssetImagePkeyUpdate!]
}

"""The `tripAssetImage` to be created by this mutation."""
input TripAssetImageTripIdFkeyTripAssetImageCreateInput {
  asset: TripAssetImageAssetIdFkeyInput
  assetId: UUID
  sorting: Int
  trip: TripAssetImageTripIdFkeyInput
  tripId: UUID
}

"""The `trip` to be created by this mutation."""
input TripAssetImageTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""A connection to a list of `TripAssetImage` values."""
type TripAssetImagesConnection {
  """
  A list of edges which contains the `TripAssetImage` and cursor to aid in pagination.
  """
  edges: [TripAssetImagesEdge!]!

  """A list of `TripAssetImage` objects."""
  nodes: [TripAssetImage!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TripAssetImage` you could get from the connection."""
  totalCount: Int!
}

"""A `TripAssetImage` edge in the connection."""
type TripAssetImagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TripAssetImage` at the end of the edge."""
  node: TripAssetImage!
}

"""Methods to use when ordering `TripAssetImage`."""
enum TripAssetImagesOrderBy {
  ASSET_ID_ASC
  ASSET_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  SORTING_ASC
  SORTING_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
}

type TripBudgetValueCount {
  from1000To2499: BigInt
  from2500To4999: BigInt
  from5000To10000: BigInt
  greater10000: BigInt
  less1000: BigInt
}

enum TripClass {
  CONSUMER
  DISCOVER
  PROPOSAL
  TEMPLATE
}

"""
A filter to be used against TripClass fields. All fields are combined with a logical ‘and.’
"""
input TripClassFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: TripClass

  """Equal to the specified value."""
  equalTo: TripClass

  """Greater than the specified value."""
  greaterThan: TripClass

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: TripClass

  """Included in the specified list."""
  in: [TripClass!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: TripClass

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: TripClass

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: TripClass

  """Not equal to the specified value."""
  notEqualTo: TripClass

  """Not included in the specified list."""
  notIn: [TripClass!]
}

"""All input for the `tripClearCountryRelations` mutation."""
input TripClearCountryRelationsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `tripClearCountryRelations` mutation."""
type TripClearCountryRelationsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `tripClearImageRelations` mutation."""
input TripClearImageRelationsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `tripClearImageRelations` mutation."""
type TripClearImageRelationsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `tripClearRegionRelations` mutation."""
input TripClearRegionRelationsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `tripClearRegionRelations` mutation."""
type TripClearRegionRelationsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `tripClearTagRelations` mutation."""
input TripClearTagRelationsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `tripClearTagRelations` mutation."""
type TripClearTagRelationsPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""The `client` to be created by this mutation."""
input TripClientIdFkeyClientCreateInput {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType!
  user: ClientAuthorIdFkeyInput
}

"""Input for the nested mutation of `client` in the `TripInput` mutation."""
input TripClientIdFkeyInput {
  """The primary key(s) for `client` for the far side of the relationship."""
  connectById: ClientClientPkeyConnect

  """The primary key(s) for `client` for the far side of the relationship."""
  connectByNodeId: ClientNodeIdConnect

  """
  A `ClientInput` object that will be created and connected to this object.
  """
  create: TripClientIdFkeyClientCreateInput

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteById: ClientClientPkeyDelete

  """The primary key(s) for `client` for the far side of the relationship."""
  deleteByNodeId: ClientNodeIdDelete

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateById: ClientOnTripForTripClientIdFkeyUsingClientPkeyUpdate

  """
  The primary key(s) and patch data for `client` for the far side of the relationship.
  """
  updateByNodeId: TripOnTripForTripClientIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `trip` in the `ClientInput` mutation."""
input TripClientIdFkeyInverseInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: [TripTripPkeyConnect!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: [TripNodeIdConnect!]

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: [TripClientIdFkeyTripCreateInput!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: [TripTripPkeyDelete!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: [TripNodeIdDelete!]

  """
  Flag indicating whether all other `trip` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: [TripOnTripForTripClientIdFkeyUsingTripPkeyUpdate!]

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: [ClientOnTripForTripClientIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input TripClientIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

type TripCollaborator {
  email: String
  id: UUID!
  isInvite: Boolean
  isOwner: Boolean
  permissions: [TripPermission]!
  user: User
}

"""
A condition to be used against `Trip` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TripCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `budget` field."""
  budget: Float

  """Checks for equality with the object’s `budgetType` field."""
  budgetType: [BudgetType]

  """Checks for equality with the object’s `class` field."""
  class: TripClass

  """Checks for equality with the object’s `clientId` field."""
  clientId: UUID

  """Checks for equality with the object’s `collaboratorCount` field."""
  collaboratorCount: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `currencyId` field."""
  currencyId: UUID

  """Checks for equality with the object’s `days` field."""
  days: Int

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `enableIdeas` field."""
  enableIdeas: Boolean

  """Checks for equality with the object’s `endDate` field."""
  endDate: Date

  """Checks for equality with the object’s `highlights` field."""
  highlights: JSON

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `imageId` field."""
  imageId: UUID

  """Checks for equality with the object’s `introduction` field."""
  introduction: String

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the object’s `legacyPaymentExpiry` field."""
  legacyPaymentExpiry: Datetime

  """Checks for equality with the object’s `legacyTier` field."""
  legacyTier: Tier

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `notes` field."""
  notes: String

  """Checks for equality with the object’s `organisationId` field."""
  organisationId: UUID

  """Checks for equality with the object’s `ownerId` field."""
  ownerId: UUID

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `sourceId` field."""
  sourceId: UUID

  """Checks for equality with the object’s `startDate` field."""
  startDate: Date

  """Checks for equality with the object’s `status` field."""
  status: TripStatus

  """Checks for equality with the object’s `type` field."""
  type: [TripType]

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `TripCountry` values."""
type TripCountriesConnection {
  """
  A list of edges which contains the `TripCountry` and cursor to aid in pagination.
  """
  edges: [TripCountriesEdge!]!

  """A list of `TripCountry` objects."""
  nodes: [TripCountry!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TripCountry` you could get from the connection."""
  totalCount: Int!
}

"""A `TripCountry` edge in the connection."""
type TripCountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TripCountry` at the end of the edge."""
  node: TripCountry!
}

"""Methods to use when ordering `TripCountry`."""
enum TripCountriesOrderBy {
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
}

type TripCountry implements Node {
  """Reads a single `Country` that is related to this `TripCountry`."""
  country: Country
  countryId: UUID!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Trip` that is related to this `TripCountry`."""
  trip: Trip
  tripId: UUID!
}

"""
A condition to be used against `TripCountry` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TripCountryCondition {
  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID
}

"""The `country` to be created by this mutation."""
input TripCountryCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `TripCountryInput` mutation.
"""
input TripCountryCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: TripCountryCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnTripCountryForTripCountryCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnTripCountryForTripCountryCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: TripCountryOnTripCountryForTripCountryCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnTripCountryForTripCountryCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `tripCountry` in the `CountryInput` mutation.
"""
input TripCountryCountryIdFkeyInverseInput {
  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  connectByNodeId: [TripCountryNodeIdConnect!]

  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  connectByTripIdAndCountryId: [TripCountryTripCountryPkeyConnect!]

  """
  A `TripCountryInput` object that will be created and connected to this object.
  """
  create: [TripCountryCountryIdFkeyTripCountryCreateInput!]

  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  deleteByNodeId: [TripCountryNodeIdDelete!]

  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  deleteByTripIdAndCountryId: [TripCountryTripCountryPkeyDelete!]

  """
  Flag indicating whether all other `tripCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tripCountry` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnTripCountryForTripCountryCountryIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tripCountry` for the far side of the relationship.
  """
  updateByTripIdAndCountryId: [TripCountryOnTripCountryForTripCountryCountryIdFkeyUsingTripCountryPkeyUpdate!]
}

"""The `tripCountry` to be created by this mutation."""
input TripCountryCountryIdFkeyTripCountryCreateInput {
  country: TripCountryCountryIdFkeyInput
  countryId: UUID
  trip: TripCountryTripIdFkeyInput
  tripId: UUID
}

"""
A filter to be used against `TripCountry` object types. All fields are combined with a logical ‘and.’
"""
input TripCountryFilter {
  """Checks for all expressions in this list."""
  and: [TripCountryFilter!]

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Negates the expression."""
  not: TripCountryFilter

  """Checks for any expressions in this list."""
  or: [TripCountryFilter!]

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter
}

"""An input for mutations affecting `TripCountry`"""
input TripCountryInput {
  country: TripCountryCountryIdFkeyInput
  countryId: UUID
  trip: TripCountryTripIdFkeyInput
  tripId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input TripCountryNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `tripCountry` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TripCountryNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `tripCountry` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TripCountryOnTripCountryForTripCountryCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `tripCountry` to look up the row to update."""
input TripCountryOnTripCountryForTripCountryCountryIdFkeyUsingTripCountryPkeyUpdate {
  countryId: UUID!

  """
  An object where the defined keys will be set on the `tripCountry` being updated.
  """
  patch: updateTripCountryOnTripCountryForTripCountryCountryIdFkeyPatch!
  tripId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input TripCountryOnTripCountryForTripCountryTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `tripCountry` to look up the row to update."""
input TripCountryOnTripCountryForTripCountryTripIdFkeyUsingTripCountryPkeyUpdate {
  countryId: UUID!

  """
  An object where the defined keys will be set on the `tripCountry` being updated.
  """
  patch: updateTripCountryOnTripCountryForTripCountryTripIdFkeyPatch!
  tripId: UUID!
}

"""
Represents an update to a `TripCountry`. Fields that are set will be updated.
"""
input TripCountryPatch {
  country: TripCountryCountryIdFkeyInput
  countryId: UUID
  trip: TripCountryTripIdFkeyInput
  tripId: UUID
}

"""The fields on `tripCountry` to look up the row to connect."""
input TripCountryTripCountryPkeyConnect {
  countryId: UUID!
  tripId: UUID!
}

"""The fields on `tripCountry` to look up the row to delete."""
input TripCountryTripCountryPkeyDelete {
  countryId: UUID!
  tripId: UUID!
}

"""
Input for the nested mutation of `trip` in the `TripCountryInput` mutation.
"""
input TripCountryTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: TripCountryTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnTripCountryForTripCountryTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: TripCountryOnTripCountryForTripCountryTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `tripCountry` in the `TripInput` mutation.
"""
input TripCountryTripIdFkeyInverseInput {
  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  connectByNodeId: [TripCountryNodeIdConnect!]

  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  connectByTripIdAndCountryId: [TripCountryTripCountryPkeyConnect!]

  """
  A `TripCountryInput` object that will be created and connected to this object.
  """
  create: [TripCountryTripIdFkeyTripCountryCreateInput!]

  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  deleteByNodeId: [TripCountryNodeIdDelete!]

  """
  The primary key(s) for `tripCountry` for the far side of the relationship.
  """
  deleteByTripIdAndCountryId: [TripCountryTripCountryPkeyDelete!]

  """
  Flag indicating whether all other `tripCountry` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tripCountry` for the far side of the relationship.
  """
  updateByNodeId: [TripOnTripCountryForTripCountryTripIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tripCountry` for the far side of the relationship.
  """
  updateByTripIdAndCountryId: [TripCountryOnTripCountryForTripCountryTripIdFkeyUsingTripCountryPkeyUpdate!]
}

"""The `tripCountry` to be created by this mutation."""
input TripCountryTripIdFkeyTripCountryCreateInput {
  country: TripCountryCountryIdFkeyInput
  countryId: UUID
  trip: TripCountryTripIdFkeyInput
  tripId: UUID
}

"""The `trip` to be created by this mutation."""
input TripCountryTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""The `currency` to be created by this mutation."""
input TripCurrencyIdFkeyCurrencyCreateInput {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
Input for the nested mutation of `currency` in the `TripInput` mutation.
"""
input TripCurrencyIdFkeyInput {
  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectById: CurrencyCurrencyPkeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByIso: CurrencyCurrencyIsoKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByName: CurrencyCurrencyNameKeyConnect

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  connectByNodeId: CurrencyNodeIdConnect

  """
  A `CurrencyInput` object that will be created and connected to this object.
  """
  create: TripCurrencyIdFkeyCurrencyCreateInput

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteById: CurrencyCurrencyPkeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByIso: CurrencyCurrencyIsoKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByName: CurrencyCurrencyNameKeyDelete

  """
  The primary key(s) for `currency` for the far side of the relationship.
  """
  deleteByNodeId: CurrencyNodeIdDelete

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateById: CurrencyOnTripForTripCurrencyIdFkeyUsingCurrencyPkeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByIso: CurrencyOnTripForTripCurrencyIdFkeyUsingCurrencyIsoKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByName: CurrencyOnTripForTripCurrencyIdFkeyUsingCurrencyNameKeyUpdate

  """
  The primary key(s) and patch data for `currency` for the far side of the relationship.
  """
  updateByNodeId: TripOnTripForTripCurrencyIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `trip` in the `CurrencyInput` mutation.
"""
input TripCurrencyIdFkeyInverseInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: [TripTripPkeyConnect!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: [TripNodeIdConnect!]

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: [TripCurrencyIdFkeyTripCreateInput!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: [TripTripPkeyDelete!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: [TripNodeIdDelete!]

  """
  Flag indicating whether all other `trip` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: [TripOnTripForTripCurrencyIdFkeyUsingTripPkeyUpdate!]

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: [CurrencyOnTripForTripCurrencyIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input TripCurrencyIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""A connection to a list of `TripDateFrequency` values."""
type TripDateFrequenciesConnection {
  """
  A list of edges which contains the `TripDateFrequency` and cursor to aid in pagination.
  """
  edges: [TripDateFrequenciesEdge!]!

  """A list of `TripDateFrequency` objects."""
  nodes: [TripDateFrequency!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `TripDateFrequency` you could get from the connection.
  """
  totalCount: Int!
}

"""A `TripDateFrequency` edge in the connection."""
type TripDateFrequenciesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TripDateFrequency` at the end of the edge."""
  node: TripDateFrequency!
}

"""Methods to use when ordering `TripDateFrequency`."""
enum TripDateFrequenciesOrderBy {
  COUNT_ASC
  COUNT_DESC
  DATE_ASC
  DATE_DESC
  NATURAL
}

type TripDateFrequency {
  count: BigInt
  date: Datetime
}

"""
A condition to be used against `TripDateFrequency` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TripDateFrequencyCondition {
  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `date` field."""
  date: Datetime
}

"""
A filter to be used against `TripDateFrequency` object types. All fields are combined with a logical ‘and.’
"""
input TripDateFrequencyFilter {
  """Checks for all expressions in this list."""
  and: [TripDateFrequencyFilter!]

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Negates the expression."""
  not: TripDateFrequencyFilter

  """Checks for any expressions in this list."""
  or: [TripDateFrequencyFilter!]
}

"""
A filter to be used against `Trip` object types. All fields are combined with a logical ‘and.’
"""
input TripFilter {
  """Checks for all expressions in this list."""
  and: [TripFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `attachments` relation."""
  attachments: TripToManyAttachmentFilter

  """Some related `attachments` exist."""
  attachmentsExist: Boolean

  """Filter by the object’s `budget` field."""
  budget: FloatFilter

  """Filter by the object’s `budgetType` field."""
  budgetType: BudgetTypeListFilter

  """Filter by the object’s `cards` relation."""
  cards: TripToManyCardFilter

  """Some related `cards` exist."""
  cardsExist: Boolean

  """Filter by the object’s `class` field."""
  class: TripClassFilter

  """Filter by the object’s `client` relation."""
  client: ClientFilter

  """A related `client` exists."""
  clientExists: Boolean

  """Filter by the object’s `clientId` field."""
  clientId: UUIDFilter

  """Filter by the object’s `collaboratorCount` field."""
  collaboratorCount: IntFilter

  """Filter by the object’s `collaboratorsV2` relation."""
  collaboratorsV2: TripToManyCollaboratorFilter

  """Some related `collaboratorsV2` exist."""
  collaboratorsV2Exist: Boolean

  """Filter by the object’s `countries` relation."""
  countries: TripToManyTripCountryFilter

  """Some related `countries` exist."""
  countriesExist: Boolean

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `currency` relation."""
  currency: CurrencyFilter

  """A related `currency` exists."""
  currencyExists: Boolean

  """Filter by the object’s `currencyId` field."""
  currencyId: UUIDFilter

  """Filter by the object’s `currentPermissions` field."""
  currentPermissions: PermissionListFilter

  """Filter by the object’s `days` field."""
  days: IntFilter

  """Filter by the object’s `description` field."""
  description: StringFilter

  """Filter by the object’s `enableIdeas` field."""
  enableIdeas: BooleanFilter

  """Filter by the object’s `endDate` field."""
  endDate: DateFilter

  """Filter by the object’s `highlights` field."""
  highlights: JSONFilter

  """Filter by the object’s `humanUri` field."""
  humanUri: StringFilter

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `image` relation."""
  image: AssetFilter

  """A related `image` exists."""
  imageExists: Boolean

  """Filter by the object’s `imageId` field."""
  imageId: UUIDFilter

  """Filter by the object’s `images` relation."""
  images: TripToManyTripAssetImageFilter

  """Some related `images` exist."""
  imagesExist: Boolean

  """Filter by the object’s `introduction` field."""
  introduction: StringFilter

  """Filter by the object’s `inviteV2s` relation."""
  inviteV2s: TripToManyInviteV2Filter

  """Some related `inviteV2s` exist."""
  inviteV2sExist: Boolean

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `isPublic` field."""
  isPublic: BooleanFilter

  """Filter by the object’s `legacyPaymentExpiry` field."""
  legacyPaymentExpiry: DatetimeFilter

  """Filter by the object’s `legacyTier` field."""
  legacyTier: TierFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: TripFilter

  """Filter by the object’s `notes` field."""
  notes: StringFilter

  """Checks for any expressions in this list."""
  or: [TripFilter!]

  """Filter by the object’s `organisation` relation."""
  organisation: OrganisationFilter

  """A related `organisation` exists."""
  organisationExists: Boolean

  """Filter by the object’s `organisationId` field."""
  organisationId: UUIDFilter

  """Filter by the object’s `owner` relation."""
  owner: UserFilter

  """Filter by the object’s `ownerEmail` field."""
  ownerEmail: StringFilter

  """A related `owner` exists."""
  ownerExists: Boolean

  """Filter by the object’s `ownerId` field."""
  ownerId: UUIDFilter

  """Filter by the object’s `paymentExpiry` field."""
  paymentExpiry: DatetimeFilter

  """Filter by the object’s `regions` relation."""
  regions: TripToManyTripRegionFilter

  """Some related `regions` exist."""
  regionsExist: Boolean

  """Filter by the object’s `requiresPayment` field."""
  requiresPayment: BooleanFilter

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `source` relation."""
  source: TripFilter

  """A related `source` exists."""
  sourceExists: Boolean

  """Filter by the object’s `sourceId` field."""
  sourceId: UUIDFilter

  """Filter by the object’s `startDate` field."""
  startDate: DateFilter

  """Filter by the object’s `status` field."""
  status: TripStatusFilter

  """Filter by the object’s `tags` relation."""
  tags: TripToManyTagTripFilter

  """Some related `tags` exist."""
  tagsExist: Boolean

  """Filter by the object’s `tasks` relation."""
  tasks: TripToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the object’s `tier` field."""
  tier: TierFilter

  """Filter by the object’s `tripsBySourceId` relation."""
  tripsBySourceId: TripToManyTripFilter

  """Some related `tripsBySourceId` exist."""
  tripsBySourceIdExist: Boolean

  """Filter by the object’s `type` field."""
  type: TripTypeListFilter

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter
}

type TripGroupLength {
  days13: BigInt
  days15Plus: BigInt
  days47: BigInt
  days814: BigInt
}

"""The `asset` to be created by this mutation."""
input TripImageIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""Input for the nested mutation of `asset` in the `TripInput` mutation."""
input TripImageIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: TripImageIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnTripForTripImageIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: TripOnTripForTripImageIdFkeyNodeIdUpdate
}

"""An input for mutations affecting `Trip`"""
input TripInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""The globally unique `ID` look up for the row to connect."""
input TripNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TripNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `trip` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnAttachmentForAttachmentTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `attachment` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `attachment` being updated.
  """
  patch: AttachmentPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnAttachmentForAttachmentTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnAttachmentForAttachmentTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnCardForCardTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnCardForCardTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnCardForCardTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnCollaboratorForCollaboratorTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `collaborator` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `collaborator` being updated.
  """
  patch: CollaboratorPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnCollaboratorForCollaboratorTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnCollaboratorForCollaboratorTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnInviteV2ForInviteTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `inviteV2` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `inviteV2` being updated.
  """
  patch: InviteV2Patch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnInviteV2ForInviteTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnInviteV2ForInviteTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTagTripForTagTripTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tagTrip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tagTrip` being updated.
  """
  patch: TagTripPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTagTripForTagTripTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTagTripForTagTripTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTaskForTaskTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `task` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `task` being updated.
  """
  patch: TaskPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTaskForTaskTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTaskForTaskTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripAssetImageForTripAssetImageTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tripAssetImage` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tripAssetImage` being updated.
  """
  patch: TripAssetImagePatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripAssetImageForTripAssetImageTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripAssetImageForTripAssetImageTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripCountryForTripCountryTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tripCountry` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tripCountry` being updated.
  """
  patch: TripCountryPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripCountryForTripCountryTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripCountryForTripCountryTripIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripForTripClientIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `client` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: ClientPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripForTripClientIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripForTripClientIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripForTripCurrencyIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `currency` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `currency` being updated.
  """
  patch: CurrencyPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripForTripCurrencyIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripForTripCurrencyIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripForTripImageIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripForTripOrganisationIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisation` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripForTripOrganisationIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripForTripOrganisationIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripForTripOwnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripForTripOwnerIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripForTripOwnerIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripForTripSourceIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripForTripSourceIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripForTripSourceIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input TripOnTripRegionForTripRegionTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `tripRegion` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `tripRegion` being updated.
  """
  patch: TripRegionPatch!
}

"""The fields on `trip` to look up the row to update."""
input TripOnTripRegionForTripRegionTripIdFkeyUsingTripPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: updateTripOnTripRegionForTripRegionTripIdFkeyPatch!
}

"""
Input for the nested mutation of `organisation` in the `TripInput` mutation.
"""
input TripOrganisationIdFkeyInput {
  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectById: OrganisationOrganisationPkeyConnect

  """
  The primary key(s) for `organisation` for the far side of the relationship.
  """
  connectByNodeId: OrganisationNodeIdConnect

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateById: OrganisationOnTripForTripOrganisationIdFkeyUsingOrganisationPkeyUpdate

  """
  The primary key(s) and patch data for `organisation` for the far side of the relationship.
  """
  updateByNodeId: TripOnTripForTripOrganisationIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `trip` in the `OrganisationInput` mutation.
"""
input TripOrganisationIdFkeyInverseInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: [TripTripPkeyConnect!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: [TripNodeIdConnect!]

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: [TripOrganisationIdFkeyTripCreateInput!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: [TripTripPkeyDelete!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: [TripNodeIdDelete!]

  """
  Flag indicating whether all other `trip` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: [TripOnTripForTripOrganisationIdFkeyUsingTripPkeyUpdate!]

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: [OrganisationOnTripForTripOrganisationIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input TripOrganisationIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""Input for the nested mutation of `user` in the `TripInput` mutation."""
input TripOwnerIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnTripForTripOwnerIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: TripOnTripForTripOwnerIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `trip` in the `UserInput` mutation."""
input TripOwnerIdFkeyInverseInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: [TripTripPkeyConnect!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: [TripNodeIdConnect!]

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: [TripOwnerIdFkeyTripCreateInput!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: [TripTripPkeyDelete!]

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: [TripNodeIdDelete!]

  """
  Flag indicating whether all other `trip` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: [TripOnTripForTripOwnerIdFkeyUsingTripPkeyUpdate!]

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: [UserOnTripForTripOwnerIdFkeyNodeIdUpdate!]
}

"""The `trip` to be created by this mutation."""
input TripOwnerIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""Represents an update to a `Trip`. Fields that are set will be updated."""
input TripPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

enum TripPermission {
  READ
  WRITE
}

type TripRegion implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads a single `Region` that is related to this `TripRegion`."""
  region: Region
  regionId: UUID!

  """Reads a single `Trip` that is related to this `TripRegion`."""
  trip: Trip
  tripId: UUID!
}

"""
A condition to be used against `TripRegion` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input TripRegionCondition {
  """Checks for equality with the object’s `regionId` field."""
  regionId: UUID

  """Checks for equality with the object’s `tripId` field."""
  tripId: UUID
}

"""
A filter to be used against `TripRegion` object types. All fields are combined with a logical ‘and.’
"""
input TripRegionFilter {
  """Checks for all expressions in this list."""
  and: [TripRegionFilter!]

  """Negates the expression."""
  not: TripRegionFilter

  """Checks for any expressions in this list."""
  or: [TripRegionFilter!]

  """Filter by the object’s `region` relation."""
  region: RegionFilter

  """Filter by the object’s `regionId` field."""
  regionId: UUIDFilter

  """Filter by the object’s `trip` relation."""
  trip: TripFilter

  """Filter by the object’s `tripId` field."""
  tripId: UUIDFilter
}

"""An input for mutations affecting `TripRegion`"""
input TripRegionInput {
  region: TripRegionRegionIdFkeyInput
  regionId: UUID
  trip: TripRegionTripIdFkeyInput
  tripId: UUID
}

"""The globally unique `ID` look up for the row to connect."""
input TripRegionNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `tripRegion` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to delete."""
input TripRegionNodeIdDelete {
  """
  The globally unique `ID` which identifies a single `tripRegion` to be deleted.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input TripRegionOnTripRegionForTripRegionRegionIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `region` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `region` being updated.
  """
  patch: RegionPatch!
}

"""The fields on `tripRegion` to look up the row to update."""
input TripRegionOnTripRegionForTripRegionRegionIdFkeyUsingTripRegionPkeyUpdate {
  """
  An object where the defined keys will be set on the `tripRegion` being updated.
  """
  patch: updateTripRegionOnTripRegionForTripRegionRegionIdFkeyPatch!
  regionId: UUID!
  tripId: UUID!
}

"""The globally unique `ID` look up for the row to update."""
input TripRegionOnTripRegionForTripRegionTripIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `tripRegion` to look up the row to update."""
input TripRegionOnTripRegionForTripRegionTripIdFkeyUsingTripRegionPkeyUpdate {
  """
  An object where the defined keys will be set on the `tripRegion` being updated.
  """
  patch: updateTripRegionOnTripRegionForTripRegionTripIdFkeyPatch!
  regionId: UUID!
  tripId: UUID!
}

"""
Represents an update to a `TripRegion`. Fields that are set will be updated.
"""
input TripRegionPatch {
  region: TripRegionRegionIdFkeyInput
  regionId: UUID
  trip: TripRegionTripIdFkeyInput
  tripId: UUID
}

"""
Input for the nested mutation of `region` in the `TripRegionInput` mutation.
"""
input TripRegionRegionIdFkeyInput {
  """The primary key(s) for `region` for the far side of the relationship."""
  connectById: RegionRegionPkeyConnect

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByName: RegionRegionNameKeyConnect

  """The primary key(s) for `region` for the far side of the relationship."""
  connectByNodeId: RegionNodeIdConnect

  """The primary key(s) for `region` for the far side of the relationship."""
  connectBySlug: RegionRegionSlugKeyConnect

  """
  A `RegionInput` object that will be created and connected to this object.
  """
  create: TripRegionRegionIdFkeyRegionCreateInput

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteById: RegionRegionPkeyDelete

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByName: RegionRegionNameKeyDelete

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteByNodeId: RegionNodeIdDelete

  """The primary key(s) for `region` for the far side of the relationship."""
  deleteBySlug: RegionRegionSlugKeyDelete

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateById: RegionOnTripRegionForTripRegionRegionIdFkeyUsingRegionPkeyUpdate

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByName: RegionOnTripRegionForTripRegionRegionIdFkeyUsingRegionNameKeyUpdate

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateByNodeId: TripRegionOnTripRegionForTripRegionRegionIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `region` for the far side of the relationship.
  """
  updateBySlug: RegionOnTripRegionForTripRegionRegionIdFkeyUsingRegionSlugKeyUpdate
}

"""
Input for the nested mutation of `tripRegion` in the `RegionInput` mutation.
"""
input TripRegionRegionIdFkeyInverseInput {
  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  connectByNodeId: [TripRegionNodeIdConnect!]

  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  connectByTripIdAndRegionId: [TripRegionTripRegionPkeyConnect!]

  """
  A `TripRegionInput` object that will be created and connected to this object.
  """
  create: [TripRegionRegionIdFkeyTripRegionCreateInput!]

  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  deleteByNodeId: [TripRegionNodeIdDelete!]

  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  deleteByTripIdAndRegionId: [TripRegionTripRegionPkeyDelete!]

  """
  Flag indicating whether all other `tripRegion` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tripRegion` for the far side of the relationship.
  """
  updateByNodeId: [RegionOnTripRegionForTripRegionRegionIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tripRegion` for the far side of the relationship.
  """
  updateByTripIdAndRegionId: [TripRegionOnTripRegionForTripRegionRegionIdFkeyUsingTripRegionPkeyUpdate!]
}

"""The `region` to be created by this mutation."""
input TripRegionRegionIdFkeyRegionCreateInput {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""The `tripRegion` to be created by this mutation."""
input TripRegionRegionIdFkeyTripRegionCreateInput {
  region: TripRegionRegionIdFkeyInput
  regionId: UUID
  trip: TripRegionTripIdFkeyInput
  tripId: UUID
}

"""
Input for the nested mutation of `trip` in the `TripRegionInput` mutation.
"""
input TripRegionTripIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: TripRegionTripIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnTripRegionForTripRegionTripIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: TripRegionOnTripRegionForTripRegionTripIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `tripRegion` in the `TripInput` mutation.
"""
input TripRegionTripIdFkeyInverseInput {
  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  connectByNodeId: [TripRegionNodeIdConnect!]

  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  connectByTripIdAndRegionId: [TripRegionTripRegionPkeyConnect!]

  """
  A `TripRegionInput` object that will be created and connected to this object.
  """
  create: [TripRegionTripIdFkeyTripRegionCreateInput!]

  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  deleteByNodeId: [TripRegionNodeIdDelete!]

  """
  The primary key(s) for `tripRegion` for the far side of the relationship.
  """
  deleteByTripIdAndRegionId: [TripRegionTripRegionPkeyDelete!]

  """
  Flag indicating whether all other `tripRegion` records that match this relationship should be removed.
  """
  deleteOthers: Boolean

  """
  The primary key(s) and patch data for `tripRegion` for the far side of the relationship.
  """
  updateByNodeId: [TripOnTripRegionForTripRegionTripIdFkeyNodeIdUpdate!]

  """
  The primary key(s) and patch data for `tripRegion` for the far side of the relationship.
  """
  updateByTripIdAndRegionId: [TripRegionOnTripRegionForTripRegionTripIdFkeyUsingTripRegionPkeyUpdate!]
}

"""The `trip` to be created by this mutation."""
input TripRegionTripIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""The `tripRegion` to be created by this mutation."""
input TripRegionTripIdFkeyTripRegionCreateInput {
  region: TripRegionRegionIdFkeyInput
  regionId: UUID
  trip: TripRegionTripIdFkeyInput
  tripId: UUID
}

"""The fields on `tripRegion` to look up the row to connect."""
input TripRegionTripRegionPkeyConnect {
  regionId: UUID!
  tripId: UUID!
}

"""The fields on `tripRegion` to look up the row to delete."""
input TripRegionTripRegionPkeyDelete {
  regionId: UUID!
  tripId: UUID!
}

"""A connection to a list of `TripRegion` values."""
type TripRegionsConnection {
  """
  A list of edges which contains the `TripRegion` and cursor to aid in pagination.
  """
  edges: [TripRegionsEdge!]!

  """A list of `TripRegion` objects."""
  nodes: [TripRegion!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TripRegion` you could get from the connection."""
  totalCount: Int!
}

"""A `TripRegion` edge in the connection."""
type TripRegionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TripRegion` at the end of the edge."""
  node: TripRegion!
}

"""Methods to use when ordering `TripRegion`."""
enum TripRegionsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  REGION_ID_ASC
  REGION_ID_DESC
  TRIP_ID_ASC
  TRIP_ID_DESC
}

"""Input for the nested mutation of `trip` in the `TripInput` mutation."""
input TripSourceIdFkeyInput {
  """The primary key(s) for `trip` for the far side of the relationship."""
  connectById: TripTripPkeyConnect

  """The primary key(s) for `trip` for the far side of the relationship."""
  connectByNodeId: TripNodeIdConnect

  """
  A `TripInput` object that will be created and connected to this object.
  """
  create: TripSourceIdFkeyTripCreateInput

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteById: TripTripPkeyDelete

  """The primary key(s) for `trip` for the far side of the relationship."""
  deleteByNodeId: TripNodeIdDelete

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateById: TripOnTripForTripSourceIdFkeyUsingTripPkeyUpdate

  """
  The primary key(s) and patch data for `trip` for the far side of the relationship.
  """
  updateByNodeId: TripOnTripForTripSourceIdFkeyNodeIdUpdate
}

"""The `trip` to be created by this mutation."""
input TripSourceIdFkeyTripCreateInput {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int!
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String!
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

enum TripStatus {
  APPROVED
  DECLINED
  DRAFT
  SENT
}

"""
A filter to be used against TripStatus fields. All fields are combined with a logical ‘and.’
"""
input TripStatusFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: TripStatus

  """Equal to the specified value."""
  equalTo: TripStatus

  """Greater than the specified value."""
  greaterThan: TripStatus

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: TripStatus

  """Included in the specified list."""
  in: [TripStatus!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: TripStatus

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: TripStatus

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: TripStatus

  """Not equal to the specified value."""
  notEqualTo: TripStatus

  """Not included in the specified list."""
  notIn: [TripStatus!]
}

type TripTimeBetweenCreateAndStart {
  count: BigInt
  per30: Int
}

"""
A condition to be used against `TripTimeBetweenCreateAndStart` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input TripTimeBetweenCreateAndStartCondition {
  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `per30` field."""
  per30: Int
}

"""
A filter to be used against `TripTimeBetweenCreateAndStart` object types. All fields are combined with a logical ‘and.’
"""
input TripTimeBetweenCreateAndStartFilter {
  """Checks for all expressions in this list."""
  and: [TripTimeBetweenCreateAndStartFilter!]

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Negates the expression."""
  not: TripTimeBetweenCreateAndStartFilter

  """Checks for any expressions in this list."""
  or: [TripTimeBetweenCreateAndStartFilter!]

  """Filter by the object’s `per30` field."""
  per30: IntFilter
}

"""A connection to a list of `TripTimeBetweenCreateAndStart` values."""
type TripTimeBetweenCreateAndStartsConnection {
  """
  A list of edges which contains the `TripTimeBetweenCreateAndStart` and cursor to aid in pagination.
  """
  edges: [TripTimeBetweenCreateAndStartsEdge!]!

  """A list of `TripTimeBetweenCreateAndStart` objects."""
  nodes: [TripTimeBetweenCreateAndStart!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `TripTimeBetweenCreateAndStart` you could get from the connection.
  """
  totalCount: Int!
}

"""A `TripTimeBetweenCreateAndStart` edge in the connection."""
type TripTimeBetweenCreateAndStartsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TripTimeBetweenCreateAndStart` at the end of the edge."""
  node: TripTimeBetweenCreateAndStart!
}

"""Methods to use when ordering `TripTimeBetweenCreateAndStart`."""
enum TripTimeBetweenCreateAndStartsOrderBy {
  COUNT_ASC
  COUNT_DESC
  NATURAL
  PER30_ASC
  PER30_DESC
}

"""
A filter to be used against many `Attachment` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyAttachmentFilter {
  """
  Every related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AttachmentFilter

  """
  No related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AttachmentFilter

  """
  Some related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AttachmentFilter
}

"""
A filter to be used against many `Card` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyCardFilter {
  """
  Every related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CardFilter

  """
  No related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CardFilter

  """
  Some related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CardFilter
}

"""
A filter to be used against many `Collaborator` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyCollaboratorFilter {
  """
  Every related `Collaborator` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CollaboratorFilter

  """
  No related `Collaborator` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CollaboratorFilter

  """
  Some related `Collaborator` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CollaboratorFilter
}

"""
A filter to be used against many `InviteV2` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyInviteV2Filter {
  """
  Every related `InviteV2` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: InviteV2Filter

  """
  No related `InviteV2` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: InviteV2Filter

  """
  Some related `InviteV2` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: InviteV2Filter
}

"""
A filter to be used against many `TagTrip` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyTagTripFilter {
  """
  Every related `TagTrip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TagTripFilter

  """
  No related `TagTrip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TagTripFilter

  """
  Some related `TagTrip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TagTripFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskFilter
}

"""
A filter to be used against many `TripAssetImage` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyTripAssetImageFilter {
  """
  Every related `TripAssetImage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripAssetImageFilter

  """
  No related `TripAssetImage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripAssetImageFilter

  """
  Some related `TripAssetImage` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripAssetImageFilter
}

"""
A filter to be used against many `TripCountry` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyTripCountryFilter {
  """
  Every related `TripCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripCountryFilter

  """
  No related `TripCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripCountryFilter

  """
  Some related `TripCountry` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripCountryFilter
}

"""
A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyTripFilter {
  """
  Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripFilter

  """
  No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripFilter

  """
  Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripFilter
}

"""
A filter to be used against many `TripRegion` object types. All fields are combined with a logical ‘and.’
"""
input TripToManyTripRegionFilter {
  """
  Every related `TripRegion` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripRegionFilter

  """
  No related `TripRegion` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripRegionFilter

  """
  Some related `TripRegion` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripRegionFilter
}

"""The fields on `trip` to look up the row to connect."""
input TripTripPkeyConnect {
  id: UUID!
}

"""The fields on `trip` to look up the row to delete."""
input TripTripPkeyDelete {
  id: UUID!
}

enum TripType {
  CITY_BREAK
  INTERNATIONAL_TRIP
  ROAD_TRIP
  STAYCATION
}

"""
A filter to be used against TripType List fields. All fields are combined with a logical ‘and.’
"""
input TripTypeListFilter {
  """Any array item is equal to the specified value."""
  anyEqualTo: TripType

  """Any array item is greater than the specified value."""
  anyGreaterThan: TripType

  """Any array item is greater than or equal to the specified value."""
  anyGreaterThanOrEqualTo: TripType

  """Any array item is less than the specified value."""
  anyLessThan: TripType

  """Any array item is less than or equal to the specified value."""
  anyLessThanOrEqualTo: TripType

  """Any array item is not equal to the specified value."""
  anyNotEqualTo: TripType

  """Contained by the specified list of values."""
  containedBy: [TripType]

  """Contains the specified list of values."""
  contains: [TripType]

  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: [TripType]

  """Equal to the specified value."""
  equalTo: [TripType]

  """Greater than the specified value."""
  greaterThan: [TripType]

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: [TripType]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: [TripType]

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: [TripType]

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: [TripType]

  """Not equal to the specified value."""
  notEqualTo: [TripType]

  """Overlaps the specified list of values."""
  overlaps: [TripType]
}

type TripsBudgetTypeCount {
  daily: BigInt
  none: BigInt
  trip: BigInt
}

"""A connection to a list of `Trip` values."""
type TripsConnection {
  """
  A list of edges which contains the `Trip` and cursor to aid in pagination.
  """
  edges: [TripsEdge!]!

  """A list of `Trip` objects."""
  nodes: [Trip!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Trip` you could get from the connection."""
  totalCount: Int!
}

"""A `Trip` edge in the connection."""
type TripsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Trip` at the end of the edge."""
  node: Trip!
}

"""Methods to use when ordering `Trip`."""
enum TripsOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  BUDGET_ASC
  BUDGET_DESC
  BUDGET_TYPE_ASC
  BUDGET_TYPE_DESC
  CLASS_ASC
  CLASS_DESC
  CLIENT_ID_ASC
  CLIENT_ID_DESC
  COLLABORATOR_COUNT_ASC
  COLLABORATOR_COUNT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  CURRENCY_ID_ASC
  CURRENCY_ID_DESC
  DAYS_ASC
  DAYS_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  ENABLE_IDEAS_ASC
  ENABLE_IDEAS_DESC
  END_DATE_ASC
  END_DATE_DESC
  HIGHLIGHTS_ASC
  HIGHLIGHTS_DESC
  ID_ASC
  ID_DESC
  IMAGE_ID_ASC
  IMAGE_ID_DESC
  INTRODUCTION_ASC
  INTRODUCTION_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  LEGACY_PAYMENT_EXPIRY_ASC
  LEGACY_PAYMENT_EXPIRY_DESC
  LEGACY_TIER_ASC
  LEGACY_TIER_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  ORGANISATION_ID_ASC
  ORGANISATION_ID_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  SOURCE_ID_ASC
  SOURCE_ID_DESC
  START_DATE_ASC
  START_DATE_DESC
  STATUS_ASC
  STATUS_DESC
  TYPE_ASC
  TYPE_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type TripsOverTime {
  count: BigInt
  date: Datetime
}

"""
A condition to be used against `TripsOverTime` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TripsOverTimeCondition {
  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `date` field."""
  date: Datetime
}

"""
A filter to be used against `TripsOverTime` object types. All fields are combined with a logical ‘and.’
"""
input TripsOverTimeFilter {
  """Checks for all expressions in this list."""
  and: [TripsOverTimeFilter!]

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Negates the expression."""
  not: TripsOverTimeFilter

  """Checks for any expressions in this list."""
  or: [TripsOverTimeFilter!]
}

"""A connection to a list of `TripsOverTime` values."""
type TripsOverTimesConnection {
  """
  A list of edges which contains the `TripsOverTime` and cursor to aid in pagination.
  """
  edges: [TripsOverTimesEdge!]!

  """A list of `TripsOverTime` objects."""
  nodes: [TripsOverTime!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `TripsOverTime` you could get from the connection."""
  totalCount: Int!
}

"""A `TripsOverTime` edge in the connection."""
type TripsOverTimesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `TripsOverTime` at the end of the edge."""
  node: TripsOverTime!
}

"""Methods to use when ordering `TripsOverTime`."""
enum TripsOverTimesOrderBy {
  COUNT_ASC
  COUNT_DESC
  DATE_ASC
  DATE_DESC
  NATURAL
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A filter to be used against UUID fields. All fields are combined with a logical ‘and.’
"""
input UUIDFilter {
  """
  Not equal to the specified value, treating null like an ordinary value.
  """
  distinctFrom: UUID

  """Equal to the specified value."""
  equalTo: UUID

  """Greater than the specified value."""
  greaterThan: UUID

  """Greater than or equal to the specified value."""
  greaterThanOrEqualTo: UUID

  """Included in the specified list."""
  in: [UUID!]

  """
  Is null (if `true` is specified) or is not null (if `false` is specified).
  """
  isNull: Boolean

  """Less than the specified value."""
  lessThan: UUID

  """Less than or equal to the specified value."""
  lessThanOrEqualTo: UUID

  """Equal to the specified value, treating null like an ordinary value."""
  notDistinctFrom: UUID

  """Not equal to the specified value."""
  notEqualTo: UUID

  """Not included in the specified list."""
  notIn: [UUID!]
}

"""All input for the `updateAccountByEmail` mutation."""
input UpdateAccountByEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  email: String!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""All input for the `updateAccountByNodeId` mutation."""
input UpdateAccountByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
}

"""All input for the `updateAccountByStripeCustomerId` mutation."""
input UpdateAccountByStripeCustomerIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
  stripeCustomerId: String!
}

"""All input for the `updateAccount` mutation."""
input UpdateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  patch: AccountPatch!
  userId: UUID!
}

"""The output of our update `Account` mutation."""
type UpdateAccountPayload {
  """The `Account` that was updated by this mutation."""
  account: Account

  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Account`."""
  user: User
}

"""All input for the `updateAssetAttribution` mutation."""
input UpdateAssetAttributionInput {
  attribution: AssetAttributionInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our `updateAssetAttribution` mutation."""
type UpdateAssetAttributionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCardByNodeId` mutation."""
input UpdateCardByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Card` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Card` being updated.
  """
  patch: CardPatch!
}

"""All input for the `updateCardCostByCardId` mutation."""
input UpdateCardCostByCardIdInput {
  cardId: UUID!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CardCost` being updated.
  """
  patch: CardCostPatch!
}

"""All input for the `updateCardCostByNodeId` mutation."""
input UpdateCardCostByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CardCost` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CardCost` being updated.
  """
  patch: CardCostPatch!
}

"""All input for the `updateCardCost` mutation."""
input UpdateCardCostInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `CardCost` being updated.
  """
  patch: CardCostPatch!
}

"""The output of our update `CardCost` mutation."""
type UpdateCardCostPayload {
  """Reads a single `Card` that is related to this `CardCost`."""
  card: Card

  """The `CardCost` that was updated by this mutation."""
  cardCost: CardCost

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `CostTax` that is related to this `CardCost`."""
  costTaxByCostTax: CostTax

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCard` mutation."""
input UpdateCardInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Card` being updated.
  """
  patch: CardPatch!
}

"""The output of our update `Card` mutation."""
type UpdateCardPayload {
  """The `Card` that was updated by this mutation."""
  card: Card

  """An edge for our `Card`. May be used by Relay 1."""
  cardEdge(
    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Card`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Card`."""
  image: Asset

  """Reads a single `User` that is related to this `Card`."""
  owner: User

  """Reads a single `Card` that is related to this `Card`."""
  parent: Card

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Card`."""
  trip: Trip
}

"""All input for the `updateClientByNodeId` mutation."""
input UpdateClientByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Client` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Client` being updated.
  """
  patch: ClientPatch!
}

"""All input for the `updateClient` mutation."""
input UpdateClientInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Client` being updated.
  """
  patch: ClientPatch!
}

"""All input for the `updateClientOrganisationByNodeId` mutation."""
input UpdateClientOrganisationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ClientOrganisation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ClientOrganisation` being updated.
  """
  patch: ClientOrganisationPatch!
}

"""All input for the `updateClientOrganisationContactByNodeId` mutation."""
input UpdateClientOrganisationContactByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ClientOrganisationContact` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ClientOrganisationContact` being updated.
  """
  patch: ClientOrganisationContactPatch!
}

"""All input for the `updateClientOrganisationContact` mutation."""
input UpdateClientOrganisationContactInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `ClientOrganisationContact` being updated.
  """
  patch: ClientOrganisationContactPatch!
  personId: UUID!
}

"""The output of our update `ClientOrganisationContact` mutation."""
type UpdateClientOrganisationContactPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientOrganisationContact` that was updated by this mutation."""
  clientOrganisationContact: ClientOrganisationContact

  """An edge for our `ClientOrganisationContact`. May be used by Relay 1."""
  clientOrganisationContactEdge(
    """The method to use when ordering `ClientOrganisationContact`."""
    orderBy: [ClientOrganisationContactsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationContactsEdge

  """
  Reads a single `ClientOrganisation` that is related to this `ClientOrganisationContact`.
  """
  organisation: ClientOrganisation

  """
  Reads a single `ClientPerson` that is related to this `ClientOrganisationContact`.
  """
  person: ClientPerson

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateClientOrganisation` mutation."""
input UpdateClientOrganisationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `ClientOrganisation` being updated.
  """
  patch: ClientOrganisationPatch!
}

"""The output of our update `ClientOrganisation` mutation."""
type UpdateClientOrganisationPayload {
  """Reads a single `Client` that is related to this `ClientOrganisation`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientOrganisation` that was updated by this mutation."""
  clientOrganisation: ClientOrganisation

  """An edge for our `ClientOrganisation`. May be used by Relay 1."""
  clientOrganisationEdge(
    """The method to use when ordering `ClientOrganisation`."""
    orderBy: [ClientOrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientOrganisationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""The output of our update `Client` mutation."""
type UpdateClientPayload {
  """Reads a single `User` that is related to this `Client`."""
  author: User

  """The `Client` that was updated by this mutation."""
  client: Client

  """An edge for our `Client`. May be used by Relay 1."""
  clientEdge(
    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Organisation` that is related to this `Client`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateClientPersonByNodeId` mutation."""
input UpdateClientPersonByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ClientPerson` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ClientPerson` being updated.
  """
  patch: ClientPersonPatch!
}

"""All input for the `updateClientPerson` mutation."""
input UpdateClientPersonInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `ClientPerson` being updated.
  """
  patch: ClientPersonPatch!
}

"""The output of our update `ClientPerson` mutation."""
type UpdateClientPersonPayload {
  """Reads a single `Client` that is related to this `ClientPerson`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ClientPerson` that was updated by this mutation."""
  clientPerson: ClientPerson

  """An edge for our `ClientPerson`. May be used by Relay 1."""
  clientPersonEdge(
    """The method to use when ordering `ClientPerson`."""
    orderBy: [ClientPeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientPeopleEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ClientPerson`."""
  user: User
}

"""All input for the `updateContinentByName` mutation."""
input UpdateContinentByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Continent` being updated.
  """
  patch: ContinentPatch!
}

"""All input for the `updateContinentByNodeId` mutation."""
input UpdateContinentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Continent` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Continent` being updated.
  """
  patch: ContinentPatch!
}

"""All input for the `updateContinent` mutation."""
input UpdateContinentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Continent` being updated.
  """
  patch: ContinentPatch!
}

"""The output of our update `Continent` mutation."""
type UpdateContinentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Continent` that was updated by this mutation."""
  continent: Continent

  """An edge for our `Continent`. May be used by Relay 1."""
  continentEdge(
    """The method to use when ordering `Continent`."""
    orderBy: [ContinentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContinentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCostItemByNodeId` mutation."""
input UpdateCostItemByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CostItem` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CostItem` being updated.
  """
  patch: CostItemPatch!
}

"""All input for the `updateCostItem` mutation."""
input UpdateCostItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `CostItem` being updated.
  """
  patch: CostItemPatch!
}

"""The output of our update `CostItem` mutation."""
type UpdateCostItemPayload {
  """Reads a single `Card` that is related to this `CostItem`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `CostItem`."""
  costCurrency: Currency

  """The `CostItem` that was updated by this mutation."""
  costItem: CostItem

  """An edge for our `CostItem`. May be used by Relay 1."""
  costItemEdge(
    """The method to use when ordering `CostItem`."""
    orderBy: [CostItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostItemsEdge

  """Reads a single `CostTax` that is related to this `CostItem`."""
  costTax: CostTax

  """Reads a single `Organisation` that is related to this `CostItem`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCostTaxByNodeId` mutation."""
input UpdateCostTaxByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CostTax` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CostTax` being updated.
  """
  patch: CostTaxPatch!
}

"""All input for the `updateCostTax` mutation."""
input UpdateCostTaxInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `CostTax` being updated.
  """
  patch: CostTaxPatch!
}

"""The output of our update `CostTax` mutation."""
type UpdateCostTaxPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CostTax` that was updated by this mutation."""
  costTax: CostTax

  """An edge for our `CostTax`. May be used by Relay 1."""
  costTaxEdge(
    """The method to use when ordering `CostTax`."""
    orderBy: [CostTaxesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CostTaxesEdge

  """Reads a single `Organisation` that is related to this `CostTax`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCountryByName` mutation."""
input UpdateCountryByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
}

"""All input for the `updateCountryByNodeId` mutation."""
input UpdateCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Country` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
}

"""All input for the `updateCountryBySlug` mutation."""
input UpdateCountryBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
  slug: String!
}

"""All input for the `updateCountry` mutation."""
input UpdateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
}

"""The output of our update `Country` mutation."""
type UpdateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Continent` that is related to this `Country`."""
  continent: Continent

  """The `Country` that was updated by this mutation."""
  country: Country

  """An edge for our `Country`. May be used by Relay 1."""
  countryEdge(
    """The method to use when ordering `Country`."""
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge

  """Reads a single `Asset` that is related to this `Country`."""
  image: Asset

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCurrencyByIso` mutation."""
input UpdateCurrencyByIsoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  iso: String!

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
}

"""All input for the `updateCurrencyByName` mutation."""
input UpdateCurrencyByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
}

"""All input for the `updateCurrencyByNodeId` mutation."""
input UpdateCurrencyByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Currency` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
}

"""All input for the `updateCurrencyCountryByNodeId` mutation."""
input UpdateCurrencyCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CurrencyCountry` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CurrencyCountry` being updated.
  """
  patch: CurrencyCountryPatch!
}

"""All input for the `updateCurrencyCountry` mutation."""
input UpdateCurrencyCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  currencyId: UUID!

  """
  An object where the defined keys will be set on the `CurrencyCountry` being updated.
  """
  patch: CurrencyCountryPatch!
}

"""The output of our update `CurrencyCountry` mutation."""
type UpdateCurrencyCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `CurrencyCountry`."""
  country: Country

  """Reads a single `Currency` that is related to this `CurrencyCountry`."""
  currency: Currency

  """The `CurrencyCountry` that was updated by this mutation."""
  currencyCountry: CurrencyCountry

  """An edge for our `CurrencyCountry`. May be used by Relay 1."""
  currencyCountryEdge(
    """The method to use when ordering `CurrencyCountry`."""
    orderBy: [CurrencyCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrencyCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateCurrency` mutation."""
input UpdateCurrencyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Currency` being updated.
  """
  patch: CurrencyPatch!
}

"""The output of our update `Currency` mutation."""
type UpdateCurrencyPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Currency` that was updated by this mutation."""
  currency: Currency

  """An edge for our `Currency`. May be used by Relay 1."""
  currencyEdge(
    """The method to use when ordering `Currency`."""
    orderBy: [CurrenciesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CurrenciesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateGratiByNodeId` mutation."""
input UpdateGratiByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Grati` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Grati` being updated.
  """
  patch: GratiPatch!
}

"""All input for the `updateGrati` mutation."""
input UpdateGratiInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Grati` being updated.
  """
  patch: GratiPatch!
}

"""The output of our update `Grati` mutation."""
type UpdateGratiPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Grati` that was updated by this mutation."""
  grati: Grati

  """An edge for our `Grati`. May be used by Relay 1."""
  gratiEdge(
    """The method to use when ordering `Grati`."""
    orderBy: [GratisOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisEdge @deprecated(reason: "Use Promo Codes")

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateGratisUsedByNodeId` mutation."""
input UpdateGratisUsedByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `GratisUsed` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `GratisUsed` being updated.
  """
  patch: GratisUsedPatch!
}

"""All input for the `updateGratisUsed` mutation."""
input UpdateGratisUsedInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  gratisId: UUID!

  """
  An object where the defined keys will be set on the `GratisUsed` being updated.
  """
  patch: GratisUsedPatch!
  userId: UUID!
}

"""The output of our update `GratisUsed` mutation."""
type UpdateGratisUsedPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Grati` that is related to this `GratisUsed`."""
  gratis: Grati

  """The `GratisUsed` that was updated by this mutation."""
  gratisUsed: GratisUsed

  """An edge for our `GratisUsed`. May be used by Relay 1."""
  gratisUsedEdge(
    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisUsedsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `GratisUsed`."""
  user: User
}

"""All input for the `updateLanguageByName` mutation."""
input UpdateLanguageByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Language` being updated.
  """
  patch: LanguagePatch!
}

"""All input for the `updateLanguageByNodeId` mutation."""
input UpdateLanguageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Language` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Language` being updated.
  """
  patch: LanguagePatch!
}

"""All input for the `updateLanguageCountryByNodeId` mutation."""
input UpdateLanguageCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `LanguageCountry` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `LanguageCountry` being updated.
  """
  patch: LanguageCountryPatch!
}

"""All input for the `updateLanguageCountry` mutation."""
input UpdateLanguageCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  languageId: UUID!

  """
  An object where the defined keys will be set on the `LanguageCountry` being updated.
  """
  patch: LanguageCountryPatch!
}

"""The output of our update `LanguageCountry` mutation."""
type UpdateLanguageCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `LanguageCountry`."""
  country: Country

  """Reads a single `Language` that is related to this `LanguageCountry`."""
  language: Language

  """The `LanguageCountry` that was updated by this mutation."""
  languageCountry: LanguageCountry

  """An edge for our `LanguageCountry`. May be used by Relay 1."""
  languageCountryEdge(
    """The method to use when ordering `LanguageCountry`."""
    orderBy: [LanguageCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguageCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateLanguage` mutation."""
input UpdateLanguageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Language` being updated.
  """
  patch: LanguagePatch!
}

"""The output of our update `Language` mutation."""
type UpdateLanguagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Language` that was updated by this mutation."""
  language: Language

  """An edge for our `Language`. May be used by Relay 1."""
  languageEdge(
    """The method to use when ordering `Language`."""
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateMetaByNodeId` mutation."""
input UpdateMetaByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Meta` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Meta` being updated.
  """
  patch: MetaPatch!
}

"""All input for the `updateMeta` mutation."""
input UpdateMetaInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Meta` being updated.
  """
  patch: MetaPatch!
}

"""The output of our update `Meta` mutation."""
type UpdateMetaPayload {
  """Reads a single `User` that is related to this `Meta`."""
  author: User

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `ClientOrganisation` that is related to this `Meta`."""
  clientOrganisation: ClientOrganisation

  """Reads a single `ClientPerson` that is related to this `Meta`."""
  clientPerson: ClientPerson

  """The `Meta` that was updated by this mutation."""
  meta: Meta

  """An edge for our `Meta`. May be used by Relay 1."""
  metaEdge(
    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasEdge

  """Reads a single `Organisation` that is related to this `Meta`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Supplier` that is related to this `Meta`."""
  supplier: Supplier
}

"""All input for the `updateOrganisationByNodeId` mutation."""
input UpdateOrganisationByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Organisation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""All input for the `updateOrganisation` mutation."""
input UpdateOrganisationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Organisation` being updated.
  """
  patch: OrganisationPatch!
}

"""The output of our update `Organisation` mutation."""
type UpdateOrganisationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `CostTax` that is related to this `Organisation`."""
  costTax: CostTax

  """Reads a single `Country` that is related to this `Organisation`."""
  country: Country

  """Reads a single `Currency` that is related to this `Organisation`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Organisation`."""
  logo: Asset

  """The `Organisation` that was updated by this mutation."""
  organisation: Organisation

  """An edge for our `Organisation`. May be used by Relay 1."""
  organisationEdge(
    """The method to use when ordering `Organisation`."""
    orderBy: [OrganisationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateOrganisationTierByName` mutation."""
input UpdateOrganisationTierByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `OrganisationTier` being updated.
  """
  patch: OrganisationTierPatch!
}

"""All input for the `updateOrganisationTierByNodeId` mutation."""
input UpdateOrganisationTierByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OrganisationTier` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `OrganisationTier` being updated.
  """
  patch: OrganisationTierPatch!
}

"""All input for the `updateOrganisationTier` mutation."""
input UpdateOrganisationTierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `OrganisationTier` being updated.
  """
  patch: OrganisationTierPatch!
}

"""The output of our update `OrganisationTier` mutation."""
type UpdateOrganisationTierPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `OrganisationTier` that was updated by this mutation."""
  organisationTier: OrganisationTier

  """An edge for our `OrganisationTier`. May be used by Relay 1."""
  organisationTierEdge(
    """The method to use when ordering `OrganisationTier`."""
    orderBy: [OrganisationTiersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationTiersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateOutletByName` mutation."""
input UpdateOutletByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Outlet` being updated.
  """
  patch: OutletPatch!
}

"""All input for the `updateOutletByNodeId` mutation."""
input UpdateOutletByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Outlet` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Outlet` being updated.
  """
  patch: OutletPatch!
}

"""All input for the `updateOutletCountryByNodeId` mutation."""
input UpdateOutletCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `OutletCountry` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `OutletCountry` being updated.
  """
  patch: OutletCountryPatch!
}

"""All input for the `updateOutletCountry` mutation."""
input UpdateOutletCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!
  outletId: UUID!

  """
  An object where the defined keys will be set on the `OutletCountry` being updated.
  """
  patch: OutletCountryPatch!
}

"""The output of our update `OutletCountry` mutation."""
type UpdateOutletCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `OutletCountry`."""
  country: Country

  """Reads a single `Outlet` that is related to this `OutletCountry`."""
  outlet: Outlet

  """The `OutletCountry` that was updated by this mutation."""
  outletCountry: OutletCountry

  """An edge for our `OutletCountry`. May be used by Relay 1."""
  outletCountryEdge(
    """The method to use when ordering `OutletCountry`."""
    orderBy: [OutletCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletCountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateOutlet` mutation."""
input UpdateOutletInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Outlet` being updated.
  """
  patch: OutletPatch!
}

"""The output of our update `Outlet` mutation."""
type UpdateOutletPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Outlet` that was updated by this mutation."""
  outlet: Outlet

  """An edge for our `Outlet`. May be used by Relay 1."""
  outletEdge(
    """The method to use when ordering `Outlet`."""
    orderBy: [OutletsOrderBy!] = [PRIMARY_KEY_ASC]
  ): OutletsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updatePartnerPageByNodeId` mutation."""
input UpdatePartnerPageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PartnerPage` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PartnerPage` being updated.
  """
  patch: PartnerPagePatch!
}

"""All input for the `updatePartnerPageBySlug` mutation."""
input UpdatePartnerPageBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PartnerPage` being updated.
  """
  patch: PartnerPagePatch!
  slug: String!
}

"""All input for the `updatePartnerPage` mutation."""
input UpdatePartnerPageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `PartnerPage` being updated.
  """
  patch: PartnerPagePatch!
}

"""The output of our update `PartnerPage` mutation."""
type UpdatePartnerPagePayload {
  """Reads a single `Asset` that is related to this `PartnerPage`."""
  background: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Grati` that is related to this `PartnerPage`."""
  gratis: Grati

  """Reads a single `Asset` that is related to this `PartnerPage`."""
  logo: Asset

  """The `PartnerPage` that was updated by this mutation."""
  partnerPage: PartnerPage

  """An edge for our `PartnerPage`. May be used by Relay 1."""
  partnerPageEdge(
    """The method to use when ordering `PartnerPage`."""
    orderBy: [PartnerPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PartnerPagesEdge

  """Reads a single `PromoCode` that is related to this `PartnerPage`."""
  promoCode: PromoCode

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updatePlaceByNodeId` mutation."""
input UpdatePlaceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Place` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Place` being updated.
  """
  patch: PlacePatch!
}

"""All input for the `updatePlace` mutation."""
input UpdatePlaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: String!

  """
  An object where the defined keys will be set on the `Place` being updated.
  """
  patch: PlacePatch!
}

"""The output of our update `Place` mutation."""
type UpdatePlacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Place` that was updated by this mutation."""
  place: Place

  """An edge for our `Place`. May be used by Relay 1."""
  placeEdge(
    """The method to use when ordering `Place`."""
    orderBy: [PlacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlacesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updatePromoCodeAffiliateByNodeId` mutation."""
input UpdatePromoCodeAffiliateByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PromoCodeAffiliate` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PromoCodeAffiliate` being updated.
  """
  patch: PromoCodeAffiliatePatch!
}

"""All input for the `updatePromoCodeAffiliate` mutation."""
input UpdatePromoCodeAffiliateInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PromoCodeAffiliate` being updated.
  """
  patch: PromoCodeAffiliatePatch!
  promoCodeId: UUID!
  userId: UUID!
}

"""The output of our update `PromoCodeAffiliate` mutation."""
type UpdatePromoCodeAffiliatePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `PromoCode` that is related to this `PromoCodeAffiliate`.
  """
  promoCode: PromoCode

  """The `PromoCodeAffiliate` that was updated by this mutation."""
  promoCodeAffiliate: PromoCodeAffiliate

  """An edge for our `PromoCodeAffiliate`. May be used by Relay 1."""
  promoCodeAffiliateEdge(
    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeAffiliatesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `PromoCodeAffiliate`."""
  user: User
}

"""All input for the `updatePromoCodeByCode` mutation."""
input UpdatePromoCodeByCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!

  """
  An object where the defined keys will be set on the `PromoCode` being updated.
  """
  patch: PromoCodePatch!
}

"""All input for the `updatePromoCodeByNodeId` mutation."""
input UpdatePromoCodeByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PromoCode` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PromoCode` being updated.
  """
  patch: PromoCodePatch!
}

"""All input for the `updatePromoCode` mutation."""
input UpdatePromoCodeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `PromoCode` being updated.
  """
  patch: PromoCodePatch!
}

"""The output of our update `PromoCode` mutation."""
type UpdatePromoCodePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PromoCode` that was updated by this mutation."""
  promoCode: PromoCode

  """An edge for our `PromoCode`. May be used by Relay 1."""
  promoCodeEdge(
    """The method to use when ordering `PromoCode`."""
    orderBy: [PromoCodesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""All input for the `updateRegionByName` mutation."""
input UpdateRegionByNameInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!

  """
  An object where the defined keys will be set on the `Region` being updated.
  """
  patch: RegionPatch!
}

"""All input for the `updateRegionByNodeId` mutation."""
input UpdateRegionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Region` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Region` being updated.
  """
  patch: RegionPatch!
}

"""All input for the `updateRegionBySlug` mutation."""
input UpdateRegionBySlugInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Region` being updated.
  """
  patch: RegionPatch!
  slug: String!
}

"""All input for the `updateRegion` mutation."""
input UpdateRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Region` being updated.
  """
  patch: RegionPatch!
}

"""The output of our update `Region` mutation."""
type UpdateRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `Region`."""
  country: Country

  """Reads a single `Asset` that is related to this `Region`."""
  image: Asset

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Region` that was updated by this mutation."""
  region: Region

  """An edge for our `Region`. May be used by Relay 1."""
  regionEdge(
    """The method to use when ordering `Region`."""
    orderBy: [RegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RegionsEdge
}

"""All input for the `updateSettingByNodeId` mutation."""
input UpdateSettingByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Setting` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
}

"""All input for the `updateSetting` mutation."""
input UpdateSettingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Setting` being updated.
  """
  patch: SettingPatch!
  userId: UUID!
}

"""The output of our update `Setting` mutation."""
type UpdateSettingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Setting` that was updated by this mutation."""
  setting: Setting

  """An edge for our `Setting`. May be used by Relay 1."""
  settingEdge(
    """The method to use when ordering `Setting`."""
    orderBy: [SettingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SettingsEdge @deprecated(reason: "Use Trip.appearance")

  """Reads a single `User` that is related to this `Setting`."""
  user: User
}

"""All input for the `updateSubscriptionLogByNodeId` mutation."""
input UpdateSubscriptionLogByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SubscriptionLog` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SubscriptionLog` being updated.
  """
  patch: SubscriptionLogPatch!
}

"""All input for the `updateSubscriptionLog` mutation."""
input UpdateSubscriptionLogInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `SubscriptionLog` being updated.
  """
  patch: SubscriptionLogPatch!
}

"""The output of our update `SubscriptionLog` mutation."""
type UpdateSubscriptionLogPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `SubscriptionLog` that was updated by this mutation."""
  subscriptionLog: SubscriptionLog

  """An edge for our `SubscriptionLog`. May be used by Relay 1."""
  subscriptionLogEdge(
    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionLogsEdge

  """Reads a single `User` that is related to this `SubscriptionLog`."""
  user: User
}

"""All input for the `updateSupplierByNodeId` mutation."""
input UpdateSupplierByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Supplier` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Supplier` being updated.
  """
  patch: SupplierPatch!
}

"""All input for the `updateSupplierCategoryByNodeId` mutation."""
input UpdateSupplierCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SupplierCategory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SupplierCategory` being updated.
  """
  patch: SupplierCategoryPatch!
}

"""All input for the `updateSupplierCategory` mutation."""
input UpdateSupplierCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `SupplierCategory` being updated.
  """
  patch: SupplierCategoryPatch!
}

"""The output of our update `SupplierCategory` mutation."""
type UpdateSupplierCategoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `SupplierCategory` that was updated by this mutation."""
  supplierCategory: SupplierCategory

  """An edge for our `SupplierCategory`. May be used by Relay 1."""
  supplierCategoryEdge(
    """The method to use when ordering `SupplierCategory`."""
    orderBy: [SupplierCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SupplierCategoriesEdge
}

"""All input for the `updateSupplier` mutation."""
input UpdateSupplierInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The output of our update `Supplier` mutation."""
type UpdateSupplierPayload {
  """Reads a single `User` that is related to this `Supplier`."""
  author: User

  """Reads a single `SupplierCategory` that is related to this `Supplier`."""
  category: SupplierCategory

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Asset` that is related to this `Supplier`."""
  logo: Asset

  """Reads a single `Organisation` that is related to this `Supplier`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Supplier` that was updated by this mutation."""
  supplier: Supplier

  """An edge for our `Supplier`. May be used by Relay 1."""
  supplierEdge(
    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersEdge
}

"""All input for the `updateSupplierTags` mutation."""
input UpdateSupplierTagsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  created: [String]
  removed: [UUID]
  selected: [UUID]
  supplierId: UUID!
}

"""The output of our `updateSupplierTags` mutation."""
type UpdateSupplierTagsPayload {
  """Reads a single `User` that is related to this `Supplier`."""
  author: User

  """Reads a single `SupplierCategory` that is related to this `Supplier`."""
  category: SupplierCategory

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Asset` that is related to this `Supplier`."""
  logo: Asset

  """Reads a single `Organisation` that is related to this `Supplier`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
  supplier: Supplier

  """An edge for our `Supplier`. May be used by Relay 1."""
  supplierEdge(
    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersEdge
}

"""All input for the `updateTagByNameAndTypeAndOrganisationId` mutation."""
input UpdateTagByNameAndTypeAndOrganisationIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  name: String!
  organisationId: UUID!

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!
  type: TagType!
}

"""All input for the `updateTagByNodeId` mutation."""
input UpdateTagByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Tag` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!
}

"""All input for the `updateTag` mutation."""
input UpdateTagInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Tag` being updated.
  """
  patch: TagPatch!
}

"""The output of our update `Tag` mutation."""
type UpdateTagPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Organisation` that is related to this `Tag`."""
  organisation: Organisation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Tag` that was updated by this mutation."""
  tag: Tag

  """An edge for our `Tag`. May be used by Relay 1."""
  tagEdge(
    """The method to use when ordering `Tag`."""
    orderBy: [TagsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagsEdge
}

"""All input for the `updateTagTripByNodeId` mutation."""
input UpdateTagTripByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TagTrip` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TagTrip` being updated.
  """
  patch: TagTripPatch!
}

"""All input for the `updateTagTrip` mutation."""
input UpdateTagTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TagTrip` being updated.
  """
  patch: TagTripPatch!
  tagId: UUID!
  tripId: UUID!
}

"""The output of our update `TagTrip` mutation."""
type UpdateTagTripPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Tag` that is related to this `TagTrip`."""
  tag: Tag

  """The `TagTrip` that was updated by this mutation."""
  tagTrip: TagTrip

  """An edge for our `TagTrip`. May be used by Relay 1."""
  tagTripEdge(
    """The method to use when ordering `TagTrip`."""
    orderBy: [TagTripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TagTripsEdge

  """Reads a single `Trip` that is related to this `TagTrip`."""
  trip: Trip
}

"""All input for the `updateTaskByNodeId` mutation."""
input UpdateTaskByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Task` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Task` being updated.
  """
  patch: TaskPatch!
}

"""All input for the `updateTask` mutation."""
input UpdateTaskInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Task` being updated.
  """
  patch: TaskPatch!
}

"""The output of our update `Task` mutation."""
type UpdateTaskPayload {
  """Reads a single `Card` that is related to this `Task`."""
  card: Card

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `Task` that was updated by this mutation."""
  task: Task

  """An edge for our `Task`. May be used by Relay 1."""
  taskEdge(
    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksEdge

  """Reads a single `Trip` that is related to this `Task`."""
  trip: Trip

  """Reads a single `User` that is related to this `Task`."""
  user: User
}

"""All input for the `updateTripAssetImageByNodeId` mutation."""
input UpdateTripAssetImageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TripAssetImage` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TripAssetImage` being updated.
  """
  patch: TripAssetImagePatch!
}

"""All input for the `updateTripAssetImage` mutation."""
input UpdateTripAssetImageInput {
  assetId: UUID!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TripAssetImage` being updated.
  """
  patch: TripAssetImagePatch!
  tripId: UUID!
}

"""The output of our update `TripAssetImage` mutation."""
type UpdateTripAssetImagePayload {
  """Reads a single `Asset` that is related to this `TripAssetImage`."""
  asset: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `TripAssetImage`."""
  trip: Trip

  """The `TripAssetImage` that was updated by this mutation."""
  tripAssetImage: TripAssetImage

  """An edge for our `TripAssetImage`. May be used by Relay 1."""
  tripAssetImageEdge(
    """The method to use when ordering `TripAssetImage`."""
    orderBy: [TripAssetImagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripAssetImagesEdge
}

"""All input for the `updateTripByNodeId` mutation."""
input UpdateTripByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Trip` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Trip` being updated.
  """
  patch: TripPatch!
}

"""All input for the `updateTripCountryByNodeId` mutation."""
input UpdateTripCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TripCountry` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TripCountry` being updated.
  """
  patch: TripCountryPatch!
}

"""All input for the `updateTripCountry` mutation."""
input UpdateTripCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: UUID!

  """
  An object where the defined keys will be set on the `TripCountry` being updated.
  """
  patch: TripCountryPatch!
  tripId: UUID!
}

"""The output of our update `TripCountry` mutation."""
type UpdateTripCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `TripCountry`."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `TripCountry`."""
  trip: Trip

  """The `TripCountry` that was updated by this mutation."""
  tripCountry: TripCountry

  """An edge for our `TripCountry`. May be used by Relay 1."""
  tripCountryEdge(
    """The method to use when ordering `TripCountry`."""
    orderBy: [TripCountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripCountriesEdge
}

"""All input for the `updateTrip` mutation."""
input UpdateTripInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `Trip` being updated.
  """
  patch: TripPatch!
}

"""The output of our update `Trip` mutation."""
type UpdateTripPayload {
  """Reads a single `Client` that is related to this `Trip`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation

  """Reads a single `User` that is related to this `Trip`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip

  """The `Trip` that was updated by this mutation."""
  trip: Trip

  """An edge for our `Trip`. May be used by Relay 1."""
  tripEdge(
    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsEdge
}

"""All input for the `updateTripRegionByNodeId` mutation."""
input UpdateTripRegionByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `TripRegion` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `TripRegion` being updated.
  """
  patch: TripRegionPatch!
}

"""All input for the `updateTripRegion` mutation."""
input UpdateTripRegionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `TripRegion` being updated.
  """
  patch: TripRegionPatch!
  regionId: UUID!
  tripId: UUID!
}

"""The output of our update `TripRegion` mutation."""
type UpdateTripRegionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Region` that is related to this `TripRegion`."""
  region: Region

  """Reads a single `Trip` that is related to this `TripRegion`."""
  trip: Trip

  """The `TripRegion` that was updated by this mutation."""
  tripRegion: TripRegion

  """An edge for our `TripRegion`. May be used by Relay 1."""
  tripRegionEdge(
    """The method to use when ordering `TripRegion`."""
    orderBy: [TripRegionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripRegionsEdge
}

"""All input for the `updateTripTags` mutation."""
input UpdateTripTagsInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  created: [String]
  removed: [UUID]
  selected: [UUID]
  tripId: UUID!
}

"""The output of our `updateTripTags` mutation."""
type UpdateTripTagsPayload {
  """Reads a single `Client` that is related to this `Trip`."""
  client: Client

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Currency` that is related to this `Trip`."""
  currency: Currency

  """Reads a single `Asset` that is related to this `Trip`."""
  image: Asset

  """Reads a single `Organisation` that is related to this `Trip`."""
  organisation: Organisation

  """Reads a single `User` that is related to this `Trip`."""
  owner: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Trip` that is related to this `Trip`."""
  source: Trip
  trip: Trip

  """An edge for our `Trip`. May be used by Relay 1."""
  tripEdge(
    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsEdge
}

"""All input for the `updateUserByNodeId` mutation."""
input UpdateUserByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  patch: UserPatch!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """Reads a single `Asset` that is related to this `User`."""
  avatar: Asset

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """Reads a single `Country` that is related to this `User`."""
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """The `User` that was updated by this mutation."""
  user: User

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUserPreferenceByNodeId` mutation."""
input UpdateUserPreferenceByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `UserPreference` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `UserPreference` being updated.
  """
  patch: UserPreferencePatch!
}

"""All input for the `updateUserPreference` mutation."""
input UpdateUserPreferenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `UserPreference` being updated.
  """
  patch: UserPreferencePatch!
  userId: UUID!
}

"""The output of our update `UserPreference` mutation."""
type UpdateUserPreferencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `UserPreference`."""
  user: User

  """The `UserPreference` that was updated by this mutation."""
  userPreference: UserPreference

  """An edge for our `UserPreference`. May be used by Relay 1."""
  userPreferenceEdge(
    """The method to use when ordering `UserPreference`."""
    orderBy: [UserPreferencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): UserPreferencesEdge
}

type UpgradedStat {
  byOrigin: [UpgradesByOrigin]
  totalGratis: BigInt
  totalTrial: BigInt
  totalUpgraded: BigInt
}

type UpgradesByOrigin {
  origin: SubscriptionOrigin
  totalTrial: BigInt
  totalUpgraded: BigInt
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User implements Node {
  """Reads a single `Account` that is related to this `User`."""
  account: Account

  """When this item was archived"""
  archivedAt: Datetime

  """Reads and enables pagination through a set of `Asset`."""
  assetsByOwnerId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssetFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Asset`."""
    orderBy: [AssetsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AssetsConnection!

  """Reads and enables pagination through a set of `Asset`."""
  assetsByOwnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AssetCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AssetFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Asset`."""
    orderBy: [AssetsOrderBy!]
  ): [Asset!]!
  attachmentVisibilitySettings(tripId: UUID!): AttachmentVisibilitySetting

  """Reads and enables pagination through a set of `Attachment`."""
  attachmentsByOwnerId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttachmentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AttachmentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AttachmentsConnection!

  """Reads and enables pagination through a set of `Attachment`."""
  attachmentsByOwnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AttachmentCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: AttachmentFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Attachment`."""
    orderBy: [AttachmentsOrderBy!]
  ): [Attachment!]!
  attachmentsVisible(tripId: UUID!): Boolean

  """Reads and enables pagination through a set of `Client`."""
  authoredClients(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientsConnection!

  """Reads and enables pagination through a set of `Client`."""
  authoredClientsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Client`."""
    orderBy: [ClientsOrderBy!]
  ): [Client!]!

  """Reads and enables pagination through a set of `Meta`."""
  authoredMetas(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!] = [PRIMARY_KEY_ASC]
  ): MetasConnection!

  """Reads and enables pagination through a set of `Meta`."""
  authoredMetasList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MetaCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: MetaFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Meta`."""
    orderBy: [MetasOrderBy!]
  ): [Meta!]!

  """Reads and enables pagination through a set of `Supplier`."""
  authoredSuppliers(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuppliersConnection!

  """Reads and enables pagination through a set of `Supplier`."""
  authoredSuppliersList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SupplierCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SupplierFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Supplier`."""
    orderBy: [SuppliersOrderBy!]
  ): [Supplier!]!

  """Reads a single `Asset` that is related to this `User`."""
  avatar: Asset
  avatarId: UUID

  """Reads and enables pagination through a set of `Card`."""
  cardsByOwnerId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CardsConnection!

  """Reads and enables pagination through a set of `Card`."""
  cardsByOwnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CardCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CardFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Card`."""
    orderBy: [CardsOrderBy!]
  ): [Card!]!

  """Reads and enables pagination through a set of `ClientPerson`."""
  clientPeople(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientPersonCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientPersonFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `ClientPerson`."""
    orderBy: [ClientPeopleOrderBy!] = [PRIMARY_KEY_ASC]
  ): ClientPeopleConnection!

  """Reads and enables pagination through a set of `ClientPerson`."""
  clientPeopleList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ClientPersonCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: ClientPersonFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `ClientPerson`."""
    orderBy: [ClientPeopleOrderBy!]
  ): [ClientPerson!]!
  collaborationRole(tripId: UUID!): CollaborationRole

  """Reads and enables pagination through a set of `Collaborator`."""
  collaborators(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CollaboratorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CollaboratorFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Collaborator`."""
    orderBy: [CollaboratorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CollaboratorsConnection!

  """Reads and enables pagination through a set of `Collaborator`."""
  collaboratorsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CollaboratorCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: CollaboratorFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Collaborator`."""
    orderBy: [CollaboratorsOrderBy!]
  ): [Collaborator!]!

  """Reads a single `Country` that is related to this `User`."""
  country: Country
  countryId: UUID

  """When this item was created"""
  createdAt: Datetime

  """Reads and enables pagination through a set of `EditLock`."""
  editLocks(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EditLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EditLockFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `EditLock`."""
    orderBy: [EditLocksOrderBy!] = [PRIMARY_KEY_ASC]
  ): EditLocksConnection!

  """Reads and enables pagination through a set of `EditLock`."""
  editLocksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EditLockCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: EditLockFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `EditLock`."""
    orderBy: [EditLocksOrderBy!]
  ): [EditLock!]!
  firstName: String @deprecated(reason: "Use `name` instead")
  friendlyName: String

  """Reads and enables pagination through a set of `GratisUsed`."""
  gratisUseds(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratisUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratisUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): GratisUsedsConnection!

  """Reads and enables pagination through a set of `GratisUsed`."""
  gratisUsedsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: GratisUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: GratisUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `GratisUsed`."""
    orderBy: [GratisUsedsOrderBy!]
  ): [GratisUsed!]!
  id: UUID!

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String @deprecated(reason: "Use `name` instead")
  name: String

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """Reads and enables pagination through a set of `OrganisationInvite`."""
  organisationInvites(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationInviteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationInviteFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationInvitesConnection!

  """Reads and enables pagination through a set of `OrganisationInvite`."""
  organisationInvitesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationInviteCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationInviteFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OrganisationInvite`."""
    orderBy: [OrganisationInvitesOrderBy!]
  ): [OrganisationInvite!]!

  """Reads and enables pagination through a set of `OrganisationUser`."""
  organisations(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationUserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `OrganisationUser`."""
    orderBy: [OrganisationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): OrganisationUsersConnection!

  """Reads and enables pagination through a set of `OrganisationUser`."""
  organisationsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: OrganisationUserCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: OrganisationUserFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `OrganisationUser`."""
    orderBy: [OrganisationUsersOrderBy!]
  ): [OrganisationUser!]!
  preferredName: String

  """Reads and enables pagination through a set of `PromoCodeAffiliate`."""
  promoCodeAffiliates(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeAffiliateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeAffiliateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeAffiliatesConnection!

  """Reads and enables pagination through a set of `PromoCodeAffiliate`."""
  promoCodeAffiliatesList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeAffiliateCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeAffiliateFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCodeAffiliate`."""
    orderBy: [PromoCodeAffiliatesOrderBy!]
  ): [PromoCodeAffiliate!]!

  """Reads and enables pagination through a set of `PromoCodeUsed`."""
  promoCodeUseds(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `PromoCodeUsed`."""
    orderBy: [PromoCodeUsedsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PromoCodeUsedsConnection!

  """Reads and enables pagination through a set of `PromoCodeUsed`."""
  promoCodeUsedsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PromoCodeUsedCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: PromoCodeUsedFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `PromoCodeUsed`."""
    orderBy: [PromoCodeUsedsOrderBy!]
  ): [PromoCodeUsed!]!

  """When this item was restored"""
  restoredAt: Datetime

  """Reads a single `Setting` that is related to this `User`."""
  setting: Setting @deprecated(reason: "Use Trip.appearance")
  statistics: JSON

  """Reads and enables pagination through a set of `SubscriptionLog`."""
  subscriptionLogs(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SubscriptionLogFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionLogsConnection!

  """Reads and enables pagination through a set of `SubscriptionLog`."""
  subscriptionLogsList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionLogCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: SubscriptionLogFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `SubscriptionLog`."""
    orderBy: [SubscriptionLogsOrderBy!]
  ): [SubscriptionLog!]!

  """Reads and enables pagination through a set of `Task`."""
  tasks(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!] = [PRIMARY_KEY_ASC]
  ): TasksConnection!

  """Reads and enables pagination through a set of `Task`."""
  tasksList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TaskCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TaskFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Task`."""
    orderBy: [TasksOrderBy!]
  ): [Task!]!

  """Reads and enables pagination through a set of `Trip`."""
  tripsByOwnerId(
    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TripsConnection!

  """Reads and enables pagination through a set of `Trip`."""
  tripsByOwnerIdList(
    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TripCondition

    """
    A filter to be used in determining which values should be returned by the collection.
    """
    filter: TripFilter

    """Only read the first `n` values of the set."""
    first: Int

    """Skip the first `n` values."""
    offset: Int

    """The method to use when ordering `Trip`."""
    orderBy: [TripsOrderBy!]
  ): [Trip!]!

  """When this item was updated"""
  updatedAt: Datetime

  """Reads a single `UserPreference` that is related to this `User`."""
  userPreference: UserPreference
}

"""The `asset` to be created by this mutation."""
input UserAvatarIdFkeyAssetCreateInput {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""Input for the nested mutation of `asset` in the `UserInput` mutation."""
input UserAvatarIdFkeyInput {
  """The primary key(s) for `asset` for the far side of the relationship."""
  connectById: AssetAssetPkeyConnect

  """The primary key(s) for `asset` for the far side of the relationship."""
  connectByNodeId: AssetNodeIdConnect

  """
  A `AssetInput` object that will be created and connected to this object.
  """
  create: UserAvatarIdFkeyAssetCreateInput

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteById: AssetAssetPkeyDelete

  """The primary key(s) for `asset` for the far side of the relationship."""
  deleteByNodeId: AssetNodeIdDelete

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateById: AssetOnUserForUserAvatarIdFkeyUsingAssetPkeyUpdate

  """
  The primary key(s) and patch data for `asset` for the far side of the relationship.
  """
  updateByNodeId: UserOnUserForUserAvatarIdFkeyNodeIdUpdate
}

"""Input for the nested mutation of `user` in the `AssetInput` mutation."""
input UserAvatarIdFkeyInverseInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: [UserUserPkeyConnect!]

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: [UserNodeIdConnect!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: [UserOnUserForUserAvatarIdFkeyUsingUserPkeyUpdate!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: [AssetOnUserForUserAvatarIdFkeyNodeIdUpdate!]
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `archivedAt` field."""
  archivedAt: Datetime

  """Checks for equality with the object’s `avatarId` field."""
  avatarId: UUID

  """Checks for equality with the object’s `countryId` field."""
  countryId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `isArchived` field."""
  isArchived: Boolean

  """Checks for equality with the object’s `isPublic` field."""
  isPublic: Boolean

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `preferredName` field."""
  preferredName: String

  """Checks for equality with the object’s `restoredAt` field."""
  restoredAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `UserCountPerCountry` values."""
type UserCountPerCountriesConnection {
  """
  A list of edges which contains the `UserCountPerCountry` and cursor to aid in pagination.
  """
  edges: [UserCountPerCountriesEdge!]!

  """A list of `UserCountPerCountry` objects."""
  nodes: [UserCountPerCountry!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `UserCountPerCountry` you could get from the connection.
  """
  totalCount: Int!
}

"""A `UserCountPerCountry` edge in the connection."""
type UserCountPerCountriesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserCountPerCountry` at the end of the edge."""
  node: UserCountPerCountry!
}

"""Methods to use when ordering `UserCountPerCountry`."""
enum UserCountPerCountriesOrderBy {
  COUNTRY_ASC
  COUNTRY_DESC
  COUNT_ASC
  COUNT_DESC
  NATURAL
}

type UserCountPerCountry {
  count: BigInt
  country: String
}

"""
A condition to be used against `UserCountPerCountry` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input UserCountPerCountryCondition {
  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `country` field."""
  country: String
}

"""
A filter to be used against `UserCountPerCountry` object types. All fields are combined with a logical ‘and.’
"""
input UserCountPerCountryFilter {
  """Checks for all expressions in this list."""
  and: [UserCountPerCountryFilter!]

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Filter by the object’s `country` field."""
  country: StringFilter

  """Negates the expression."""
  not: UserCountPerCountryFilter

  """Checks for any expressions in this list."""
  or: [UserCountPerCountryFilter!]
}

"""The `country` to be created by this mutation."""
input UserCountryIdFkeyCountryCreateInput {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
Input for the nested mutation of `country` in the `UserInput` mutation.
"""
input UserCountryIdFkeyInput {
  """The primary key(s) for `country` for the far side of the relationship."""
  connectById: CountryCountryPkeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByName: CountryCountryNameKeyConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectByNodeId: CountryNodeIdConnect

  """The primary key(s) for `country` for the far side of the relationship."""
  connectBySlug: CountryCountrySlugKeyConnect

  """
  A `CountryInput` object that will be created and connected to this object.
  """
  create: UserCountryIdFkeyCountryCreateInput

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteById: CountryCountryPkeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByName: CountryCountryNameKeyDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteByNodeId: CountryNodeIdDelete

  """The primary key(s) for `country` for the far side of the relationship."""
  deleteBySlug: CountryCountrySlugKeyDelete

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateById: CountryOnUserForUserCountryIdFkeyUsingCountryPkeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByName: CountryOnUserForUserCountryIdFkeyUsingCountryNameKeyUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateByNodeId: UserOnUserForUserCountryIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `country` for the far side of the relationship.
  """
  updateBySlug: CountryOnUserForUserCountryIdFkeyUsingCountrySlugKeyUpdate
}

"""
Input for the nested mutation of `user` in the `CountryInput` mutation.
"""
input UserCountryIdFkeyInverseInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: [UserUserPkeyConnect!]

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: [UserNodeIdConnect!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: [UserOnUserForUserCountryIdFkeyUsingUserPkeyUpdate!]

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: [CountryOnUserForUserCountryIdFkeyNodeIdUpdate!]
}

"""
A filter to be used against `User` object types. All fields are combined with a logical ‘and.’
"""
input UserFilter {
  """Filter by the object’s `account` relation."""
  account: AccountFilter

  """A related `account` exists."""
  accountExists: Boolean

  """Checks for all expressions in this list."""
  and: [UserFilter!]

  """Filter by the object’s `archivedAt` field."""
  archivedAt: DatetimeFilter

  """Filter by the object’s `assetsByOwnerId` relation."""
  assetsByOwnerId: UserToManyAssetFilter

  """Some related `assetsByOwnerId` exist."""
  assetsByOwnerIdExist: Boolean

  """Filter by the object’s `attachmentsByOwnerId` relation."""
  attachmentsByOwnerId: UserToManyAttachmentFilter

  """Some related `attachmentsByOwnerId` exist."""
  attachmentsByOwnerIdExist: Boolean

  """Filter by the object’s `authoredClients` relation."""
  authoredClients: UserToManyClientFilter

  """Some related `authoredClients` exist."""
  authoredClientsExist: Boolean

  """Filter by the object’s `authoredMetas` relation."""
  authoredMetas: UserToManyMetaFilter

  """Some related `authoredMetas` exist."""
  authoredMetasExist: Boolean

  """Filter by the object’s `authoredSuppliers` relation."""
  authoredSuppliers: UserToManySupplierFilter

  """Some related `authoredSuppliers` exist."""
  authoredSuppliersExist: Boolean

  """Filter by the object’s `avatar` relation."""
  avatar: AssetFilter

  """A related `avatar` exists."""
  avatarExists: Boolean

  """Filter by the object’s `avatarId` field."""
  avatarId: UUIDFilter

  """Filter by the object’s `cardsByOwnerId` relation."""
  cardsByOwnerId: UserToManyCardFilter

  """Some related `cardsByOwnerId` exist."""
  cardsByOwnerIdExist: Boolean

  """Filter by the object’s `clientPeople` relation."""
  clientPeople: UserToManyClientPersonFilter

  """Some related `clientPeople` exist."""
  clientPeopleExist: Boolean

  """Filter by the object’s `collaborators` relation."""
  collaborators: UserToManyCollaboratorFilter

  """Some related `collaborators` exist."""
  collaboratorsExist: Boolean

  """Filter by the object’s `country` relation."""
  country: CountryFilter

  """A related `country` exists."""
  countryExists: Boolean

  """Filter by the object’s `countryId` field."""
  countryId: UUIDFilter

  """Filter by the object’s `createdAt` field."""
  createdAt: DatetimeFilter

  """Filter by the object’s `editLocks` relation."""
  editLocks: UserToManyEditLockFilter

  """Some related `editLocks` exist."""
  editLocksExist: Boolean

  """Filter by the object’s `firstName` field."""
  firstName: StringFilter

  """Filter by the object’s `friendlyName` field."""
  friendlyName: StringFilter

  """Filter by the object’s `gratisUseds` relation."""
  gratisUseds: UserToManyGratisUsedFilter

  """Some related `gratisUseds` exist."""
  gratisUsedsExist: Boolean

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `isArchived` field."""
  isArchived: BooleanFilter

  """Filter by the object’s `isPublic` field."""
  isPublic: BooleanFilter

  """Filter by the object’s `lastName` field."""
  lastName: StringFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: UserFilter

  """Checks for any expressions in this list."""
  or: [UserFilter!]

  """Filter by the object’s `organisationInvites` relation."""
  organisationInvites: UserToManyOrganisationInviteFilter

  """Some related `organisationInvites` exist."""
  organisationInvitesExist: Boolean

  """Filter by the object’s `organisations` relation."""
  organisations: UserToManyOrganisationUserFilter

  """Some related `organisations` exist."""
  organisationsExist: Boolean

  """Filter by the object’s `preferredName` field."""
  preferredName: StringFilter

  """Filter by the object’s `promoCodeAffiliates` relation."""
  promoCodeAffiliates: UserToManyPromoCodeAffiliateFilter

  """Some related `promoCodeAffiliates` exist."""
  promoCodeAffiliatesExist: Boolean

  """Filter by the object’s `promoCodeUseds` relation."""
  promoCodeUseds: UserToManyPromoCodeUsedFilter

  """Some related `promoCodeUseds` exist."""
  promoCodeUsedsExist: Boolean

  """Filter by the object’s `restoredAt` field."""
  restoredAt: DatetimeFilter

  """Filter by the object’s `setting` relation."""
  setting: SettingFilter

  """A related `setting` exists."""
  settingExists: Boolean

  """Filter by the object’s `subscriptionLogs` relation."""
  subscriptionLogs: UserToManySubscriptionLogFilter

  """Some related `subscriptionLogs` exist."""
  subscriptionLogsExist: Boolean

  """Filter by the object’s `tasks` relation."""
  tasks: UserToManyTaskFilter

  """Some related `tasks` exist."""
  tasksExist: Boolean

  """Filter by the object’s `tripsByOwnerId` relation."""
  tripsByOwnerId: UserToManyTripFilter

  """Some related `tripsByOwnerId` exist."""
  tripsByOwnerIdExist: Boolean

  """Filter by the object’s `updatedAt` field."""
  updatedAt: DatetimeFilter

  """Filter by the object’s `userPreference` relation."""
  userPreference: UserPreferenceFilter

  """A related `userPreference` exists."""
  userPreferenceExists: Boolean
}

"""The globally unique `ID` look up for the row to connect."""
input UserNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnAccountForAccountUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `account` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `account` being updated.
  """
  patch: AccountPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnAccountForAccountUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnAccountForAccountUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnAssetForAssetOwnerIdNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnAssetForAssetOwnerIdUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnAssetForAssetOwnerIdPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnAttachmentForAttachmentOwnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `attachment` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `attachment` being updated.
  """
  patch: AttachmentPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnAttachmentForAttachmentOwnerIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnAttachmentForAttachmentOwnerIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnCardForCardOwnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `card` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `card` being updated.
  """
  patch: CardPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnCardForCardOwnerIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnCardForCardOwnerIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnClientForClientAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `client` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `client` being updated.
  """
  patch: ClientPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnClientForClientAuthorIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnClientForClientAuthorIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnClientPersonForClientPersonUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `clientPerson` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `clientPerson` being updated.
  """
  patch: ClientPersonPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnClientPersonForClientPersonUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnClientPersonForClientPersonUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnCollaboratorForCollaboratorUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `collaborator` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `collaborator` being updated.
  """
  patch: CollaboratorPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnCollaboratorForCollaboratorUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnCollaboratorForCollaboratorUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnEditLockForEditLockUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `editLock` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `editLock` being updated.
  """
  patch: EditLockPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnEditLockForEditLockUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnEditLockForEditLockUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnGratisUsedForGratisUsedUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `gratisUsed` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `gratisUsed` being updated.
  """
  patch: GratisUsedPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnGratisUsedForGratisUsedUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnGratisUsedForGratisUsedUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnMetaForMetadataAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `meta` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `meta` being updated.
  """
  patch: MetaPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnMetaForMetadataAuthorIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnMetaForMetadataAuthorIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnOrganisationInviteForOrganisationInviteUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisationInvite` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisationInvite` being updated.
  """
  patch: OrganisationInvitePatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnOrganisationInviteForOrganisationInviteUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnOrganisationInviteForOrganisationInviteUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnOrganisationUserForOrganisationUserUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `organisationUser` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `organisationUser` being updated.
  """
  patch: OrganisationUserPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnOrganisationUserForOrganisationUserUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnOrganisationUserForOrganisationUserUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCodeAffiliate` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCodeAffiliate` being updated.
  """
  patch: PromoCodeAffiliatePatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnPromoCodeUsedForPromoCodeUsedUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `promoCodeUsed` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `promoCodeUsed` being updated.
  """
  patch: PromoCodeUsedPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnPromoCodeUsedForPromoCodeUsedUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnPromoCodeUsedForPromoCodeUsedUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnSettingForSettingsUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `setting` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `setting` being updated.
  """
  patch: SettingPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnSettingForSettingsUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnSettingForSettingsUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnSubscriptionLogForSubscriptionLogUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `subscriptionLog` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `subscriptionLog` being updated.
  """
  patch: SubscriptionLogPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnSubscriptionLogForSubscriptionLogUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnSubscriptionLogForSubscriptionLogUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnSupplierForSupplierAuthorIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `supplier` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `supplier` being updated.
  """
  patch: SupplierPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnSupplierForSupplierAuthorIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnSupplierForSupplierAuthorIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnTaskForTaskUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `task` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `task` being updated.
  """
  patch: TaskPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnTaskForTaskUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnTaskForTaskUserIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnTripForTripOwnerIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `trip` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `trip` being updated.
  """
  patch: TripPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnTripForTripOwnerIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnTripForTripOwnerIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserForUserAvatarIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnUserForUserAvatarIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserForUserAvatarIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserForUserCountryIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `country` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `country` being updated.
  """
  patch: CountryPatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnUserForUserCountryIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserForUserCountryIdFkeyPatch!
}

"""The globally unique `ID` look up for the row to update."""
input UserOnUserPreferenceForUserPreferenceUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `userPreference` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `userPreference` being updated.
  """
  patch: UserPreferencePatch!
}

"""The fields on `user` to look up the row to update."""
input UserOnUserPreferenceForUserPreferenceUserIdFkeyUsingUserPkeyUpdate {
  id: UUID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: updateUserOnUserPreferenceForUserPreferenceUserIdFkeyPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

type UserPreference implements Node {
  flightNotifications: Boolean

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  taskNotifications: Boolean
  tripNotifications: Boolean

  """Reads a single `User` that is related to this `UserPreference`."""
  user: User
  userId: UUID!
}

"""
A filter to be used against `UserPreference` object types. All fields are combined with a logical ‘and.’
"""
input UserPreferenceFilter {
  """Checks for all expressions in this list."""
  and: [UserPreferenceFilter!]

  """Filter by the object’s `flightNotifications` field."""
  flightNotifications: BooleanFilter

  """Negates the expression."""
  not: UserPreferenceFilter

  """Checks for any expressions in this list."""
  or: [UserPreferenceFilter!]

  """Filter by the object’s `taskNotifications` field."""
  taskNotifications: BooleanFilter

  """Filter by the object’s `tripNotifications` field."""
  tripNotifications: BooleanFilter

  """Filter by the object’s `user` relation."""
  user: UserFilter

  """Filter by the object’s `userId` field."""
  userId: UUIDFilter
}

"""The globally unique `ID` look up for the row to connect."""
input UserPreferenceNodeIdConnect {
  """
  The globally unique `ID` which identifies a single `userPreference` to be connected.
  """
  nodeId: ID!
}

"""The globally unique `ID` look up for the row to update."""
input UserPreferenceOnUserPreferenceForUserPreferenceUserIdFkeyNodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `user` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `user` being updated.
  """
  patch: UserPatch!
}

"""The fields on `userPreference` to look up the row to update."""
input UserPreferenceOnUserPreferenceForUserPreferenceUserIdFkeyUsingUserPreferencePkeyUpdate {
  """
  An object where the defined keys will be set on the `userPreference` being updated.
  """
  patch: updateUserPreferenceOnUserPreferenceForUserPreferenceUserIdFkeyPatch!
  userId: UUID!
}

"""
Represents an update to a `UserPreference`. Fields that are set will be updated.
"""
input UserPreferencePatch {
  flightNotifications: Boolean
  taskNotifications: Boolean
  tripNotifications: Boolean
  user: UserPreferenceUserIdFkeyInput
  userId: UUID
}

"""
Input for the nested mutation of `user` in the `UserPreferenceInput` mutation.
"""
input UserPreferenceUserIdFkeyInput {
  """The primary key(s) for `user` for the far side of the relationship."""
  connectById: UserUserPkeyConnect

  """The primary key(s) for `user` for the far side of the relationship."""
  connectByNodeId: UserNodeIdConnect

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateById: UserOnUserPreferenceForUserPreferenceUserIdFkeyUsingUserPkeyUpdate

  """
  The primary key(s) and patch data for `user` for the far side of the relationship.
  """
  updateByNodeId: UserPreferenceOnUserPreferenceForUserPreferenceUserIdFkeyNodeIdUpdate
}

"""
Input for the nested mutation of `userPreference` in the `UserInput` mutation.
"""
input UserPreferenceUserIdFkeyInverseInput {
  """
  The primary key(s) for `userPreference` for the far side of the relationship.
  """
  connectByNodeId: UserPreferenceNodeIdConnect

  """
  The primary key(s) for `userPreference` for the far side of the relationship.
  """
  connectByUserId: UserPreferenceUserPreferencePkeyConnect

  """
  The primary key(s) and patch data for `userPreference` for the far side of the relationship.
  """
  updateByNodeId: UserOnUserPreferenceForUserPreferenceUserIdFkeyNodeIdUpdate

  """
  The primary key(s) and patch data for `userPreference` for the far side of the relationship.
  """
  updateByUserId: UserPreferenceOnUserPreferenceForUserPreferenceUserIdFkeyUsingUserPreferencePkeyUpdate
}

"""The fields on `userPreference` to look up the row to connect."""
input UserPreferenceUserPreferencePkeyConnect {
  userId: UUID!
}

"""A `UserPreference` edge in the connection."""
type UserPreferencesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UserPreference` at the end of the edge."""
  node: UserPreference!
}

"""Methods to use when ordering `UserPreference`."""
enum UserPreferencesOrderBy {
  FLIGHT_NOTIFICATIONS_ASC
  FLIGHT_NOTIFICATIONS_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  TASK_NOTIFICATIONS_ASC
  TASK_NOTIFICATIONS_DESC
  TRIP_NOTIFICATIONS_ASC
  TRIP_NOTIFICATIONS_DESC
  USER_ID_ASC
  USER_ID_DESC
}

"""
A filter to be used against many `Asset` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyAssetFilter {
  """
  Every related `Asset` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AssetFilter

  """
  No related `Asset` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AssetFilter

  """
  Some related `Asset` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AssetFilter
}

"""
A filter to be used against many `Attachment` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyAttachmentFilter {
  """
  Every related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: AttachmentFilter

  """
  No related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: AttachmentFilter

  """
  Some related `Attachment` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: AttachmentFilter
}

"""
A filter to be used against many `Card` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyCardFilter {
  """
  Every related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CardFilter

  """
  No related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CardFilter

  """
  Some related `Card` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CardFilter
}

"""
A filter to be used against many `Client` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyClientFilter {
  """
  Every related `Client` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ClientFilter

  """
  No related `Client` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ClientFilter

  """
  Some related `Client` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ClientFilter
}

"""
A filter to be used against many `ClientPerson` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyClientPersonFilter {
  """
  Every related `ClientPerson` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: ClientPersonFilter

  """
  No related `ClientPerson` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: ClientPersonFilter

  """
  Some related `ClientPerson` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: ClientPersonFilter
}

"""
A filter to be used against many `Collaborator` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyCollaboratorFilter {
  """
  Every related `Collaborator` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: CollaboratorFilter

  """
  No related `Collaborator` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: CollaboratorFilter

  """
  Some related `Collaborator` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: CollaboratorFilter
}

"""
A filter to be used against many `EditLock` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyEditLockFilter {
  """
  Every related `EditLock` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: EditLockFilter

  """
  No related `EditLock` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: EditLockFilter

  """
  Some related `EditLock` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: EditLockFilter
}

"""
A filter to be used against many `GratisUsed` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyGratisUsedFilter {
  """
  Every related `GratisUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: GratisUsedFilter

  """
  No related `GratisUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: GratisUsedFilter

  """
  Some related `GratisUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: GratisUsedFilter
}

"""
A filter to be used against many `Meta` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyMetaFilter {
  """
  Every related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: MetaFilter

  """
  No related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: MetaFilter

  """
  Some related `Meta` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: MetaFilter
}

"""
A filter to be used against many `OrganisationInvite` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyOrganisationInviteFilter {
  """
  Every related `OrganisationInvite` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationInviteFilter

  """
  No related `OrganisationInvite` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationInviteFilter

  """
  Some related `OrganisationInvite` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationInviteFilter
}

"""
A filter to be used against many `OrganisationUser` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyOrganisationUserFilter {
  """
  Every related `OrganisationUser` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: OrganisationUserFilter

  """
  No related `OrganisationUser` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: OrganisationUserFilter

  """
  Some related `OrganisationUser` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: OrganisationUserFilter
}

"""
A filter to be used against many `PromoCodeAffiliate` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyPromoCodeAffiliateFilter {
  """
  Every related `PromoCodeAffiliate` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PromoCodeAffiliateFilter

  """
  No related `PromoCodeAffiliate` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PromoCodeAffiliateFilter

  """
  Some related `PromoCodeAffiliate` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PromoCodeAffiliateFilter
}

"""
A filter to be used against many `PromoCodeUsed` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyPromoCodeUsedFilter {
  """
  Every related `PromoCodeUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: PromoCodeUsedFilter

  """
  No related `PromoCodeUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: PromoCodeUsedFilter

  """
  Some related `PromoCodeUsed` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: PromoCodeUsedFilter
}

"""
A filter to be used against many `SubscriptionLog` object types. All fields are combined with a logical ‘and.’
"""
input UserToManySubscriptionLogFilter {
  """
  Every related `SubscriptionLog` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SubscriptionLogFilter

  """
  No related `SubscriptionLog` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SubscriptionLogFilter

  """
  Some related `SubscriptionLog` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SubscriptionLogFilter
}

"""
A filter to be used against many `Supplier` object types. All fields are combined with a logical ‘and.’
"""
input UserToManySupplierFilter {
  """
  Every related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: SupplierFilter

  """
  No related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: SupplierFilter

  """
  Some related `Supplier` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: SupplierFilter
}

"""
A filter to be used against many `Task` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTaskFilter {
  """
  Every related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TaskFilter

  """
  No related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TaskFilter

  """
  Some related `Task` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TaskFilter
}

"""
A filter to be used against many `Trip` object types. All fields are combined with a logical ‘and.’
"""
input UserToManyTripFilter {
  """
  Every related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  every: TripFilter

  """
  No related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  none: TripFilter

  """
  Some related `Trip` matches the filter criteria. All fields are combined with a logical ‘and.’
  """
  some: TripFilter
}

"""The fields on `user` to look up the row to connect."""
input UserUserPkeyConnect {
  id: UUID!
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """A list of `User` objects."""
  nodes: [User!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User!
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  ARCHIVED_AT_ASC
  ARCHIVED_AT_DESC
  AVATAR_ID_ASC
  AVATAR_ID_DESC
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  ID_ASC
  ID_DESC
  IS_ARCHIVED_ASC
  IS_ARCHIVED_DESC
  IS_PUBLIC_ASC
  IS_PUBLIC_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PREFERRED_NAME_ASC
  PREFERRED_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RESTORED_AT_ASC
  RESTORED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
}

type UsersOverTime {
  count: BigInt
  date: Datetime
}

"""
A condition to be used against `UsersOverTime` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input UsersOverTimeCondition {
  """Checks for equality with the object’s `count` field."""
  count: BigInt

  """Checks for equality with the object’s `date` field."""
  date: Datetime
}

"""
A filter to be used against `UsersOverTime` object types. All fields are combined with a logical ‘and.’
"""
input UsersOverTimeFilter {
  """Checks for all expressions in this list."""
  and: [UsersOverTimeFilter!]

  """Filter by the object’s `count` field."""
  count: BigIntFilter

  """Filter by the object’s `date` field."""
  date: DatetimeFilter

  """Negates the expression."""
  not: UsersOverTimeFilter

  """Checks for any expressions in this list."""
  or: [UsersOverTimeFilter!]
}

"""A connection to a list of `UsersOverTime` values."""
type UsersOverTimesConnection {
  """
  A list of edges which contains the `UsersOverTime` and cursor to aid in pagination.
  """
  edges: [UsersOverTimesEdge!]!

  """A list of `UsersOverTime` objects."""
  nodes: [UsersOverTime!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `UsersOverTime` you could get from the connection."""
  totalCount: Int!
}

"""A `UsersOverTime` edge in the connection."""
type UsersOverTimesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `UsersOverTime` at the end of the edge."""
  node: UsersOverTime!
}

"""Methods to use when ordering `UsersOverTime`."""
enum UsersOverTimesOrderBy {
  COUNT_ASC
  COUNT_DESC
  DATE_ASC
  DATE_DESC
  NATURAL
}

"""All input for the `verify` mutation."""
input VerifyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  code: String!
}

"""The output of our `verify` mutation."""
type VerifyPayload {
  boolean: Boolean

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

type ViewerOrganisation {
  id: UUID

  """Reads a single `Asset` that is related to this `ViewerOrganisation`."""
  logo: Asset
  logoId: UUID
  name: String
  primaryColour: String
  secondaryColour: String
}

"""
A condition to be used against `ViewerOrganisation` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ViewerOrganisationCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `logoId` field."""
  logoId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `primaryColour` field."""
  primaryColour: String

  """Checks for equality with the object’s `secondaryColour` field."""
  secondaryColour: String
}

"""
A filter to be used against `ViewerOrganisation` object types. All fields are combined with a logical ‘and.’
"""
input ViewerOrganisationFilter {
  """Checks for all expressions in this list."""
  and: [ViewerOrganisationFilter!]

  """Filter by the object’s `id` field."""
  id: UUIDFilter

  """Filter by the object’s `logo` relation."""
  logo: AssetFilter

  """A related `logo` exists."""
  logoExists: Boolean

  """Filter by the object’s `logoId` field."""
  logoId: UUIDFilter

  """Filter by the object’s `name` field."""
  name: StringFilter

  """Negates the expression."""
  not: ViewerOrganisationFilter

  """Checks for any expressions in this list."""
  or: [ViewerOrganisationFilter!]

  """Filter by the object’s `primaryColour` field."""
  primaryColour: StringFilter

  """Filter by the object’s `secondaryColour` field."""
  secondaryColour: StringFilter
}

"""The globally unique `ID` look up for the row to update."""
input ViewerOrganisationOnViewerOrganisationForFakePublicViewerOrganisationsForeignKey0NodeIdUpdate {
  """
  The globally unique `ID` which identifies a single `asset` to be connected.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `asset` being updated.
  """
  patch: AssetPatch!
}

"""A connection to a list of `ViewerOrganisation` values."""
type ViewerOrganisationsConnection {
  """
  A list of edges which contains the `ViewerOrganisation` and cursor to aid in pagination.
  """
  edges: [ViewerOrganisationsEdge!]!

  """A list of `ViewerOrganisation` objects."""
  nodes: [ViewerOrganisation!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ViewerOrganisation` you could get from the connection.
  """
  totalCount: Int!
}

"""A `ViewerOrganisation` edge in the connection."""
type ViewerOrganisationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ViewerOrganisation` at the end of the edge."""
  node: ViewerOrganisation!
}

"""Methods to use when ordering `ViewerOrganisation`."""
enum ViewerOrganisationsOrderBy {
  ID_ASC
  ID_DESC
  LOGO_ID_ASC
  LOGO_ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_COLOUR_ASC
  PRIMARY_COLOUR_DESC
  SECONDARY_COLOUR_ASC
  SECONDARY_COLOUR_DESC
}

type ViewerStatistic {
  continents: Int
  countries: Int
  country: String
  month: Int
  nights: Int
  trips: Int
}

"""
An object where the defined keys will be set on the `account` being updated.
"""
input updateAccountOnAccountForAccountUserIdFkeyPatch {
  email: String
  emailConfirmed: Datetime

  """Lists features the user has early access to"""
  featurePreview: [String]

  """The date their account will be reverted to free tier"""
  gratisEndDate: Datetime

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  phone: String
  role: Role
  stripeCustomerId: String
  tier: Tier
  user: AccountUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `airport` being updated.
"""
input updateAirportOnAirportForAirportCountryIdFkeyPatch {
  cityName: String
  country: AirportCountryIdFkeyInput
  facebook: String
  iata: String
  instagram: String
  linkedin: String
  location: LocationInput
  name: String
  namesI18N: JSON
  phone: String
  timezoneName: String
  twitter: String
  website: String
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnAssetForAssetOwnerIdPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnCardForCardImageIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnCountryForCountryImageIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnOrganisationForOrganisationLogoIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnPartnerPageForPartnerPageBackgroundIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnRegionForRegionImageIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnSupplierForSupplierLogoIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnTripAssetImageForTripAssetImageAssetIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnTripForTripImageIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnUserForUserAvatarIdFkeyPatch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `asset` being updated.
"""
input updateAssetOnViewerOrganisationForFakePublicViewerOrganisationsForeignKey0Patch {
  attribution: AssetAttributionInput
  cards: CardImageIdFkeyInverseInput
  countries: CountryImageIdFkeyInverseInput
  file: Upload
  id: UUID
  organisations: OrganisationLogoIdFkeyInverseInput
  ownerId: UUID
  partnerPagesToBackgroundIdUsingId: PartnerPageBackgroundIdFkeyInverseInput
  partnerPagesToLogoIdUsingId: PartnerPageLogoIdFkeyInverseInput
  referrersToBackgroundIdUsingId: FakePublicReferrerForeignKey1InverseInput
  referrersToLogoIdUsingId: FakePublicReferrerForeignKey0InverseInput
  regions: RegionImageIdFkeyInverseInput
  suppliers: SupplierLogoIdFkeyInverseInput
  trips: TripAssetImageAssetIdFkeyInverseInput
  user: AssetOwnerIdInput
  users: UserAvatarIdFkeyInverseInput
  viewerOrganisations: FakePublicViewerOrganisationsForeignKey0InverseInput
}

"""
An object where the defined keys will be set on the `attachment` being updated.
"""
input updateAttachmentOnAttachmentForAttachmentCardIdFkeyPatch {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `attachment` being updated.
"""
input updateAttachmentOnAttachmentForAttachmentOwnerIdFkeyPatch {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  trip: AttachmentTripIdFkeyInput
  tripId: UUID
  user: AttachmentOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `attachment` being updated.
"""
input updateAttachmentOnAttachmentForAttachmentTripIdFkeyPatch {
  attachment: Upload
  card: AttachmentCardIdFkeyInput
  cardId: UUID
  id: UUID
  ownerId: UUID
  trip: AttachmentTripIdFkeyInput
  user: AttachmentOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `cardCost` being updated.
"""
input updateCardCostOnCardCostForCardCostCardIdFkeyPatch {
  card: CardCostCardIdFkeyInput
  costTax: CardCostCostTaxFkeyInput
  costType: CostType
  discount: Float
  id: UUID
}

"""
An object where the defined keys will be set on the `cardCost` being updated.
"""
input updateCardCostOnCardCostForCardCostCostTaxFkeyPatch {
  card: CardCostCardIdFkeyInput
  cardId: UUID
  costType: CostType
  discount: Float
  id: UUID
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnAttachmentForAttachmentCardIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCardCostForCardCostCardIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCardForCardCurrencyIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCardForCardImageIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCardForCardOwnerIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCardForCardParentIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCardForCardTripIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnCostItemForCostItemCardIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `card` being updated.
"""
input updateCardOnTaskForTaskCardIdFkeyPatch {
  attachments: AttachmentCardIdFkeyInverseInput
  budget: Float
  card: CardParentIdFkeyInput
  cardCost: CardCostCardIdFkeyInverseInput
  contentSorting: JSON
  costItems: CostItemCardIdFkeyInverseInput
  currency: CardCurrencyIdFkeyInput
  currencyId: UUID
  dailyBudget: Float
  dailyDeposit: Float
  day: Int
  deposit: Float

  """The number of days this card repeats"""
  duration: Int

  """Defines how the duration is handled"""
  durationType: CardDurationType
  enableImage: Boolean
  enableMap: Boolean
  endAlert: Boolean
  endAlertOffset: Int
  endTime: Time
  flightNumber: String
  id: UUID
  image: CardImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  notes: String
  ownerId: UUID
  parentId: UUID
  placeId: String
  sorting: Int
  startAlert: Boolean
  startAlertOffset: Int
  startTime: Time
  status: CardStatus
  subType: CardSubType
  tasks: TaskCardIdFkeyInverseInput
  trip: CardTripIdFkeyInput
  tripId: UUID
  type: CardType
  user: CardOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `client` being updated.
"""
input updateClientOnClientForClientAuthorIdFkeyPatch {
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType
  user: ClientAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `client` being updated.
"""
input updateClientOnClientForClientOrganisationIdFkeyPatch {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  organisation: ClientOrganisationIdFkeyInput
  trips: TripClientIdFkeyInverseInput
  type: ClientType
  user: ClientAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `client` being updated.
"""
input updateClientOnClientOrganisationForClientOrganisationIdFkey1Patch {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType
  user: ClientAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `client` being updated.
"""
input updateClientOnClientPersonForClientPersonIdFkeyPatch {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType
  user: ClientAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `client` being updated.
"""
input updateClientOnTripForTripClientIdFkeyPatch {
  authorId: UUID
  clientOrganisation: ClientOrganisationIdFkey1InverseInput
  clientPerson: ClientPersonIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  organisation: ClientOrganisationIdFkeyInput
  organisationId: UUID
  trips: TripClientIdFkeyInverseInput
  type: ClientType
  user: ClientAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `clientOrganisationContact` being updated.
"""
input updateClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyPatch {
  clientOrganisation: ClientOrganisationContactOrganisationIdFkeyInput
  clientPerson: ClientOrganisationContactPersonIdFkeyInput
  isPrimary: Boolean
  personId: UUID
  role: String
}

"""
An object where the defined keys will be set on the `clientOrganisationContact` being updated.
"""
input updateClientOrganisationContactOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyPatch {
  clientOrganisation: ClientOrganisationContactOrganisationIdFkeyInput
  clientPerson: ClientOrganisationContactPersonIdFkeyInput
  isPrimary: Boolean
  organisationId: UUID
  role: String
}

"""
An object where the defined keys will be set on the `clientOrganisation` being updated.
"""
input updateClientOrganisationOnClientOrganisationContactForClientOrganisationContactOrganisationIdFkeyPatch {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String
}

"""
An object where the defined keys will be set on the `clientOrganisation` being updated.
"""
input updateClientOrganisationOnClientOrganisationForClientOrganisationIdFkey1Patch {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String
}

"""
An object where the defined keys will be set on the `clientOrganisation` being updated.
"""
input updateClientOrganisationOnMetaForMetadataClientOrganisationIdFkeyPatch {
  client: ClientOrganisationIdFkey1Input
  contact: ClientOrganisationContactOrganisationIdFkeyInverseInput
  id: UUID
  metadata: MetadataClientOrganisationIdFkeyInverseInput
  name: String
}

"""
An object where the defined keys will be set on the `clientPerson` being updated.
"""
input updateClientPersonOnClientOrganisationContactForClientOrganisationContactPersonIdFkeyPatch {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `clientPerson` being updated.
"""
input updateClientPersonOnClientPersonForClientPersonIdFkeyPatch {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String
  givenName: String
  honorific: Honorific
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `clientPerson` being updated.
"""
input updateClientPersonOnClientPersonForClientPersonUserIdFkeyPatch {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String
  preferredName: String
  user: ClientPersonUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `clientPerson` being updated.
"""
input updateClientPersonOnMetaForMetadataClientPersonIdFkeyPatch {
  client: ClientPersonIdFkeyInput
  contact: ClientOrganisationContactPersonIdFkeyInverseInput
  familyName: String
  givenName: String
  honorific: Honorific
  id: UUID
  metadata: MetadataClientPersonIdFkeyInverseInput
  name: String
  preferredName: String
  user: ClientPersonUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `collaborator` being updated.
"""
input updateCollaboratorOnCollaboratorForCollaboratorTripIdFkeyPatch {
  permissions: [Permission]
  role: CollaborationRole
  trip: CollaboratorTripIdFkeyInput
  user: CollaboratorUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `collaborator` being updated.
"""
input updateCollaboratorOnCollaboratorForCollaboratorUserIdFkeyPatch {
  permissions: [Permission]
  role: CollaborationRole
  trip: CollaboratorTripIdFkeyInput
  tripId: UUID
  user: CollaboratorUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `continent` being updated.
"""
input updateContinentOnCountryForCountryContinentIdFkeyPatch {
  countries: CountryContinentIdFkeyInverseInput
  id: UUID
  name: String
}

"""
An object where the defined keys will be set on the `costItem` being updated.
"""
input updateCostItemOnCostItemForCostItemCardIdFkeyPatch {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""
An object where the defined keys will be set on the `costItem` being updated.
"""
input updateCostItemOnCostItemForCostItemCostCurrencyIdFkeyPatch {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""
An object where the defined keys will be set on the `costItem` being updated.
"""
input updateCostItemOnCostItemForCostItemCostTaxIdFkeyPatch {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  organisationId: UUID
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""
An object where the defined keys will be set on the `costItem` being updated.
"""
input updateCostItemOnCostItemForCostItemOrganisationIdFkeyPatch {
  agentProfit: Float
  card: CostItemCardIdFkeyInput
  cardId: UUID
  costConverted: Float
  costCurrencyId: UUID
  costTax: CostItemCostTaxIdFkeyInput
  costTaxId: UUID
  costType: CostType
  costValue: Float
  currency: CostItemCostCurrencyIdFkeyInput
  discountPercent: Float
  discountQuantity: Int
  id: UUID
  organisation: CostItemOrganisationIdFkeyInput
  primaryQuantity: Int
  primaryType: String
  secondaryQuantity: Int
  secondaryType: String
}

"""
An object where the defined keys will be set on the `costTax` being updated.
"""
input updateCostTaxOnCardCostForCardCostCostTaxFkeyPatch {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float
}

"""
An object where the defined keys will be set on the `costTax` being updated.
"""
input updateCostTaxOnCostItemForCostItemCostTaxIdFkeyPatch {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float
}

"""
An object where the defined keys will be set on the `costTax` being updated.
"""
input updateCostTaxOnCostTaxForCostTaxOrganisationIdFkeyPatch {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  organisation: CostTaxOrganisationIdFkeyInput
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float
}

"""
An object where the defined keys will be set on the `costTax` being updated.
"""
input updateCostTaxOnOrganisationForOrganisationCostTaxIdFkeyPatch {
  cardCosts: CardCostCostTaxFkeyInverseInput
  costItems: CostItemCostTaxIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  organisation: CostTaxOrganisationIdFkeyInput
  organisationId: UUID
  organisations: OrganisationCostTaxIdFkeyInverseInput
  value: Float
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnAirportForAirportCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnCountryForCountryContinentIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnCountryForCountryImageIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnLanguageCountryForLanguageCountryCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnOrganisationForOrganisationCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnOutletCountryForOutletCountryCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnRegionForRegionCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnTripCountryForTripCountryCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `country` being updated.
"""
input updateCountryOnUserForUserCountryIdFkeyPatch {
  airports: AirportCountryIdFkeyInverseInput
  averageTemperature: JSON
  colloquial: String
  continent: CountryContinentIdFkeyInput
  continentId: UUID
  currencies: CurrencyCountryCountryIdFkeyInverseInput
  id: UUID
  image: CountryImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  iso: String
  iso3: String
  languages: LanguageCountryCountryIdFkeyInverseInput
  location: LocationInput
  name: String
  organisations: OrganisationCountryIdFkeyInverseInput
  outlets: OutletCountryCountryIdFkeyInverseInput
  regions: RegionCountryIdFkeyInverseInput
  slug: String
  synonyms: String
  trips: TripCountryCountryIdFkeyInverseInput
  users: UserCountryIdFkeyInverseInput
  voltage: String
}

"""
An object where the defined keys will be set on the `currencyCountry` being updated.
"""
input updateCurrencyCountryOnCurrencyCountryForCurrencyCountryCountryIdFkeyPatch {
  country: CurrencyCountryCountryIdFkeyInput
  currency: CurrencyCountryCurrencyIdFkeyInput
  currencyId: UUID
  sorting: Int
}

"""
An object where the defined keys will be set on the `currencyCountry` being updated.
"""
input updateCurrencyCountryOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyPatch {
  country: CurrencyCountryCountryIdFkeyInput
  countryId: UUID
  currency: CurrencyCountryCurrencyIdFkeyInput
  sorting: Int
}

"""
An object where the defined keys will be set on the `currency` being updated.
"""
input updateCurrencyOnCardForCardCurrencyIdFkeyPatch {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `currency` being updated.
"""
input updateCurrencyOnCostItemForCostItemCostCurrencyIdFkeyPatch {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `currency` being updated.
"""
input updateCurrencyOnCurrencyCountryForCurrencyCountryCurrencyIdFkeyPatch {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `currency` being updated.
"""
input updateCurrencyOnOrganisationForOrganisationCurrencyIdFkeyPatch {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `currency` being updated.
"""
input updateCurrencyOnTripForTripCurrencyIdFkeyPatch {
  cards: CardCurrencyIdFkeyInverseInput

  """Conversion rate to EUR"""
  conversionRate: Float
  costItems: CostItemCostCurrencyIdFkeyInverseInput
  countries: CurrencyCountryCurrencyIdFkeyInverseInput
  id: UUID
  iso: String
  name: String
  organisations: OrganisationCurrencyIdFkeyInverseInput
  trips: TripCurrencyIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `editLock` being updated.
"""
input updateEditLockOnEditLockForEditLockUserIdFkeyPatch {
  key: String
  user: EditLockUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `grati` being updated.
"""
input updateGratiOnGratisUsedForGratisUsedGratisIdFkeyPatch {
  """The code users must enter to use the gratis"""
  code: String

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime
  gratisUseds: GratisUsedGratisIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPageGratisIdFkeyInverseInput

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""
An object where the defined keys will be set on the `grati` being updated.
"""
input updateGratiOnPartnerPageForPartnerPageGratisIdFkeyPatch {
  """The code users must enter to use the gratis"""
  code: String

  """The number of months the user gets for free"""
  duration: Int

  """The date the code becomes unusable"""
  expiresAt: Datetime
  gratisUseds: GratisUsedGratisIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPageGratisIdFkeyInverseInput

  """The total number of uses the code can have (null means infinite)"""
  uses: Int

  """The date the code becomes usable"""
  validFrom: Datetime
}

"""
An object where the defined keys will be set on the `gratisUsed` being updated.
"""
input updateGratisUsedOnGratisUsedForGratisUsedGratisIdFkeyPatch {
  createdAt: Datetime
  grati: GratisUsedGratisIdFkeyInput
  user: GratisUsedUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `gratisUsed` being updated.
"""
input updateGratisUsedOnGratisUsedForGratisUsedUserIdFkeyPatch {
  createdAt: Datetime
  grati: GratisUsedGratisIdFkeyInput
  gratisId: UUID
  user: GratisUsedUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `inviteV2` being updated.
"""
input updateInviteV2OnInviteV2ForInviteTripIdFkeyPatch {
  code: String
  email: String
  expires: Datetime
  id: UUID
  permissions: [Permission]
  role: CollaborationRole
  trip: InviteTripIdFkeyInput
}

"""
An object where the defined keys will be set on the `languageCountry` being updated.
"""
input updateLanguageCountryOnLanguageCountryForLanguageCountryCountryIdFkeyPatch {
  country: LanguageCountryCountryIdFkeyInput
  language: LanguageCountryLanguageIdFkeyInput
  languageId: UUID
  sorting: Int
}

"""
An object where the defined keys will be set on the `languageCountry` being updated.
"""
input updateLanguageCountryOnLanguageCountryForLanguageCountryLanguageIdFkeyPatch {
  country: LanguageCountryCountryIdFkeyInput
  countryId: UUID
  language: LanguageCountryLanguageIdFkeyInput
  sorting: Int
}

"""
An object where the defined keys will be set on the `language` being updated.
"""
input updateLanguageOnLanguageCountryForLanguageCountryLanguageIdFkeyPatch {
  countries: LanguageCountryLanguageIdFkeyInverseInput
  id: UUID
  name: String
}

"""
An object where the defined keys will be set on the `meta` being updated.
"""
input updateMetaOnMetaForMetadataAuthorIdFkeyPatch {
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""
An object where the defined keys will be set on the `meta` being updated.
"""
input updateMetaOnMetaForMetadataClientOrganisationIdFkeyPatch {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""
An object where the defined keys will be set on the `meta` being updated.
"""
input updateMetaOnMetaForMetadataClientPersonIdFkeyPatch {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""
An object where the defined keys will be set on the `meta` being updated.
"""
input updateMetaOnMetaForMetadataOrganisationIdFkeyPatch {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  primaryType: MetadataPrimaryType
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  supplierId: UUID
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""
An object where the defined keys will be set on the `meta` being updated.
"""
input updateMetaOnMetaForMetadataSupplierIdFkeyPatch {
  authorId: UUID
  clientOrganisation: MetadataClientOrganisationIdFkeyInput
  clientOrganisationId: UUID
  clientPerson: MetadataClientPersonIdFkeyInput
  clientPersonId: UUID
  id: UUID
  organisation: MetadataOrganisationIdFkeyInput
  organisationId: UUID
  primaryType: MetadataPrimaryType
  secondaryType: MetadataSecondaryType
  supplier: MetadataSupplierIdFkeyInput
  user: MetadataAuthorIdFkeyInput
  value: String
}

"""
An object where the defined keys will be set on the `organisationInvite` being updated.
"""
input updateOrganisationInviteOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyPatch {
  code: String
  email: String
  id: UUID
  name: String
  organisation: OrganisationInviteOrganisationIdFkeyInput
  user: OrganisationInviteUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `organisationInvite` being updated.
"""
input updateOrganisationInviteOnOrganisationInviteForOrganisationInviteUserIdFkeyPatch {
  code: String
  email: String
  id: UUID
  name: String
  organisation: OrganisationInviteOrganisationIdFkeyInput
  organisationId: UUID
  user: OrganisationInviteUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnClientForClientOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnCostItemForCostItemOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnCostTaxForCostTaxOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnMetaForMetadataOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnOrganisationForOrganisationCostTaxIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnOrganisationForOrganisationCountryIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnOrganisationForOrganisationCurrencyIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnOrganisationForOrganisationLogoIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnOrganisationInviteForOrganisationInviteOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnOrganisationUserForOrganisationUserOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnSupplierForSupplierOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnTagForTagOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisation` being updated.
"""
input updateOrganisationOnTripForTripOrganisationIdFkeyPatch {
  clients: ClientOrganisationIdFkeyInverseInput
  costItems: CostItemOrganisationIdFkeyInverseInput
  costTax: OrganisationCostTaxIdFkeyInput
  costTaxId: UUID
  costTaxes: CostTaxOrganisationIdFkeyInverseInput
  costType: CostType
  country: OrganisationCountryIdFkeyInput
  countryId: UUID
  currency: OrganisationCurrencyIdFkeyInput
  currencyId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean

  """Added to the cap defined by the organisations tier"""
  itineraryCapAdditional: Int
  logo: OrganisationLogoIdFkeyInput
  logoId: UUID
  metas: MetadataOrganisationIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteOrganisationIdFkeyInverseInput
  phone: String

  """Must be a valid 3 or 6 char hex, including hash"""
  primaryColour: String
  proposalDefaultMessage: String
  requireTermsAcceptance: Boolean

  """Must be a valid 3 or 6 char hex, including hash"""
  secondaryColour: String
  supplierDefaultMessage: String
  suppliers: SupplierOrganisationIdFkeyInverseInput
  tags: TagOrganisationIdFkeyInverseInput

  """Added to the cap defined by the organisations tier"""
  templateCapAdditional: Int
  terms: String
  tierId: UUID
  trips: TripOrganisationIdFkeyInverseInput
  users: OrganisationUserOrganisationIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `organisationUser` being updated.
"""
input updateOrganisationUserOnOrganisationUserForOrganisationUserOrganisationIdFkeyPatch {
  organisation: OrganisationUserOrganisationIdFkeyInput
  role: OrganisationUserRole
  user: OrganisationUserUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `organisationUser` being updated.
"""
input updateOrganisationUserOnOrganisationUserForOrganisationUserUserIdFkeyPatch {
  organisation: OrganisationUserOrganisationIdFkeyInput
  organisationId: UUID
  role: OrganisationUserRole
  user: OrganisationUserUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `outletCountry` being updated.
"""
input updateOutletCountryOnOutletCountryForOutletCountryCountryIdFkeyPatch {
  country: OutletCountryCountryIdFkeyInput
  outlet: OutletCountryOutletIdFkeyInput
  outletId: UUID
  sorting: Int
}

"""
An object where the defined keys will be set on the `outletCountry` being updated.
"""
input updateOutletCountryOnOutletCountryForOutletCountryOutletIdFkeyPatch {
  country: OutletCountryCountryIdFkeyInput
  countryId: UUID
  outlet: OutletCountryOutletIdFkeyInput
  sorting: Int
}

"""
An object where the defined keys will be set on the `outlet` being updated.
"""
input updateOutletOnOutletCountryForOutletCountryOutletIdFkeyPatch {
  countries: OutletCountryOutletIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  notes: String
}

"""
An object where the defined keys will be set on the `partnerPage` being updated.
"""
input updatePartnerPageOnPartnerPageForPartnerPageBackgroundIdFkeyPatch {
  asset: PartnerPageBackgroundIdFkeyInput
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  name: String
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String
}

"""
An object where the defined keys will be set on the `partnerPage` being updated.
"""
input updatePartnerPageOnPartnerPageForPartnerPageGratisIdFkeyPatch {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  name: String
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String
}

"""
An object where the defined keys will be set on the `partnerPage` being updated.
"""
input updatePartnerPageOnPartnerPageForPartnerPageLogoIdFkeyPatch {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  promoCode: PartnerPagePromoCodeIdFkeyInput
  promoCodeId: UUID
  slug: String
}

"""
An object where the defined keys will be set on the `partnerPage` being updated.
"""
input updatePartnerPageOnPartnerPageForPartnerPagePromoCodeIdFkeyPatch {
  asset: PartnerPageBackgroundIdFkeyInput
  backgroundId: UUID
  bannerBackgroundColour: String
  bannerText: String
  bannerTextColour: String
  grati: PartnerPageGratisIdFkeyInput
  gratisId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  name: String
  promoCode: PartnerPagePromoCodeIdFkeyInput
  slug: String
}

"""
An object where the defined keys will be set on the `promoCodeAffiliate` being updated.
"""
input updatePromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyPatch {
  promoCode: PromoCodeAffiliateIdFkeyInput
  user: PromoCodeAffiliateUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `promoCodeAffiliate` being updated.
"""
input updatePromoCodeAffiliateOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyPatch {
  promoCode: PromoCodeAffiliateIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeAffiliateUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `promoCode` being updated.
"""
input updatePromoCodeOnPartnerPageForPartnerPagePromoCodeIdFkeyPatch {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""
An object where the defined keys will be set on the `promoCode` being updated.
"""
input updatePromoCodeOnPromoCodeAffiliateForPromoCodeAffiliateIdFkeyPatch {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""
An object where the defined keys will be set on the `promoCode` being updated.
"""
input updatePromoCodeOnPromoCodeUsedForPromoCodeUsedIdFkeyPatch {
  """
  The percentage value the affiliate gets from a referred users subscription
  """
  affiliatePercent: Int
  code: String

  """The percentage value the user gets off their first subscription year"""
  discountPercent: Int

  """The time the user gets plus for free"""
  duration: IntervalInput
  expiresAt: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  partnerPages: PartnerPagePromoCodeIdFkeyInverseInput
  promoCodeAffiliates: PromoCodeAffiliateIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedIdFkeyInverseInput
  type: PromoCodeType

  """The max number of uses of this promo code (null == infinite)"""
  uses: Int
  validFrom: Datetime
}

"""
An object where the defined keys will be set on the `promoCodeUsed` being updated.
"""
input updatePromoCodeUsedOnPromoCodeUsedForPromoCodeUsedIdFkeyPatch {
  createdAt: Datetime
  origin: PromoCodeUsedOrigin
  promoCode: PromoCodeUsedIdFkeyInput
  user: PromoCodeUsedUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `promoCodeUsed` being updated.
"""
input updatePromoCodeUsedOnPromoCodeUsedForPromoCodeUsedUserIdFkeyPatch {
  createdAt: Datetime
  origin: PromoCodeUsedOrigin
  promoCode: PromoCodeUsedIdFkeyInput
  promoCodeId: UUID
  user: PromoCodeUsedUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `region` being updated.
"""
input updateRegionOnRegionForRegionCountryIdFkeyPatch {
  country: RegionCountryIdFkeyInput
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `region` being updated.
"""
input updateRegionOnRegionForRegionImageIdFkeyPatch {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `region` being updated.
"""
input updateRegionOnTripRegionForTripRegionRegionIdFkeyPatch {
  country: RegionCountryIdFkeyInput
  countryId: UUID
  id: UUID
  image: RegionImageIdFkeyInput
  imageId: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  location: LocationInput
  name: String
  slug: String
  trips: TripRegionRegionIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `setting` being updated.
"""
input updateSettingOnSettingForSettingsUserIdFkeyPatch {
  boldColours: Boolean
  showImageOnCard: Boolean
  user: SettingsUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `subscriptionLog` being updated.
"""
input updateSubscriptionLogOnSubscriptionLogForSubscriptionLogUserIdFkeyPatch {
  event: String
  id: UUID
  identifier: String
  origin: SubscriptionOrigin
  timestamp: Datetime
  user: SubscriptionLogUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplierCategory` being updated.
"""
input updateSupplierCategoryOnSupplierForSupplierCategoryIdFkeyPatch {
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  suppliers: SupplierCategoryIdFkeyInverseInput
  type: CardType
}

"""
An object where the defined keys will be set on the `supplier` being updated.
"""
input updateSupplierOnMetaForMetadataSupplierIdFkeyPatch {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplier` being updated.
"""
input updateSupplierOnSupplierForSupplierAuthorIdFkeyPatch {
  asset: SupplierLogoIdFkeyInput
  categoryId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplier` being updated.
"""
input updateSupplierOnSupplierForSupplierCategoryIdFkeyPatch {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplier` being updated.
"""
input updateSupplierOnSupplierForSupplierLogoIdFkeyPatch {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplier` being updated.
"""
input updateSupplierOnSupplierForSupplierOrganisationIdFkeyPatch {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplier` being updated.
"""
input updateSupplierOnSupplierTagForSupplierTagSupplierIdFkeyPatch {
  asset: SupplierLogoIdFkeyInput
  authorId: UUID
  categoryId: UUID
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  logoId: UUID
  metadata: MetadataSupplierIdFkeyInverseInput
  name: String
  organisation: SupplierOrganisationIdFkeyInput
  organisationId: UUID
  rating: Int
  supplierCategory: SupplierCategoryIdFkeyInput
  tags: SupplierTagSupplierIdFkeyInverseInput
  type: CardType
  user: SupplierAuthorIdFkeyInput
}

"""
An object where the defined keys will be set on the `supplierTag` being updated.
"""
input updateSupplierTagOnSupplierTagForSupplierTagSupplierIdFkeyPatch {
  supplier: SupplierTagSupplierIdFkeyInput
  tag: SupplierTagTagIdFkeyInput
  tagId: UUID
}

"""
An object where the defined keys will be set on the `supplierTag` being updated.
"""
input updateSupplierTagOnSupplierTagForSupplierTagTagIdFkeyPatch {
  supplier: SupplierTagSupplierIdFkeyInput
  supplierId: UUID
  tag: SupplierTagTagIdFkeyInput
}

"""
An object where the defined keys will be set on the `tag` being updated.
"""
input updateTagOnSupplierTagForSupplierTagTagIdFkeyPatch {
  icon: String
  id: UUID
  name: String
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""
An object where the defined keys will be set on the `tag` being updated.
"""
input updateTagOnTagForTagOrganisationIdFkeyPatch {
  icon: String
  id: UUID
  name: String
  organisation: TagOrganisationIdFkeyInput
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""
An object where the defined keys will be set on the `tag` being updated.
"""
input updateTagOnTagTripForTagTripTagIdFkeyPatch {
  icon: String
  id: UUID
  name: String
  organisation: TagOrganisationIdFkeyInput
  organisationId: UUID
  suppliers: SupplierTagTagIdFkeyInverseInput
  synonyms: String
  trips: TagTripTagIdFkeyInverseInput
  type: TagType
}

"""
An object where the defined keys will be set on the `tagTrip` being updated.
"""
input updateTagTripOnTagTripForTagTripTagIdFkeyPatch {
  tag: TagTripTagIdFkeyInput
  trip: TagTripTripIdFkeyInput
  tripId: UUID
}

"""
An object where the defined keys will be set on the `tagTrip` being updated.
"""
input updateTagTripOnTagTripForTagTripTripIdFkeyPatch {
  tag: TagTripTagIdFkeyInput
  tagId: UUID
  trip: TagTripTripIdFkeyInput
}

"""
An object where the defined keys will be set on the `task` being updated.
"""
input updateTaskOnTaskForTaskCardIdFkeyPatch {
  card: TaskCardIdFkeyInput
  complete: Boolean
  date: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `task` being updated.
"""
input updateTaskOnTaskForTaskTripIdFkeyPatch {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  notes: String
  trip: TaskTripIdFkeyInput
  user: TaskUserIdFkeyInput
  userId: UUID
}

"""
An object where the defined keys will be set on the `task` being updated.
"""
input updateTaskOnTaskForTaskUserIdFkeyPatch {
  card: TaskCardIdFkeyInput
  cardId: UUID
  complete: Boolean
  date: Datetime
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  name: String
  notes: String
  trip: TaskTripIdFkeyInput
  tripId: UUID
  user: TaskUserIdFkeyInput
}

"""
An object where the defined keys will be set on the `tripAssetImage` being updated.
"""
input updateTripAssetImageOnTripAssetImageForTripAssetImageAssetIdFkeyPatch {
  asset: TripAssetImageAssetIdFkeyInput
  sorting: Int
  trip: TripAssetImageTripIdFkeyInput
  tripId: UUID
}

"""
An object where the defined keys will be set on the `tripAssetImage` being updated.
"""
input updateTripAssetImageOnTripAssetImageForTripAssetImageTripIdFkeyPatch {
  asset: TripAssetImageAssetIdFkeyInput
  assetId: UUID
  sorting: Int
  trip: TripAssetImageTripIdFkeyInput
}

"""
An object where the defined keys will be set on the `tripCountry` being updated.
"""
input updateTripCountryOnTripCountryForTripCountryCountryIdFkeyPatch {
  country: TripCountryCountryIdFkeyInput
  trip: TripCountryTripIdFkeyInput
  tripId: UUID
}

"""
An object where the defined keys will be set on the `tripCountry` being updated.
"""
input updateTripCountryOnTripCountryForTripCountryTripIdFkeyPatch {
  country: TripCountryCountryIdFkeyInput
  countryId: UUID
  trip: TripCountryTripIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnAttachmentForAttachmentTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnCardForCardTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnCollaboratorForCollaboratorTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnInviteV2ForInviteTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTagTripForTagTripTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTaskForTaskTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripAssetImageForTripAssetImageTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripCountryForTripCountryTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripForTripClientIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripForTripCurrencyIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripForTripOrganisationIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripForTripOwnerIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripForTripSourceIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `trip` being updated.
"""
input updateTripOnTripRegionForTripRegionTripIdFkeyPatch {
  attachments: AttachmentTripIdFkeyInverseInput
  budget: Float
  budgetType: [BudgetType]
  cards: CardTripIdFkeyInverseInput
  class: TripClass
  client: TripClientIdFkeyInput
  clientId: UUID
  collaboratorCount: Int
  collaboratorsV2: CollaboratorTripIdFkeyInverseInput
  countries: TripCountryTripIdFkeyInverseInput
  currency: TripCurrencyIdFkeyInput
  currencyId: UUID
  days: Int
  description: String
  enableIdeas: Boolean
  endDate: Date
  highlights: JSON
  id: UUID
  image: TripImageIdFkeyInput
  imageId: UUID
  images: TripAssetImageTripIdFkeyInverseInput
  introduction: String
  inviteV2s: InviteTripIdFkeyInverseInput

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  legacyPaymentExpiry: Datetime
  legacyTier: Tier
  name: String
  notes: String
  organisation: TripOrganisationIdFkeyInput
  organisationId: UUID
  ownerId: UUID
  regions: TripRegionTripIdFkeyInverseInput
  sourceId: UUID
  startDate: Date
  status: TripStatus
  tags: TagTripTripIdFkeyInverseInput
  tasks: TaskTripIdFkeyInverseInput
  trip: TripSourceIdFkeyInput
  type: [TripType]
  user: TripOwnerIdFkeyInput
}

"""
An object where the defined keys will be set on the `tripRegion` being updated.
"""
input updateTripRegionOnTripRegionForTripRegionRegionIdFkeyPatch {
  region: TripRegionRegionIdFkeyInput
  trip: TripRegionTripIdFkeyInput
  tripId: UUID
}

"""
An object where the defined keys will be set on the `tripRegion` being updated.
"""
input updateTripRegionOnTripRegionForTripRegionTripIdFkeyPatch {
  region: TripRegionRegionIdFkeyInput
  regionId: UUID
  trip: TripRegionTripIdFkeyInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnAccountForAccountUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnAssetForAssetOwnerIdPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnAttachmentForAttachmentOwnerIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnCardForCardOwnerIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnClientForClientAuthorIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnClientPersonForClientPersonUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnCollaboratorForCollaboratorUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnEditLockForEditLockUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnGratisUsedForGratisUsedUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnMetaForMetadataAuthorIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnOrganisationInviteForOrganisationInviteUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnOrganisationUserForOrganisationUserUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnPromoCodeAffiliateForPromoCodeAffiliateUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnPromoCodeUsedForPromoCodeUsedUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnSettingForSettingsUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnSubscriptionLogForSubscriptionLogUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnSupplierForSupplierAuthorIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnTaskForTaskUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnTripForTripOwnerIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserForUserAvatarIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserForUserCountryIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `user` being updated.
"""
input updateUserOnUserPreferenceForUserPreferenceUserIdFkeyPatch {
  account: AccountUserIdFkeyInverseInput
  assets: AssetOwnerIdInverseInput
  attachments: AttachmentOwnerIdFkeyInverseInput
  avatar: UserAvatarIdFkeyInput
  avatarId: UUID
  cards: CardOwnerIdFkeyInverseInput
  clientPeople: ClientPersonUserIdFkeyInverseInput
  clients: ClientAuthorIdFkeyInverseInput
  collaborators: CollaboratorUserIdFkeyInverseInput
  country: UserCountryIdFkeyInput
  countryId: UUID
  editLocks: EditLockUserIdFkeyInverseInput
  firstName: String
  gratisUseds: GratisUsedUserIdFkeyInverseInput
  id: UUID

  """Whether or not this item is archived (soft-deleted)"""
  isArchived: Boolean
  isPublic: Boolean
  lastName: String
  metas: MetadataAuthorIdFkeyInverseInput
  name: String
  organisationInvites: OrganisationInviteUserIdFkeyInverseInput
  organisations: OrganisationUserUserIdFkeyInverseInput
  preferredName: String
  promoCodeAffiliates: PromoCodeAffiliateUserIdFkeyInverseInput
  promoCodeUseds: PromoCodeUsedUserIdFkeyInverseInput
  setting: SettingsUserIdFkeyInverseInput
  subscriptionLogs: SubscriptionLogUserIdFkeyInverseInput
  suppliers: SupplierAuthorIdFkeyInverseInput
  tasks: TaskUserIdFkeyInverseInput
  trips: TripOwnerIdFkeyInverseInput
  userPreference: UserPreferenceUserIdFkeyInverseInput
}

"""
An object where the defined keys will be set on the `userPreference` being updated.
"""
input updateUserPreferenceOnUserPreferenceForUserPreferenceUserIdFkeyPatch {
  flightNotifications: Boolean
  taskNotifications: Boolean
  tripNotifications: Boolean
  user: UserPreferenceUserIdFkeyInput
}
